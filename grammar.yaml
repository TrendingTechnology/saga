information_for_contributors:
  - This file is a grammar for the Saga programming language, whose syntax is
  - inspired by Python, Ruby, OCaml, Nim, Elixir, F#, Go, Swift, Bash, and Smalltalk.

  - Should you want to provide a fix or improvement, or even a new feature,
  - please create a pull request against this repo - https://github.com/nxltm/saga
  - and I will be very happy to receive them.

  - Once accepted, I am happy to receive your request and feedback.

  - This document is under construction, and might take several weeks/months
  - to edit.

  - Updates:
      - |
        Only _ out of all Unicode `Pc` symbols are considered letters.
        The rest are considered operator characters.
      - Add YAML/Bash unquoted literals

  - Bugs:
      - In code sample "x ().int", does not highlight ".int" part as method call
      - Fix code highlighting for YAML-like syntax
      - |
        In backslash code literals, "\:" only the last `:` should not be parsed
        in type annotations such as "(3 + 4): int" or object keys such as `int:`

  - To-do:
      - Add object/list/map destructuring syntax
      - Add color, date/time, advanced numeric literals and more.

  - Doing:
      - Add standard library stuff (the bulk of this grammar)
      - - Python, PHP, Perl, CSS, HTML, JS, TS, Swift, R, C, C++,
        - Bash, Shell, SQL and more
        - Dictionaries from https://github.com/nxltm/cspell-dicts:
            - Java, Scala
            - Golang, C++
            - Python/Django
            - TypeScript
        - NumPy, Pandas, NLTK, Gensim and more (see libraries in action)

  - Done:
      - Revamp string, number, symbol and regex literals
      - Fixed pipeline/composition operator highlighting
      - Added
      - Fixed highlighting for pipeline operator
      - Added syntax for bracket-less function/method calls
      - Rework regex syntax (brackets)

name: Saga
scopeName: source.coffee
fileTypes: [saga, coffee]
patterns: [{include: "#core"}]

repository:
  define:
    entity-name: &entity-name |
      (?x)\s*\b
      (?!
      \b(?:# don't match keywords
      in|of|as|is|new|infer|unset
      |typeof|nameof|sizeof|keyof|valof
      |len|del|to|til|thru|at|by
      |and|x?or|not|para|series|spawn
      |def|func?|fn|macro|proc|sub
      |let|var|val|const|decl
      |class|given|law|enum|rel|lat
      |proj|prot|ext|impl|frag|inter|struct
      |module|nspace|object|record|label
      |raw|data|query|schema|style|trait|alias|type
      |if|else|elif|eless|unless|guard
      |for|each|while|until|repeat|do|redo
      |switch|case|fail|match|when|pass
      |try|retry|throw|raise|catch|rescue|finally
      |with|ref|defer|refer|show|hide|enter|exit
      |then|begin|end|debug|check|assert
      |break|continue|halt|skip|(?:return|give|await|yield|throw|raise)s?
      |yield\b\s*\bfrom|import|export|show|hide
      |from|where|join|equals|[io]nto|order
      |take|drop|fold|scan|select|use|using
      |fi|rof|done|esac|wend|yrt|kill|wout
      |open|close
      )\b
      )
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      \b

  core:
    patterns:
      - include: "#definitions"
      - include: "#clauses"
      - include: "#comments"
      - include: "#brackets"
      - include: "#literals"
      - include: "#type-annotation"
      - include: "#punctuation"
      - include: "#operators"
      - include: "#keywords"
      - include: "#calls"
      - include: "#variables"
      - include: "#illegal"

  illegal:
    - match: .+
      name: invalid.illegal.syntax.saga

  clause-content:
    patterns:
      - include: "#punctuation"
      - include: "#definitions"
      - include: "#clauses"
      - include: "#comments"
      - include: "#brackets"
      - include: "#literals"
      - include: "#operators"
      - include: "#keywords"
      - include: "#calls"
      - include: "#variables"

  entities:
    patterns:
      - include: "#function-names"
      - include: "#constant-names"
      - include: "#type-names"

    repository:
      function-names:
        comment: Names for built-in functions
        patterns: []

      method-names:
        comment: Names for static and instance methods
        patterns: []

      constant-names:
        comment: Names for constants, symbols and static properties
        patterns: []

      type-names:
        comment: Names for types and more
        patterns: []

      variable-names:
        comment: Standard Library variable names
        patterns: []

      property-names:
        comment: Standard Library property names
        patterns: []

  literals:
    patterns:
      - include: "#symbols"
      - include: "#constants"
      - include: "#numbers"
      - include: "#strings"
      - include: "#regexps"

  constants:
    patterns:
      - match: |
          (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(?:
          (true|yes|on)|(false|no|off)|(null|nil|none)|(undef|void)|(nan)|(inf|infin)
          )\b
        captures:
          1: {name: constant.language.boolean.true.saga}
          2: {name: constant.language.boolean.false.saga}
          3: {name: constant.language.null.saga}
          4: {name: constant.language.undefined.saga}
          5: {name: constant.language.nan.saga}
          6: {name: constant.language.infinity.saga}
      - match: |
          (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(?:
          (params|args)|(super|this|self|proto)|(\\proto|main)|(ctor)|(targ)
          )\b
        captures:
          1: {name: variable.language.arguments.saga}
          2: {name: variable.language.$2.saga}
          3: {name: variable.language.prototype.saga}
          4: {name: variable.language.constructor.saga}
          5: {name: variable.language.target.saga}

  numbers:
    patterns:
      - match: (?<=(^|\p{ps})\s*\d\w*)\.
        name: punctuation.separator.decimal.period.saga
      - match: (?<=(?:^|\p{ps})\s*|\s)\.(?=\d)
        name: punctuation.separator.decimal.period.saga
      - match: (?xi)\s*\b0b(?:[01][01_]*[01]?)?(?:(\.)[01][01_]*[01]?)(?:(r)[01][01_]*[01]?)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?\s*\b
        captures:
          0: {name: constant.numeric.binary.saga}
          1: {name: meta.delimiter.decimal.period.saga}
          2: {name: storage.type.numeric.bigint.saga}
          3: {name: storage.type.numeric.bigint.saga}
          4: {name: storage.type.numeric.bigint.saga}
          5: {name: storage.type.numeric.bigint.saga}
      - match: (?xi)\s*\b0b[01][01_]*[01]?(?:(\.)[01][01_]*[01]?)?(?:(r)[01][01_]*[01]?)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?\s*\b
        captures:
          0: {name: constant.numeric.binary.saga}
          1: {name: meta.delimiter.decimal.period.saga}
          2: {name: storage.type.numeric.bigint.saga}
          3: {name: storage.type.numeric.bigint.saga}
          4: {name: storage.type.numeric.bigint.saga}
          5: {name: storage.type.numeric.bigint.saga}
      - match: (?xi)\s*\b0q(?:[0-3][0-3_]*[0-3]?)?(?:(\.)[0-3][0-3_]*[0-3]?)(?:(r)[0-3][0-3_]*[0-3]?)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?\s*\b
        captures:
          0: {name: constant.numeric.quaternary.saga}
          1: {name: meta.delimiter.decimal.period.saga}
          2: {name: storage.type.numeric.bigint.saga}
          3: {name: storage.type.numeric.bigint.saga}
          4: {name: storage.type.numeric.bigint.saga}
          5: {name: storage.type.numeric.bigint.saga}
      - match: (?xi)\s*\b0q[0-3][0-3_]*[0-3]?(?:(\.)[0-3][0-3_]*[0-3]?)?(?:(r)[0-3][0-3_]*[0-3]?)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?\s*\b
        captures:
          0: {name: constant.numeric.quaternary.saga}
          1: {name: meta.delimiter.decimal.period.saga}
          2: {name: storage.type.numeric.bigint.saga}
          3: {name: storage.type.numeric.bigint.saga}
          4: {name: storage.type.numeric.bigint.saga}
          5: {name: storage.type.numeric.bigint.saga}
      - match: (?xi)\s*\b0s(?:[0-5][0-5_]*[0-5]?)?(?:(\.)[0-5][0-5_]*[0-5]?)(?:(r)[0-5][0-5_]*[0-5]?)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?\s*\b
        captures:
          0: {name: constant.numeric.senary.saga}
          1: {name: meta.delimiter.decimal.period.saga}
          2: {name: storage.type.numeric.bigint.saga}
          3: {name: storage.type.numeric.bigint.saga}
          4: {name: storage.type.numeric.bigint.saga}
          5: {name: storage.type.numeric.bigint.saga}
      - match: (?xi)\s*\b0s[0-5][0-5_]*[0-5]?(?:(\.)[0-5][0-5_]*[0-5]?)?(?:(r)[0-5][0-5_]*[0-5]?)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?\s*\b
        captures:
          0: {name: constant.numeric.senary.saga}
          1: {name: meta.delimiter.decimal.period.saga}
          2: {name: storage.type.numeric.bigint.saga}
          3: {name: storage.type.numeric.bigint.saga}
          4: {name: storage.type.numeric.bigint.saga}
          5: {name: storage.type.numeric.bigint.saga}
      - match: (?xi)\s*\b0o(?:[0-7][0-7_]*[0-7]?)?(?:(\.)[0-7][0-7_]*[0-7]?)(?:(r)[0-7][0-7_]*[0-7]?)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?\s*\b
        captures:
          0: {name: constant.numeric.octal.saga}
          1: {name: meta.delimiter.decimal.period.saga}
          2: {name: storage.type.numeric.bigint.saga}
          3: {name: storage.type.numeric.bigint.saga}
          4: {name: storage.type.numeric.bigint.saga}
          5: {name: storage.type.numeric.bigint.saga}
      - match: (?xi)\s*\b0o[0-7][0-7_]*[0-7]?(?:(\.)[0-7][0-7_]*[0-7]?)?(?:(r)[0-7][0-7_]*[0-7]?)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?\s*\b
        captures:
          0: {name: constant.numeric.octal.saga}
          1: {name: meta.delimiter.decimal.period.saga}
          2: {name: storage.type.numeric.bigint.saga}
          3: {name: storage.type.numeric.bigint.saga}
          4: {name: storage.type.numeric.bigint.saga}
          5: {name: storage.type.numeric.bigint.saga}
      - match: (?xi)\s*\b0z(?:[\dabetxz][\dabetxz_]*[\dabetxz]?)?(?:(\.)[\dabetxz][\dabetxz_]*[\dabetxz]?)(?:(r)[\dabetxz][\dabetxz_]*[\dabetxz]?)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?\s*\b
        captures:
          0: {name: constant.numeric.duodecimal.saga}
          1: {name: meta.delimiter.decimal.period.saga}
          2: {name: storage.type.numeric.bigint.saga}
          3: {name: storage.type.numeric.bigint.saga}
          4: {name: storage.type.numeric.bigint.saga}
          5: {name: storage.type.numeric.bigint.saga}
      - match: (?xi)\s*\b0z[\dabetxz][\dabetxz_]*[\dabetxz]?(?:(\.)[\dabetxz][\dabetxz_]*[\dabetxz]?)?(?:(r)[\dabetxz][\dabetxz_]*[\dabetxz]?)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?\s*\b
        captures:
          0: {name: constant.numeric.duodecimal.saga}
          1: {name: meta.delimiter.decimal.period.saga}
          2: {name: storage.type.numeric.bigint.saga}
          3: {name: storage.type.numeric.bigint.saga}
          4: {name: storage.type.numeric.bigint.saga}
          5: {name: storage.type.numeric.bigint.saga}
      - match: (?xi)\s*\b0x(?:\h[\h_]*\h?)?(?:(\.)\h[\h_]*\h?)(?:(r)\h[\h_]*\h?)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?\s*\b
        captures:
          0: {name: constant.numeric.hexadecimal.saga}
          1: {name: meta.delimiter.decimal.period.saga}
          2: {name: storage.type.numeric.bigint.saga}
          3: {name: storage.type.numeric.bigint.saga}
          4: {name: storage.type.numeric.bigint.saga}
          5: {name: storage.type.numeric.bigint.saga}
      - match: (?xi)\s*\b0x\h[\h_]*\h?(?:(\.)\h[\h_]*\h?)?(?:(r)\h[\h_]*\h?)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?\s*\b
        captures:
          0: {name: constant.numeric.hexadecimal.saga}
          1: {name: meta.delimiter.decimal.period.saga}
          2: {name: storage.type.numeric.bigint.saga}
          3: {name: storage.type.numeric.bigint.saga}
          4: {name: storage.type.numeric.bigint.saga}
          5: {name: storage.type.numeric.bigint.saga}
      - match: (?xi)\s*\b(?:\d[\d_]*\d?)?(?:(\.)\d[\d_]*\d?)(?:(r)\d[\d_]*\d?)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?\s*\b
        captures:
          0: {name: constant.numeric.decimal.saga}
          1: {name: meta.delimiter.decimal.period.saga}
          2: {name: storage.type.numeric.bigint.saga}
          3: {name: storage.type.numeric.bigint.saga}
          4: {name: storage.type.numeric.bigint.saga}
          5: {name: storage.type.numeric.bigint.saga}
      - match: (?xi)\s*\b\d[\d_]*\d?(?:(\.)\d[\d_]*\d?)?(?:(r)\d[\d_]*\d?)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?\s*\b
        captures:
          0: {name: constant.numeric.decimal.saga}
          1: {name: meta.delimiter.decimal.period.saga}
          2: {name: storage.type.numeric.bigint.saga}
          3: {name: storage.type.numeric.bigint.saga}
          4: {name: storage.type.numeric.bigint.saga}
          5: {name: storage.type.numeric.bigint.saga}
      - match: (?xi)\s*\b\d\w(?:\w[\w_]*\w?)?(?:(\.)\w[\w_]*\w?)(?:(r)\w[\w_]*\w?)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?\s*\b
        captures:
          0: {name: constant.numeric.illegal.saga}
          1: {name: meta.delimiter.decimal.period.saga}
          2: {name: storage.type.numeric.bigint.saga}
          3: {name: storage.type.numeric.bigint.saga}
          4: {name: storage.type.numeric.bigint.saga}
          5: {name: storage.type.numeric.bigint.saga}
      - match: (?xi)\s*\b\d\w\w[\w_]*\w?(?:(\.)\w[\w_]*\w?)?(?:(r)\w[\w_]*\w?)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?\s*\b
        captures:
          0: {name: constant.numeric.illegal.saga}
          1: {name: meta.delimiter.decimal.period.saga}
          2: {name: storage.type.numeric.bigint.saga}
          3: {name: storage.type.numeric.bigint.saga}
          4: {name: storage.type.numeric.bigint.saga}
          5: {name: storage.type.numeric.bigint.saga}

  strings:
    patterns:
      - include: "#string-unquoted"
      - comment: single quoted raw string
        begin: \s*('{3,})
        contentName: string.quoted.single.saga
        end: \s*((\1)(?!\1))
        captures:
          1: {name: punctuation.definition.string.saga}
        patterns:
          - include: "#embedded-raw"
      - comment: simple single quoted raw string
        begin: \s*(')
        contentName: string.quoted.single.saga
        end: \s*((\1)(?!\1))
        captures:
          1: {name: punctuation.definition.string.saga}
        patterns:
          - match: "''"
            name: constant.character.escape.saga
          - include: "#embedded-raw"
      - comment: double quoted standard string
        begin: \s*("{3,}|")
        contentName: string.quoted.double.saga
        end: \s*((\1)(?!\1))
        captures:
          1: {name: punctuation.definition.string.saga}
        patterns:
          - include: "#string-escapes"

  string-escapes:
    patterns:
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.saga
      - match: (?i)\\b(?:[01]{1,21}|{[01\s]+?})
        name: constant.character.escape.binary.saga
      - match: (?i)\\q(?:[0-3]{1,11}|{[0-3\s]+?})
        name: constant.character.escape.quaternary.saga
      - match: (?i)\\s(?:[0-5]{1,8}|{[0-5\s]+?})
        name: constant.character.escape.senary.saga
      - match: (?i)\\o(?:[0-7]{1,7}|{[0-7\s]+?})
        name: constant.character.escape.octal.saga
      - match: (?i)\\d?\d{1,7}|\\d{[\d\s]+?}
        name: constant.character.escape.decimal.saga
      - match: (?i)\\z(?:[\dabetxz]{1,6}|{[\s\dabetxz]+?})
        name: constant.character.escape.duodecimal.saga
      - match: (?i)\\x(?:\h{1,6}|{[\h\s]+?})
        name: constant.character.escape.hexadecimal.saga
      - match: (?i)\\u(?:\h{1,6}|{[\h\s]+?})
        name: constant.character.escape.unicode.saga
      - begin: (?i)\\j{
        end: \s*}
        name: constant.character.entity.named.saga
        patterns:
          - include: "#regexp-patterns"
      - match: (?i)\\[abceflnprtvz]
        name: constant.character.escape.saga
      - match: \\[\p{s}\p{p}]
        name: constant.character.escape.symbol.saga
      - match: \\[\p{l}\p{n}]
        name: constant.character.escape.illegal.saga
      - include: "#embedded"

  embedded:
    patterns:
      - match: (\$)(\d+)
        captures:
          1: {name: punctuation.quasi.element.saga}
          2: {name: constant.numeric.decimal.saga}
      - match: (%)((['"\`])(?:\\\g<-1>|.)*?\g<-1>|\w+(?:[^\s'"\`]+\w+)*)
        captures:
          1: {name: punctuation.separator.key-value.saga}
          2: {name: storage.type.format.saga}
      - match: |
          (?xi)
          #(?<!\\)# no backslash
          (\$)# prefix
          (
          [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
          )# variable
        captures:
          1: {name: punctuation.quasi.element.saga}
          2: {patterns: [{include: $self}]}
      - begin: (?#?<!\\)(\${)\s*
        end: (})
        name: entity.quasi.element.saga
        captures:
          1: {name: punctuation.quasi.element.saga}
        patterns:
          - include: $self

  embedded-raw:
    patterns:
      - match: (\$)(\d+)
        captures:
          1: {name: punctuation.quasi.element.saga}
          2: {name: constant.numeric.decimal.saga}
      - match: ([$%]){2}
        name: constant.character.escape.saga
      - match: (%)((['"\`])(?:\\\g<-1>|.)*?\g<-1>|\w+(?:[^\s'"\`]+\w+)*)
        captures:
          1: {name: punctuation.separator.key-value.saga}
          2: {name: storage.type.format.saga}
      - match: |
          (?xi)
          (?<!\$)# no dollar
          (\$)# prefix
          (
          [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
          )# variable
        captures:
          1: {name: punctuation.quasi.element.saga}
          2: {patterns: [{include: $self}]}
      - begin: (?<!\$)(\${)\s*
        end: (})
        name: entity.quasi.element.saga
        captures:
          1: {name: punctuation.quasi.element.saga}
        patterns:
          - include: $self

  string-unquoted:
    patterns:
      - begin: |
          (?x)
          (\\\\)\s*
          (?:(\d\w+)|
          (
          [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
          )
          )?\s*
          ([-+])?\s*
          (.*\n?)
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.literal.saga}
          2: {patterns: [include: "#numbers"]}
          3: {name: fenced_code.block.language.saga}
          4: {name: storage.modifier.chomping-indicator.saga}
          5:
            patterns:
              - include: "#comments"
              - match: .+
                name: invalid.illegal.expected-comment-or-newline.saga
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^(([ \t])+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.block.saga
            patterns:
              - include: "#embedded-raw"
              - include: text.html.markdown#inline
      - begin: |
          (?x)
          (\/\\)\s*
          (?:(\d\w+)|
          (
          [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
          )
          )?\s*
          ([-+])?\s*
          (.*\n?)
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.folded.saga}
          2: {patterns: [include: "#numbers"]}
          3: {name: fenced_code.block.language.saga}
          4: {name: storage.modifier.chomping-indicator.saga}
          5:
            patterns:
              - include: "#comments"
              - match: .+
                name: invalid.illegal.expected-comment-or-newline.saga
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^(([ \t])+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.plain.in.saga
            patterns:
              - include: "#string-escapes"
              - include: text.html.markdown#inline
      - begin: |
          (?x)
          (\\\/)\s*
          (?:(\w+)?\b\s*\b
          (
          \w+\s*
          (?:[+-]\s*
          (?:(?:\w+)))*
          )
          )?\s*
          ([-+])?\s*
          (.*\n?)
        beginCaptures:
          1: {name: keyword.control.flow.block-scalar.regexp.saga}
          2: {name: keyword.modifier.saga}
          3: {name: keyword.other.flag.saga}
          4: {name: storage.modifier.chomping-indicator.saga}
          5:
            patterns:
              - include: "#comments"
              - match: .+
                name: invalid.illegal.expected-comment-or-newline.saga
        end: ^(?=\S)|(?!\G)
        patterns:
          - begin: ^(([ \t])+)(?!\2)
            end: ^(?!\1|\s*$)
            name: string.unquoted.plain.out.saga
            patterns:
              - include: "#regexp-patterns"
      - match: |
          (?x)
          (?<=^|\p{ps}|\s+)\s*(\\)
          ([^\s,:;'"\`\\\#]+?)
          (?=[\p{ps}\p{pe}]|$|[\s,:;'"\`\\\#])
        name: string.unquoted.saga
        captures:
          1: {name: punctuation.definition.string.saga}
          2: {patterns: [{include: "#string-escapes"}]}

  symbols:
    patterns:
      - match: |
          (?x)
          (?<=^|\p{ps}|\s+)\s*(:)
          ((?:
          [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*
          [_\p{l}\p{m}\p{n}]+)+
          [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,:;'"\`\#]]*
          )
          (?=[\p{ps}\p{pe}]|\s|:+)
        name: meta.symbol.saga
        captures:
          1: {name: punctuation.definition.symbol.saga}
          2: {name: constant.other.symbol.saga}

  labels:
    patterns:
      - match: |
          (?x)
          (
          (?!
          \b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|keyof|valof
          |len|del|to|til|thru|at|by
          |and|x?or|not|para|series|spawn
          |def|func?|fn|macro|proc|sub
          |let|var|val|const|decl
          |class|given|law|enum|rel|lat
          |proj|prot|ext|impl|frag|inter|struct
          |module|nspace|object|record|label
          |raw|data|query|schema|style|trait|alias|type
          |if|else|elif|eless|unless|guard
          |for|each|while|until|repeat|do|redo
          |switch|case|fail|match|when|pass
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |break|continue|halt|skip|(?:return|give|await|yield|throw|raise)s?
          |yield\b\s*\bfrom|import|export|show|hide
          |from|where|join|equals|[io]nto|order
          |take|drop|fold|scan|select|use|using
          |fi|rof|done|esac|wend|yrt|kill|wout
          |open|close
          )\b
          )
          (?:
          [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*
          [_\p{l}\p{m}\p{n}]+)+
          [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,:;'"\`\#]]*
          )
          (:)(?=\s)
        name: meta.object-literal.key.saga
        captures:
          1: {patterns: [{include: "#label-keys"}]}
          2: {name: punctuation.separator.key-value.saga}
    repository:
      label-keys:
        patterns:
          - include: "#number"
          - match: '[^\s:]+'
            name: constant.other.object.key.saga

  document:
    patterns:
      - include: "#document-inline-tags"
      - include: "#document-access"
      - include: "#document-as-name-path"
      - include: "#document-simple-name-path"
      - include: "#document-module"
      - include: "#document-type-name"
      - include: "#document-type-no-name"
      - match: (?<=^|[''"\`\\\s\p{ps}])@([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\b
        name: storage.type.class.saga

    repository:
      document-access:
        match: |
          (?x)
          (@acc)\b\s*\b
          (?:
          (?:
          pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager
          |lawful|rogue|early|late|unique|handle|over|abs|vol|stat|dyn|final
          |[gs]et|[dr]ef|trans|part|rec|gen|(?:im)?pure|local|global|native
          |(?:un)?(?:sign|safe|check|lock|fixed|size)
          |(?:pre|in|post|suf|a[df])fix
          |(?:u|bi|ter|)nary
          )\s*\b
          )*
          (?=\s|$)
        captures:
          1: {name: storage.type.class.saga}
          0: {name: storage.modifier.saga}
      document-as-name-path:
        begin: (@(borrows|lends)\b)\s*(?=(?![}\]]\#)\S+(?:(?:\s*\bas\b\s*(?![}\]]\#)\S+)?)?([\S\s]*))
        end: ^|(?=[}\]]\#)|(?=\3$)
        beginCaptures:
          1: {name: storage.type.class.saga}
        patterns:
          - include: "#document-name-path-scopes"
      document-inline-tags:
        begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
        end: (})
        name: meta.tag.inline.saga
        beginCaptures:
          1: {name: string.linktext.saga}
          2: {name: meta.brace.curly.saga}
        endCaptures:
          1: {name: meta.brace.curly.saga}
        patterns:
          - match: (@(link|tutorial))\b([^}]*)
            captures:
              1: {name: storage.type.class.saga}
              3: {name: string.saga}
      document-module:
        begin: |
          (?x)(@(
          (?:(?:im|ex)port|listen|require|use)s?
          )\b)
          \s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
        end: ^|(?=[}\]]\#)|(?=\5$)
        beginCaptures:
          1: {name: storage.type.class.saga}
        patterns:
          - include: "#document-typedef-scopes"
          - match: (?:(module)(:))?(((?![}\]]\#)\S)+)
            captures:
              1: {name: keyword.module.saga}
              2: {name: punctuation.saga}
              3: {name: string.module-name.saga}
      document-name-scopes:
        patterns:
          - match: ((?![}\]]\#)[\S&&[^\[\]"']])+
            captures:
              0: {name: variable.other.saga}
          - begin: \[
            end: \]|^
            name: variable.other.saga
            patterns:
              - include: "#document-string"
              - include: "#document-name-scopes"
      document-simple-name-path:
        begin: |
          (?x)(@(
          (?:use|call|emit|event|fire)s?|alias|name|mixes|prop
          |this|that|it|self|super
          )\b)
          \s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
        end: ^|(?=[}\]]\#)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.saga}
        patterns:
          - include: "#document-typedef-scopes"
          - include: "#types"
      document-string:
        match: '"(\\"|[^"])*"|''(\\''|[^''])*'''
        name: string.saga
      document-type-name:
        begin: |
          (?x)(@(
          def|func?|fn|macro|proc|sub|class|given|law|const|enum|rel|lat
          |proj|prot|ext|impl|frag|inter|struct|module|nspace|object|record|raw
          |data|query|schema|style|trait|alias|type|decl|let|va[rl]
          |arg|ctor|member|method|mixin|param
          )\b)\s*
          (?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
        end: ^|(?=[}\]]\#)|(?=\7$)
        beginCaptures:
          1: {name: storage.type.class.saga}
        patterns:
          - include: "#document-typedef-scopes"
          - include: "#document-name-scopes"
      document-type-no-name:
        begin: |
          (?x)
          (@(
          pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager
          |lawful|rogue|early|late|unique|handle|over|abs|vol|stat|dyn|final
          |[gs]et|[dr]ef|trans|part|rec|gen|(?:im)?pure|local|global|native
          |(?:un)?(?:sign|safe|check|lock|fixed|size)
          |except|ext|impl|break|continue|halt|skip|(?:return|give|await|yield|throw|raise)s?
          |(?:pre|in|post|suf|a[df])fix
          |(?:u|bi|ter|)nary
          )\b)
          \s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*([\S\s]*))
        end: ^|(?=[}\]]\#)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.saga}
        patterns:
          - include: "#document-typedef-scopes"
      document-typedef-obj:
        begin: "{"
        end: "}|^"
        captures:
          0: {name: meta.brace.curly.saga}
        patterns:
          - include: "#types"
      document-typedef-scopes:
        begin: "{"
        end: "}|^"
        name: entity.name.type.instance.saga
        captures:
          0: {name: meta.brace.curly.saga}
        patterns:
          - include: "#types"

  comments:
    patterns:
      - begin: \s*((#\())
        end: (\s*(\)))
        name: comment.block.inline.saga
        captures:
          1: {name: comment.block.inline.saga}
          2: {name: punctuation.definition.comment.saga}
        patterns:
          - include: "#markdown-inline"
          - include: "#nested-inline"
      - begin: \s*((#{))
        end: (\s*(}#))
        name: comment.block.documentation.saga
        captures:
          1: {name: comment.block.documentation.saga}
          2: {name: punctuation.definition.comment.saga}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
          - include: "#nested-document-block"
      - begin: \s*((#\[))
        end: (\s*(\]#))
        name: comment.block.saga
        captures:
          1: {name: comment.block.saga}
          2: {name: punctuation.definition.comment.saga}
        patterns:
          - include: "#markdown-inline"
          - include: "#nested-block"
      - begin: ((^\s*)|\s*)((#=))
        end: \s*$
        name: comment.line.special.saga
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.saga}
          3: {name: comment.line.special.saga}
          4: {name: punctuation.definition.comment.saga}
        endCaptures:
          1: {name: punctuation.definition.comment.saga}
        patterns:
          - include: "#comment-special"
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((##))
        end: \s*$
        name: comment.line.playground.saga
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.saga}
          3: {name: comment.line.playground.saga}
          4: {name: punctuation.definition.comment.saga}
        endCaptures:
          0: {name: comment.line.playground.saga}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((#:))
        end: \s*$
        name: comment.line.documentation.saga
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.saga}
          3: {name: comment.line.documentation.saga}
          4: {name: punctuation.definition.comment.saga}
        endCaptures:
          0: {name: comment.line.documentation.saga}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((#!))
        end: \s*$
        name: comment.line.shebang.saga
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.saga}
          3: {name: comment.line.shebang.saga}
          4: {name: punctuation.definition.comment.saga}
        endCaptures:
          0: {name: comment.line.shebang.saga}
        patterns:
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((#\?))
        end: \s*$
        name: comment.line.doctype.saga
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.saga}
          3: {name: comment.line.doctype.saga}
          4: {name: punctuation.definition.comment.saga}
        endCaptures:
          0: {name: comment.line.doctype.saga}
        patterns:
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((#))
        end: \s*$
        name: comment.line.number-sign.saga
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.saga}
          3: {name: comment.line.double-slash.saga}
          4: {name: punctuation.definition.comment.saga}
        endCaptures:
          0: {name: comment.line.number-sign.saga}
        patterns:
          - include: "#markdown-inline"

    repository:
      markdown-inline:
        patterns:
          - include: text.html.markdown#inline
      nested-block:
        begin: (#\[)\s*
        end: \s*(\]#)
        captures:
          1: {name: punctuation.definition.comment.saga}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
          - include: "#nested-block"
      nested-document-block:
        begin: (#{)\s*
        end: \s*(}#)
        captures:
          1: {name: punctuation.definition.comment.saga}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
          - include: "#nested-document-block"
      nested-inline:
        begin: (\()\s*
        end: \s*(\))
        name: comment.block.inline.saga
        captures:
          1: {name: punctuation.definition.comment.saga}
        patterns:
          - include: "#markdown-inline"
          - include: "#nested-inline"
      nested-special:
        begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.comment.saga}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
          - include: "#nested-special"

  regexps:
    begin: (\p{alnum}*)(\`)\s*
    end: \s*(?!\\)(\`(?!\`))(\p{alnum}*)
    contentName: string.pattern.regexp.saga
    beginCaptures:
      1: {name: keyword.modifier.saga}
      2: {name: punctuation.section.regexp.begin.saga}
    endCaptures:
      1: {name: punctuation.section.regexp.end.saga}
      2: {name: keyword.other.flag.saga}
    patterns:
      - include: "#comments"
      - include: "#regexp-patterns"
      - begin: (\`)(\`)\s*\n?
        end: \s*(?=(?!\\)\`)
        contentName: string.replace.regexp.saga
        beginCaptures:
          1: {name: punctuation.section.regexp.end.saga}
          2: {name: punctuation.section.regexp.begin.saga}
        patterns:
          - include: "#back-references"

  back-references:
    patterns:
      - match: \$[&+-]
        name: keyword.other.back-reference.saga
      - match: \${2}
        name: constant.character.escape.saga
      - begin: (\$<)
        end: \s*(>)
        name: keyword.other.back-reference.saga
        beginCaptures:
          1: {name: keyword.other.back-reference.saga}
        endCaptures:
          1: {name: keyword.other.back-reference.saga}
        patterns:
          - include: "#variables"
          - include: "#operators"
          - include: "#numbers"
      - include: "#string-escapes"

  regexp-patterns:
    patterns:
      - include: "#embedded"
      - include: "#comments"
      - match: \|
        name: keyword.operator.or.saga
      - match: \&
        name: keyword.operator.match.saga
      - match: \!
        name: keyword.operator.disjunction.saga
      - match: \.
        name: constant.character.all.saga
      - match: (?i)\\[by]({\p{alpha}+})?
        name: keyword.control.anchor.saga
      - match: (?i)(\^|\\<|\\a(?:{\p{alpha}+})?)|(\$|\\>|\\z(?:{\p{alpha}+})?)
        captures:
          1: {name: keyword.control.begin.saga}
          2: {name: keyword.control.end.saga}
      - match: (\\\()(?:(\?)|(\+)|(\*))
        captures:
          1: {name: constant.character.escape.other.saga}
          2: {name: keyword.operator.quantifier.lazy.saga}
          3: {name: keyword.operator.quantifier.eager.saga}
          4: {name: keyword.operator.quantifier.greedy.saga}
      - match: \\\d+
        name: keyword.other.back-reference.saga
      - match: \{(\s*\d*\s*(?:,?\s*\d*\s*)*)\}
        name: keyword.operator.quantifier.saga
      - begin: (\\Q)
        contentName: string.quoted.single.saga
        end: (\\E)
        name: string.quoted.raw.saga
        captures:
          1: {name: keyword.control.quote.saga}
        patterns:
          - include: "#string-escapes"
      - begin: (\\q)
        contentName: string.quoted.double.saga
        end: (\\e)
        name: string.quoted.saga
        captures:
          1: {name: keyword.control.quote.saga}
        patterns:
          - include: "#embedded-raw"
      - begin: (\\k<)
        end: \s*(>)
        name: keyword.other.back-reference.saga
        beginCaptures:
          1: {name: keyword.other.back-reference.saga}
        endCaptures:
          1: {name: keyword.other.back-reference.saga}
        patterns:
          - include: "#variables"
          - include: "#numbers"
      - begin: (\\g<)
        end: \s*(>)
        name: keyword.other.subroutine.saga
        beginCaptures:
          1: {name: keyword.other.subroutine.saga}
        endCaptures:
          1: {name: keyword.other.subroutine.saga}
        patterns:
          - include: "#variables"
          - include: "#numbers"
      - include: "#regexp-groups"
      - include: "#regexp-charset"
      - include: "#regexp-character-class"
      - match: (?i)(?:(\\M)|(\\K)|(\\G)|(\\X))
        captures:
          1: {name: keyword.control.anchor.saga}
          2: {name: keyword.control.keepout.saga}
          3: {name: keyword.control.search.saga}
          4: {name: constant.character.unicode.saga}
      - match: (?<=[*+?}])(?:(\?)|(\+)|(\*))
        captures:
          1: {name: keyword.operator.modifier.lazy.saga}
          2: {name: keyword.operator.modifier.eager.saga}
          3: {name: keyword.operator.modifier.greedy.saga}
      - match: (\?)|(\+)|(\*)
        captures:
          1: {name: keyword.operator.quantifier.lazy.saga}
          2: {name: keyword.operator.quantifier.eager.saga}
          3: {name: keyword.operator.quantifier.greedy.saga}
      - match: \\.
        name: constant.character.escape.other.saga

    repository:
      regexp-groups:
        patterns:
          - begin: \(([*+])
            end: \s*(\))
            name: constant.other.pcre.saga
            captures:
              0: {name: punctuation.section.expression.saga}
            patterns:
              - include: source.clojure
          - begin: (\()(\?#)
            contentName: comment.block.regexp.saga
            end: \s*(\))
            name: comment.block.regexp.saga
            captures:
              1: {name: punctuation.definition.comment.saga}
            patterns:
              - match: \\.
                name: comment.block.regexp.saga
          - begin: (\(\?=)
            end: \s*(\))
            name: meta.group.saga
            captures:
              1: {name: punctuation.definition.group.look-ahead.saga}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?<=)
            end: \s*(\))
            name: meta.group.saga
            captures:
              1: {name: punctuation.definition.group.look-behind.saga}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?!)
            end: \s*(\))
            name: meta.group.saga
            captures:
              1: {name: punctuation.definition.group.negative-look-ahead.saga}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?<!)
            end: \s*(\))
            name: meta.group.saga
            captures:
              1: {name: punctuation.definition.group.negative-look-behind.saga}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?(?:([+-]?\d+?)|(\p{upper}+(?:[+-]\p{upper}+)*)|(\p{lower}+(?:[+-]\p{lower}+)*)))\s*(:)?
            end: \s*(\))
            name: meta.group.saga
            captures:
              0: {name: punctuation.definition.group.flag.saga}
              1: {name: punctuation.definition.group.flag.saga}
              2: {name: entity.name.function.method.saga}
              3: {name: keyword.control.recursion.saga}
              4: {name: keyword.other.flag.saga}
              5: {name: punctuation.separator.key-value.saga}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?)(?={)
            end: \s*(\))
            name: meta.group.saga
            captures:
              1: {name: punctuation.definition.group.call-out.saga}
            patterns:
              - begin: (?<=\(\?)({)
                end: \s*(\})([<*>])?(?:(\[)(.*?)(\]))?
                name: punctuation.definition.group.call-out.saga
                captures:
                  1: {name: punctuation.definition.group.call-out.saga}
                  2: {name: keyword.operator.range.saga}
                  3: {name: punctuation.definition.tag.saga}
                  4: {patterns: [{include: "#function-entities"}]}
                  5: {name: punctuation.definition.tag.saga}
                patterns:
                  - include: $self
              - include: "#regexp-patterns"
          - begin: (\(\?>)
            end: \s*(\))
            name: meta.group.saga
            captures:
              1: {name: punctuation.definition.group.atomic.saga}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?:)
            end: \s*(\))
            name: meta.group.saga
            captures:
              1: {name: punctuation.definition.group.non-capturing.saga}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?)(?=[(|])
            end: \s*(\))
            name: meta.group.saga
            captures:
              1: {name: punctuation.definition.group.branch.saga}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?~)
            end: \s*(\))
            name: meta.group.saga
            captures:
              1: {name: punctuation.definition.group.absent.saga}
            patterns:
              - include: "#regexp-patterns"
          - begin: \((\?(?:&)(?:([+-]?\d+)|([_\p{L}\p{Nl}][_\\d\p{L}\p{M}\p{N}]*)|([+-]?\d*)))(:)?
            end: \s*\)
            name: meta.group.saga
            captures:
              0: {name: punctuation.definition.group.back-reference.saga}
              1: {name: punctuation.definition.group.back-reference.saga}
              2: {name: entity.name.function.method.saga}
              3: {name: variable.other.saga}
              4: {name: punctuation.separator.key-value.saga}
            patterns:
              - include: "#regexp-patterns"
          - begin: \(\?(?=<(?![!=]))
            end: \s*(\))
            name: meta.group.saga
            beginCaptures:
              0: {name: punctuation.definition.group.named.saga}
              1: {patterns: [{include: "#variables"}]}
            endCaptures:
              0: {name: punctuation.definition.group.named.saga}
            patterns:
              - begin: (?<=\(\?)(<)
                end: \s*(>)
                name: punctuation.definition.group.named.saga
                beginCaptures:
                  1: {name: punctuation.definition.group.named.saga}
                endCaptures:
                  1: {name: punctuation.definition.group.named.saga}
                patterns:
                  - include: "#variables"
                  - include: "#numbers"
              - include: "#regexp-patterns"
          - begin: \(
            end: \s*\)
            captures:
              0: {name: punctuation.definition.group.saga}
            patterns:
              - include: "#regexp-patterns"

      regexp-character-class:
        patterns:
          - match: \\(?=\s*$)
            name: constant.character.escape.newline.saga
          - begin: (?i)\\p{
            end: \s*}
            name: constant.other.character-class.unicode.saga
            patterns:
              - include: "#expression-keywords"
              - include: "#variables"
              - include: "#operators"
          - begin: \\j{
            end: \s*}
            name: constant.character.entity.named.saga
            patterns:
              - include: "#regexp-patterns"
          - match: (?i)\\b(?:[01]{1,21}|{[01\s]+?})
            name: constant.character.escape.binary.saga
          - match: (?i)\\q(?:[0-3]{1,11}|{[0-3\s]+?})
            name: constant.character.escape.quaternary.saga
          - match: (?i)\\s(?:[0-5]{1,8}|{[0-5\s]+?})
            name: constant.character.escape.senary.saga
          - match: (?i)\\o(?:[0-7]{1,7}|{[0-7\s]+?})
            name: constant.character.escape.octal.saga
          - match: (?i)\\d?\d{1,7}|\\d{[\d\s]+?}
            name: constant.character.escape.decimal.saga
          - match: (?i)\\z(?:[\dabetxz]{1,6}|{[\s\dabetxz]+?})
            name: constant.character.escape.duodecimal.saga
          - match: (?i)\\x(?:\h{1,6}|{[\h\s]+?})
            name: constant.character.escape.hexadecimal.saga
          - match: (?i)\\u(?:\h{1,6}|{[\h\s]+?})
            name: constant.character.escape.unicode.saga
          - match: (?i:\\[cm]\p{alpha})|\\R
            name: constant.character.control.saga
          - match: (?i:\\p\p{alpha}{1,2})|\\O
            name: constant.other.character-class.unicode.saga
          - match: (?i)\\[ci]
            name: constant.other.character-class.xml.saga
          - match: \.|\\[dhlns-w]
            name: constant.other.character-class.saga
          - match: \\[DHLNS-W]
            name: constant.other.character-class.negated.saga
          - match: (?i)\\n{[\w\s]+}
            name: constant.character.escape.unicode.name.saga
          - match: (?i)\\[abceflnprtvz]
            name: constant.character.escape.saga
          - match: \\[\p{s}\p{p}]
            name: constant.character.escape.symbol.saga
          - match: \\\p{z}
            name: constant.character.escape.symbol.saga
          - match: \\[\p{l}\p{n}]
            name: constant.character.escape.illegal.saga
          - include: "#embedded"

      regexp-char-ops:
        patterns:
          - match: \--
            name: keyword.operator.optional.saga
          - match: (?<!\\?[\\\[])-(?![-\[\]])
            name: keyword.operator.range.saga
          - match: \|\|
            name: keyword.operator.union.saga
          - match: \&&
            name: keyword.operator.intersection.saga
          - match: \^\^
            name: keyword.operator.only.saga
          - match: ~~
            name: keyword.operator.maybe.saga
          - match: \.
            name: constant.other.character-class.range.saga
          - match: \\.
            name: constant.character.escape.other.saga

      regexp-charset:
        patterns:
          - begin: (\[=)
            end: \s*(=\])
            name: constant.other.character-class.posix.saga
            captures:
              1: {name: punctuation.definition.character-class.posix.saga}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
          - begin: (\[\.)
            end: \s*(\.\])
            name: constant.other.character-class.posix.saga
            captures:
              1: {name: punctuation.definition.character-class.posix.saga}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
          - begin: (\[:)
            end: \s*(:\])
            name: constant.other.character-class.posix.saga
            captures:
              1: {name: punctuation.definition.character-class.posix.saga}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
          - begin: (\[\^)
            end: \s*(\])
            name: constant.other.character-class.set.saga
            captures:
              1: {name: punctuation.definition.character-class.negated.saga}
            patterns:
              - include: "#comments"
              - include: "#regexp-character-class"
              - include: "#regexp-char-ops"
              - include: "#regexp-charset"
          - begin: (\[)
            end: \s*(\])
            name: constant.other.character-class.set.saga
            captures:
              1: {name: punctuation.definition.character-class.saga}
            patterns:
              - include: "#comments"
              - include: "#regexp-character-class"
              - include: "#regexp-char-ops"
              - include: "#regexp-charset"

  calls:
    comment: |
      Function calls
      For testing only:
      for let x int|str, y int in list arr 'json' if x % 2 < 3
    match: |
      (?x)
      (?!['"\`]\s*)(?<=^\s*|[\p{ps}\p{pe}]\s*
      |[\p{s}\p{p}]\s+
      |(?:^|[\p{pe}\s])\s*(?:[!?~]?\.|[?!:]:|->)
      |\s*
      \b(?:# don't match keywords
      in|of|as|is|new|infer|unset
      |typeof|nameof|sizeof|keyof|valof
      |len|del|to|til|thru|at|by
      |and|x?or|not|para|series|spawn
      |def|func?|fn|macro|proc|sub
      |let|var|val|const|decl
      |class|given|law|enum|rel|lat
      |proj|prot|ext|impl|frag|inter|struct
      |module|nspace|object|record|label
      |raw|data|query|schema|style|trait|alias|type
      |if|else|elif|eless|unless|guard
      |for|each|while|until|repeat|do|redo
      |switch|case|fail|match|when|pass
      |try|retry|throw|raise|catch|rescue|finally
      |with|ref|defer|refer|show|hide|enter|exit
      |then|begin|end|debug|check|assert
      |break|continue|halt|skip|(?:return|give|await|yield|throw|raise)s?
      |yield\b\s*\bfrom|import|export|show|hide
      |from|where|join|equals|[io]nto|order
      |take|drop|fold|scan|select|use|using
      |fi|rof|done|esac|wend|yrt|kill|wout
      |open|close
      )\b
      \s*)

      (
      [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*# prefix
      (?!\b(?:# don't match keywords
      in|of|as|is|new|infer|unset
      |typeof|nameof|sizeof|keyof|valof
      |len|del|to|til|thru|at|by
      |and|x?or|not|para|series|spawn
      |def|func?|fn|macro|proc|sub
      |let|var|val|const|decl
      |class|given|law|enum|rel|lat
      |proj|prot|ext|impl|frag|inter|struct
      |module|nspace|object|record|label
      |raw|data|query|schema|style|trait|alias|type
      |if|else|elif|eless|unless|guard
      |for|each|while|until|repeat|do|redo
      |switch|case|fail|match|when|pass
      |try|retry|throw|raise|catch|rescue|finally
      |with|ref|defer|refer|show|hide|enter|exit
      |then|begin|end|debug|check|assert
      |break|continue|halt|skip|(?:return|give|await|yield|throw|raise)s?
      |yield\b\s*\bfrom|import|export|show|hide
      |from|where|join|equals|[io]nto|order
      |take|drop|fold|scan|select|use|using
      |fi|rof|done|esac|wend|yrt|kill|wout
      |open|close
      )\b)
      [_\p{l}\p{m}\p{n}]+
      (?:[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*# adfix
      [_\p{l}\p{m}\p{n}]+)*
      [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*# suffix
      )

      (?=\s+
      (?:
      (?!:)
      [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*# prefix
      (?!\b(?:# don't match keywords
      in|of|as|is|new|infer|unset
      |typeof|nameof|sizeof|keyof|valof
      |len|del|to|til|thru|at|by
      |and|x?or|not|para|series|spawn
      |def|func?|fn|macro|proc|sub
      |let|var|val|const|decl
      |class|given|law|enum|rel|lat
      |proj|prot|ext|impl|frag|inter|struct
      |module|nspace|object|record|label
      |raw|data|query|schema|style|trait|alias|type
      |if|else|elif|eless|unless|guard
      |for|each|while|until|repeat|do|redo
      |switch|case|fail|match|when|pass
      |try|retry|throw|raise|catch|rescue|finally
      |with|ref|defer|refer|show|hide|enter|exit
      |then|begin|end|debug|check|assert
      |break|continue|halt|skip|(?:return|give|await|yield|throw|raise)s?
      |yield\b\s*\bfrom|import|export|show|hide
      |from|where|join|equals|[io]nto|order
      |take|drop|fold|scan|select|use|using
      |fi|rof|done|esac|wend|yrt|kill|wout
      |open|close
      )\b)
      [_\p{l}\p{m}\p{n}]+
      (?:[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*# adfix
      [_\p{l}\p{m}\p{n}]+)*
      [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*# suffix
      |(?:[~!?]\.?)?[\p{ps}&&[^\[{]]|<[|+]\s+)+
      |(?:[~!?]\.?)?\s*(?:\[<|['"\`\\\p{ps}&&[^\[{]])
      |(?:[~!?]\.?)?!\.?
      )\b
    captures:
      1: {patterns: [{include: "#function-entities"}]}

  function-entities:
    patterns:
      - match: |
          (?x)\b(?:
          (?:# Objects and maps
          (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
          ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
          ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
          ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
          )
          (?=(?:[?!~]?\.?=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)

          |
          (?<!\.\.+)(?<=[!?~]?\.|[?!:]:|->)
          (?:# Properties (note all properties are by default, symbols)
          (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
          ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
          ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
          ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
          )

          |
          (?:# Regular variables
          (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
          ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
          ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
          ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
          )
          )\b
        captures:
          1: {name: entity.name.module.saga}
          2: {name: entity.name.tag.saga}
          3: {name: entity.name.namespace.saga}
          4: {name: entity.name.interface.saga}
          5: {name: entity.name.tag.saga}
          6: {name: entity.name.tag.saga support.class.component.saga}
          7: {name: entity.name.class.builtin.saga}
          8: {name: entity.name.function.method.saga}
          9: {name: entity.name.function.tagged-template.saga}
          10: {name: entity.name.type.saga}
          11: {name: entity.name.class.saga}
          12: {name: entity.name.function.saga}
      - include: $self

  variables:
    comment: |
      For testing only
      _int int_ _int._int INT INT.INT Int Int.Int int int.int

      Four types of variables:
      - underscore variables (either surrounded by _ on one end or both)
      - constant variables: in SHOUT_SNAKE_CASE
      - class variables: in PascalCase
      - regular variables: in camelCase
    match: |
      (?x)\b(?:
      (?:# Objects and maps
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )
      (?=(?:[?!~]?\.?=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)

      |
      (?<!\.\.+)(?<=[!?~]?\.|[?!:]:|->)
      (?:# Properties (note all properties are by default, symbols)
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )

      |
      (?:# Regular variables
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )
      )\b
    captures:
      1: {name: variable.other.global.saga}
      2: {name: variable.other.constant.object.saga}
      3: {name: variable.other.conditional.saga}
      4: {name: variable.other.object.saga}
      5: {name: variable.other.index.saga}
      6: {name: variable.other.constant.property.saga}
      7: {name: variable.other.property.static.saga}
      8: {name: variable.other.property.saga}
      9: {name: variable.other.dollar.saga}
      10: {name: variable.other.constant.saga}
      11: {name: variable.other.class.saga}
      12: {name: variable.other.readwrite.saga}

  operators:
    patterns:
      - include: "#special-operators"
      - include: "#unary-ops"
      - include: "#binary-ops"

    repository:
      binary-ops-builtin:
        patterns:
          - comment: augmented assignment += -= *= /= etc
            match: (?<=^|['"\`\\\p{ps}\s])([\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+(?<![!:~.<=>])=)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.assignment.augmented.saga
          - comment: "assignment : :="
            match: (?<=^|['"\`\\\p{ps}\s])(:?=)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.assignment.saga
          - comment: arithmetic + - * ** *** / // /// % %% *> <*
            match: (?<=^|['"\`\\\p{ps}\s])((?<!<)\+(?!>|\++)|(?<!<)-(?!>|-+)|\*{1,3}|/{1,3}(?!\\)|%%?|\*+>|<\*+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.arithmetic.saga
          - comment: increment/decrement ++ --
            match: (?<=^|['"\`\\\p{ps}\s])((?:[+-])+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.successor.saga
          - comment: logical && || ^^ /\ / \ \\ etc.
            match: (?<=^|['"\`\\\p{ps}\s])((?:[&^]){2,}|\|\|+(?!>)|/\\|\\/|\\+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.logical.saga
          - comment: bitwise & | ^ ~
            match: (?<=^|['"\`\\\p{ps}\s])([&^]|\|(?!>)|~(?![!=<>]))(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.bitwise.saga
          - comment: shift << >> <<< >>>>
            match: (?<=^|['"\`\\\p{ps}\s])(<{2,}(?![!:=+|*])|(?<![!:=+|*])>{2,})(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.bitwise.shift.saga
          - comment: function composition +> <+
            match: (?<=^|['"\`\\\p{ps}\s])(<\++|\++>)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.compose.saga
          - comment: pipeline |> <|
            match: (?<=^|['"\`\\\p{ps}\s])(<\|+|\|+>)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.pipeline.saga
          - comment: "class <: :> :< >: <:< >:> <:> >:< <! !> !< >! <!< >!> <!> >!<"
            match: (?<=^|['"\`\\\p{ps}\s])([<>][!:][<>]?|[!:][<>])(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.class.saga
          - comment: relational < > <= >=
            match: (?<=^|['"\`\\\p{ps}\s])([<>]=?)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.relational.saga
          - comment: regex =< <> </ /> <$ $> <$> <+> <*> </> <$> $
            match: (?<=^|['"\`\\\p{ps}\s])(<>|=<|<(?:[/*+$])+>?|(?:[/*+$])+>)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.regexp.saga
          - comment: equality == != === !==
            match: (?<=^|['"\`\\\p{ps}\s])([!=]=+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.comparison.saga
          - comment: similarity operators
            match: (?<=^|['"\`\\\p{ps}\s])([!=~]+~|~[!=~]+|[<~>]+~[<~>]*|~[<~>]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.similarity.saga
          - comment: fat arrow-like => ==> <==
            match: (?<=^|['"\`\\\p{Ps}\s])([=>]+|[<=]+|[=>]+[<=]+)(?=$|['"\`\\\s\p{Pe}])
            name: keyword.operator.arrow.fat.saga
          - comment: skinny arrow-like -> <- --> <--
            match: (?<=^|['"\`\\\p{Ps}\s])([->]+|[<-]+|[->]+[<-]+)(?=$|['"\`\\\s\p{Pe}])
            name: keyword.operator.arrow.skinny.saga
          - comment: wavy arrow-like ~> <~ ~~> <~~
            match: (?<=^|['"\`\\\p{Ps}\s])([~>]+|[<~]+|[~>]+[<~]+)(?=$|['"\`\\\s\p{Pe}])
            name: keyword.operator.arrow.wavy.saga
          - comment: null-coalescing ??
            match: (?<=^|['"\`\\\p{ps}\s])(\?{2,})(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.null-coalescing.saga
          - comment: non-null coalescing !!
            match: (?<=^|['"\`\\\p{ps}\s])(!{2,})(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.coalescing.saga
          - comment: "false coalescing ?:"
            match: (?<=^|['"\`\\\p{ps}\s])(\?+:+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.conditional.saga
          - comment: "true coalescing !:"
            match: (?<=^|['"\`\\\p{ps}\s])(!+:+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.ternary.saga
          - comment: "infix function $:"
            match: (?<=^|['"\`\\\p{ps}\s])(\$+:+|\${2,})(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.macro.dollar.saga
          - comment: custom bitwise (leading &|^ ~)
            match: (?<=^|['"\`\\\p{ps}\s])([&|^~][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.bitwise.saga
          - comment: custom arithmetic (leading + - * / %)
            match: (?<=^|['"\`\\\p{ps}\s])([+\-*/%][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.arithmetic.saga
          - comment: "custom accessor (leading : .)"
            match: (?<=^|['"\`\\\p{ps}\s])([:.][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.prototype.saga
          - comment: custom equality (leading = !)
            match: (?<=^|['"\`\\\p{ps}\s])([!=][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.comparison.saga
          - comment: custom comparison (leading < >)
            match: (?<=^|['"\`\\\p{ps}\s])([<>][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.relational.saga
          - comment: custom optional (leading ?)
            match: (?<=^|['"\`\\\p{ps}\s])(\?[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.private.saga
          - comment: custom mathematical (leading Unicode category Sm)
            match: (?<=^|['"\`\\\p{ps}\s])([\p{sm}&&[\x{80}-\x{10ffff}]][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.math.saga
          - comment: custom currency-based (leading Unicode category Sc)
            match: (?<=^|['"\`\\\p{ps}\s])([\p{sc}&&[^$]][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.currency.saga
          - comment: custom ASCII (leading Unicode 0x80 to 0xFF)
            match: (?<=^|['"\`\\\p{ps}\s])([\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[\x{80}-\x{ff}]][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.ascii.saga
          - comment: other custom (leading anything not covered above)
            match: (?<=^|['"\`\\\p{ps}\s])([\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+)(?=$|['"\`\\\s\p{pe}])
            name: keyword.operator.infix.saga

      binary-ops:
        match: (?<=^|['"\`\\\s\p{ps}])([\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]+)(?=$|['"\`\\\s\p{pe}])
        captures:
          0: {patterns: [{include: "#binary-ops-builtin"}]}

      unary-ops:
        patterns:
          - &adfix-operators
            comment: non-spaced-out binary operators
            match: |
              (?x)(?<=\b|^|[\p{pe}'"\`\\\s])
              (?:([>.]\.[.<])|(\?\.[=!]?)|(~\.[=!]?)|(!\.[=!]?)|(\.[=!]?|::=?)|(->))
              (?=\b|$|[\p{ps}'"\`\\\s])
            captures:
              1: {name: keyword.operator.range.saga}
              2: {name: punctuation.accessor.optional.saga}
              3: {name: punctuation.accessor.cascade.saga}
              4: {name: punctuation.accessor.call.saga}
              5: {name: punctuation.accessor.saga}
              6: {name: punctuation.accessor.module.saga}

          - &prefix-operators
            comment: prefix operators
            match: |
              (?x)
              (?:(\*)#1
              |(\+)#2
              |(\-)#3
              |(\&)#4
              |(\|)#5
              |(\^)#6
              |(\!)#7
              |(\$)#8
              |(\@)#9
              |(\~)#10
              |(\?)#11
              |(\=)#12
              |(\$)#13
              |[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])#14
              (?=[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*
              [\p{l}\p{m}\p{n}\p{ps}_,;'"\`])
            name: keyword.operator.prefix.saga
            captures:
              1: {name: keyword.operator.module.all.saga}
              2: {name: keyword.operator.increment.saga}
              3: {name: keyword.operator.decrement.saga}
              4: {name: keyword.operator.intersection.saga}
              5: {name: keyword.operator.union.saga}
              6: {name: keyword.operator.sym-diff.saga}
              7: {name: keyword.operator.logical.saga}
              8: {name: keyword.operator.private.saga}
              9: {name: keyword.operator.decorator.saga}
              10: {name: keyword.operator.bitwise.not.saga}
              11: {name: keyword.operator.existential.saga}
              12: {name: keyword.operator.assignment.saga}
              13: {name: keyword.operator.pipeline.saga}
              14: {name: keyword.operator.prefix.saga}

          - &suffix-operators
            comment: suffix operators
            match: |
              (?x)
              (?<=[\p{l}\p{m}\p{n}\p{pe}_,;'"\`]
              [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*)
              (?:(\*)#1
              |(\+)#2
              |(\-)#3
              |(\&)#4
              |(\|)#5
              |(\^)#6
              |(\!)#7
              |(\$)#8
              |(\@)#9
              |(\~)#10
              |(\?)#11
              |(\=)#12
              |(\$)#13
              |[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])#14
            name: keyword.operator.suffix.saga
            captures:
              1: {name: keyword.operator.module.all.saga}
              2: {name: keyword.operator.increment.saga}
              3: {name: keyword.operator.decrement.saga}
              4: {name: keyword.operator.intersection.saga}
              5: {name: keyword.operator.union.saga}
              6: {name: keyword.operator.sym-diff.saga}
              7: {name: punctuation.accessor.call.saga}
              8: {name: keyword.operator.private.saga}
              9: {name: keyword.operator.decorator.saga}
              10: {name: keyword.operator.bitwise.saga}
              11: {name: punctuation.accessor.optional.saga}
              12: {name: keyword.operator.assignment.saga}
              13: {name: keyword.operator.pipeline.saga}
              14: {name: keyword.operator.suffix.saga}

      pipeline-operator:
        patterns:
          - applyEndPatternLast: 1
            begin: |
              (?x)\s*(?:(\++>)|(\|+>))(?=\s*(
              [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*# prefix

              (?!
              \b(?:# don't match keywords
              in|of|as|is|new|infer|unset
              |typeof|nameof|sizeof|keyof|valof
              |len|del|to|til|thru|at|by
              |and|x?or|not|para|series|spawn
              |def|func?|fn|macro|proc|sub
              |let|var|val|const|decl
              |class|given|law|enum|rel|lat
              |proj|prot|ext|impl|frag|inter|struct
              |module|nspace|object|record|label
              |raw|data|query|schema|style|trait|alias|type
              |if|else|elif|eless|unless|guard
              |for|each|while|until|repeat|do|redo
              |switch|case|fail|match|when|pass
              |try|retry|throw|raise|catch|rescue|finally
              |with|ref|defer|refer|show|hide|enter|exit
              |then|begin|end|debug|check|assert
              |break|continue|halt|skip|(?:return|give|await|yield|throw|raise)s?
              |yield\b\s*\bfrom|import|export|show|hide
              |from|where|join|equals|[io]nto|order
              |take|drop|fold|scan|select|use|using
              |fi|rof|done|esac|wend|yrt|kill|wout
              |open|close
              )\b
              )

              [_\p{l}\p{m}\p{n}]+
              (?:[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*# adfix
              [_\p{l}\p{m}\p{n}]+)*
              [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]*# suffix
              )\s*([^(]|$|;))
            end: (?=.)
            beginCaptures:
              1: {name: keyword.operator.compose.saga}
              2: {name: keyword.operator.pipeline.saga}
            patterns:
              - match: |
                  (?x)(?<=(?:\++>)|(?:\|+>))\s*
                  (?!
                  \b(?:# don't match keywords
                  in|of|as|is|new|infer|unset
                  |typeof|nameof|sizeof|keyof|valof
                  |len|del|to|til|thru|at|by
                  |and|x?or|not|para|series|spawn
                  |def|func?|fn|macro|proc|sub
                  |let|var|val|const|decl
                  |class|given|law|enum|rel|lat
                  |proj|prot|ext|impl|frag|inter|struct
                  |module|nspace|object|record|label
                  |raw|data|query|schema|style|trait|alias|type
                  |if|else|elif|eless|unless|guard
                  |for|each|while|until|repeat|do|redo
                  |switch|case|fail|match|when|pass
                  |try|retry|throw|raise|catch|rescue|finally
                  |with|ref|defer|refer|show|hide|enter|exit
                  |then|begin|end|debug|check|assert
                  |break|continue|halt|skip|(?:return|give|await|yield|throw|raise)s?
                  |yield\b\s*\bfrom|import|export|show|hide
                  |from|where|join|equals|[io]nto|order
                  |take|drop|fold|scan|select|use|using
                  |fi|rof|done|esac|wend|yrt|kill|wout
                  |open|close
                  )\b
                  )
                  ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
                  (?!(?:[?!~]?\.=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)
                captures:
                  1: {name: entity.name.function.saga}
              - match: |
                  (?x)\s*
                  (?!
                  \b(?:# don't match keywords
                  in|of|as|is|new|infer|unset
                  |typeof|nameof|sizeof|keyof|valof
                  |len|del|to|til|thru|at|by
                  |and|x?or|not|para|series|spawn
                  |def|func?|fn|macro|proc|sub
                  |let|var|val|const|decl
                  |class|given|law|enum|rel|lat
                  |proj|prot|ext|impl|frag|inter|struct
                  |module|nspace|object|record|label
                  |raw|data|query|schema|style|trait|alias|type
                  |if|else|elif|eless|unless|guard
                  |for|each|while|until|repeat|do|redo
                  |switch|case|fail|match|when|pass
                  |try|retry|throw|raise|catch|rescue|finally
                  |with|ref|defer|refer|show|hide|enter|exit
                  |then|begin|end|debug|check|assert
                  |break|continue|halt|skip|(?:return|give|await|yield|throw|raise)s?
                  |yield\b\s*\bfrom|import|export|show|hide
                  |from|where|join|equals|[io]nto|order
                  |take|drop|fold|scan|select|use|using
                  |fi|rof|done|esac|wend|yrt|kill|wout
                  |open|close
                  )\b
                  )
                  ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
                  (?!(?:[?!~]?\.=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)
                captures:
                  1: {name: entity.name.function.method.saga}
              - match: |
                  (?x)\s*
                  (?!
                  \b(?:# don't match keywords
                  in|of|as|is|new|infer|unset
                  |typeof|nameof|sizeof|keyof|valof
                  |len|del|to|til|thru|at|by
                  |and|x?or|not|para|series|spawn
                  |def|func?|fn|macro|proc|sub
                  |let|var|val|const|decl
                  |class|given|law|enum|rel|lat
                  |proj|prot|ext|impl|frag|inter|struct
                  |module|nspace|object|record|label
                  |raw|data|query|schema|style|trait|alias|type
                  |if|else|elif|eless|unless|guard
                  |for|each|while|until|repeat|do|redo
                  |switch|case|fail|match|when|pass
                  |try|retry|throw|raise|catch|rescue|finally
                  |with|ref|defer|refer|show|hide|enter|exit
                  |then|begin|end|debug|check|assert
                  |break|continue|halt|skip|(?:return|give|await|yield|throw|raise)s?
                  |yield\b\s*\bfrom|import|export|show|hide
                  |from|where|join|equals|[io]nto|order
                  |take|drop|fold|scan|select|use|using
                  |fi|rof|done|esac|wend|yrt|kill|wout
                  |open|close
                  )\b
                  )
                  ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
                  ((?:[?!~]?\.=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)
                captures:
                  1: {name: variable.other.object.saga}
                  2: {patterns: [{include: "#unary-ops"}]}
              - include: "#comments"

      special-operators:
        patterns:
          - include: "#pipeline-operator"
          - begin: (?<=\s)(\?)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.conditional.saga}
            patterns:
              - begin: \s*(?=([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s*:)
                end: \s*(?=:\s|$)
                patterns:
                  - include: "#constants"
                  - include: "#variables"
              - include: $self
          - begin: (?<=\s)(\!)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.ternary.saga}
            patterns:
              - begin: \s*(?=([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s*:)
                end: \s*(?=:\s|$)
                patterns:
                  - include: "#constants"
                  - include: "#variables"
              - include: $self
          - begin: (?<=\s)(\$)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.macro.dollar.saga}
            patterns:
              - begin: \s*(?=([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s*:)
                end: \s*(?=:\s|$)
                name: entity.name.function.saga
              - include: $self

  constant-types:
    - include: "#numbers"
    - include: "#strings"
    - include: "#regexps"

  custom-types:
    comment: |
      For testing only
      _int int_ _int._int INT INT.INT Int Int.Int int int.int

      Four types of variables:
      - underscore variables (either surrounded by _ on one end or both)
      - constant variables: in SHOUT_SNAKE_CASE
      - class variables: in PascalCase
      - regular variables: in camelCase
    match: |
      (?x)\s*\b

      (?!
      \b(?:# don't match keywords
      in|of|as|is|new|unset
      |len|del|to|til|thru|at|by
      |and|x?or|not|para|series|spawn
      |def|func?|fn|macro|proc|sub
      |let|var|val|const|decl
      |class|given|law|enum|rel|lat
      |proj|prot|ext|impl|frag|inter|struct
      |module|nspace|object|record|label
      |raw|data|query|schema|style|trait|alias|type
      |if|else|elif|eless|unless|guard
      |for|each|while|until|repeat|do|redo
      |switch|case|fail|match|when|pass
      |try|retry|throw|raise|catch|rescue|finally
      |with|ref|defer|refer|show|hide|enter|exit
      |then|begin|end|debug|check|assert
      |break|continue|halt|skip|(?:return|give|await|yield|throw|raise)s?
      |yield\b\s*\bfrom|import|export|show|hide
      |from|where|join|equals|[io]nto|order
      |take|drop|fold|scan|select|use|using
      |fi|rof|done|esac|wend|yrt|kill|wout
      |open|close
      )\b
      )

      (?:
      (?:# Objects and maps
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )
      (?=(?:[?!~]?\.?=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)

      |
      (?<!\.\.+)(?<=[!?~]?\.|[?!:]:|->)
      (?:# Properties (note all properties are by default, symbols)
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )

      |
      (?:# Regular variables
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )
      )\b
    captures: &custom-types
      1: {name: entity.name.module.saga}
      2: {name: entity.name.tag.saga}
      3: {name: entity.name.namespace.saga}
      4: {name: entity.name.interface.saga}
      5: {name: entity.name.tag.block.saga}
      6: {name: entity.name.tag.script.saga}
      7: {name: entity.name.tag.style.saga}
      8: {name: entity.name.tag.inline.saga}
      9: {name: entity.name.label.saga}
      10: {name: entity.name.project.saga}
      11: {name: entity.name.class.saga}
      12: {name: entity.name.type.saga}

  type-brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"

    repository:
      curly-brackets: &type-curly-brackets
        patterns:
          - begin: \s*(\{\|)
            end: \s*(\|\})
            captures:
              1: {name: punctuation.definition.mapping.saga}
            patterns:
              - include: "#types"
              - include: $self
          - begin: \s*(\{)
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.dictionary.saga}
            patterns:
              - include: "#types"
              - include: $self

      round-brackets: &type-round-brackets
        patterns:
          - begin: \s*(\(\|)
            end: \s*(\|\))
            captures:
              1: {name: punctuation.definition.parameters.saga}
            patterns:
              - include: "#types"
              - include: $self
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.saga}
            patterns:
              - include: "#types"
              - include: $self

      square-brackets: &type-square-brackets
        patterns:
          - begin: \s*(\[<)
            end: \s*(>\])
            captures:
              1: {name: punctuation.definition.typeparameters.saga}
            patterns:
              - include: "#types"
              - include: $self
          - begin: \s*(\[\|)
            end: \s*(\|\])
            captures:
              1: {name: punctuation.definition.sequence.saga}
            patterns:
              - include: "#types"
              - include: $self
          - begin: \s*(\[)
            end: \s*(\])
            captures:
              1: {name: punctuation.definition.array.saga}
            patterns:
              - include: "#types"
              - include: $self

  type-keywords:
    patterns:
      - match: |
          (?x)\s*(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
          (ext)\b\s*
        name: storage.type.extends.saga
      - match: |
          (?x)\s*(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
          (impl)\b\s*
        name: storage.type.implements.saga
      - match: |
          (?x)\s*(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
          ((?:type|name|size|key)of|only|infer)\b\s*
        name: keyword.operator.expression.$1.saga
      - match: |
          (?x)\s*(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
          (valof)\b\s*
        name: keyword.operator.expression.valueof.saga

  type-operators:
    patterns:
      - comment: non-spaced-out binary operators
        match: |
          (?x)(?<=^|[\p{pe}_\p{l}\p{m}\p{n}'"\`])
          (?:(\?[:.])|(~[:.])|(![:.])|(::|\.)|(->))
          (?=$|[\p{ps}_\p{l}\p{m}\p{n}'"\`])
        captures:
          1: {name: punctuation.accessor.optional.saga}
          2: {name: punctuation.accessor.cascade.saga}
          3: {name: punctuation.accessor.call.saga}
          4: {name: punctuation.accessor.saga}
          5: {name: punctuation.accessor.module.saga}

      - comment: sum type +
        match: \s*(\+)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.sum.saga
      - comment: difference type -
        match: \s*(\-)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.difference.saga
      - comment: product type *
        match: \s*(\*)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.product.saga
      - comment: quotient type /
        match: \s*(\/)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.quotient.saga
      - comment: remainder type %
        match: \s*(\/)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.remainder.saga
      - comment: result/return type !
        match: \s*(\!)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.only.saga
      - comment: some or maybe type ?
        match: \s*(\?)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.maybe.saga
      - comment: intersection type &
        match: \s*(\&)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.intersection.saga
      - comment: union type |
        match: \s*(\|)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.union.saga
      - comment: symmetric difference type ^
        match: \s*(\^)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.sym-diff.saga
      - comment: complement type ~
        match: \s*(\~)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.negation.saga
      - comment: class type < >
        match: \s*([<>])(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: keyword.operator.class.saga
      - comment: "type operator :"
        match: \s*(:)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]])
        name: punctuation.definition.annotation.saga

  type-annotation:
    applyEndPatternLast: 1
    begin: (:)(?=\s|$)
    end: (?=\O)|$
    beginCaptures:
      1: {name: punctuation.definition.annotation.saga}
    patterns:
      - include: "#types"

  types:
    patterns:
      - include: "#type-keywords"
      - include: "#modifier-keywords"
      - include: "#constant-types"
      - include: "#support-types"
      - include: "#custom-types"
      - include: "#type-operators"
      - include: "#type-brackets"

      - match: (?<=\))\s*(=>)\s*
        name: storage.type.function.arrow.saga

      - match: (?!^)\s*\b((?>WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|strings|SIMD.Uint8x16|SIMD.Uint32x4|SIMD.Uint16x8|SIMD.Int8x16|SIMD.Int32x4|SIMD.Int16x8|SIMD.Float64x2|SIMD.Float32x4|SIMD.Bool8x16|SIMD.Bool64x2|SIMD.Bool32x4|SIMD.Bool16x8|SIMD|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|numbers|NaN|Math|Map|JSON|Intl.NumberFormat|Intl.DateTimeFormat|Intl.Collator|Intl|InternalError|Int8Array|Int32Array|Int16Array|Infinity|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array))\b
        captures:
          1: {name: support.type.builtin.class.saga}
      - match: \s*\b((SIMD)((\.)(Uint8x16|Uint32x4|Uint16x8|Int8x16|Int32x4|Int16x8|Float64x2|Float32x4|Bool8x16|Bool64x2|Bool32x4|Bool16x8))?)\b
        captures:
          2: {name: support.type.builtin.class.saga}
          4: {name: keyword.operator.accessor.saga}
          5: {name: support.type.builtin.class.saga}
      - match: \s*\b((Intl)((\.)(NumberFormat|DateTimeFormat|Collator))?)\b
        captures:
          2: {name: support.type.builtin.class.saga}
          4: {name: keyword.operator.accessor.saga}
          5: {name: support.type.builtin.class.saga}

  modifier-keywords:
    comment: Modifier keywords only activate when they are next to a declaration.
    match: |
      (?x)
      (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
      (# Generator modifiers
      (?:return|give|await|yield|throw|raise)s|
      prev|next
      )|
      (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(?:
      (# Access modifiers
      pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager|trans|part
      |lawful|rogue|early|late|unique|handle|over|abs|vol|stat|dyn|final
      )|
      (# Function or method modifiers
      [gs]et|[dr]ef|rec|gen|(?:im)?pure|local|global|native
      |(?:un)?(?:sign|safe|check|lock|fixed|size)
      )|
      (# Property modifiers
      (?:pre|in|post|suf|a[df])fix|
      (?:u|bi|ter|)nary
      )
      )\b(?=\b
      (?:\s*\b
      (?:# Access modifiers
      pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager
      |lawful|rogue|early|late|unique|handle|over|abs|vol|stat|dyn|final
      |[gs]et|[dr]ef|trans|part|rec|gen|(?:im)?pure|local|global|native
      |(?:un)?(?:sign|safe|check|lock|fixed|size)
      |# Function or method modifiers
      (?:pre|in|post|suf|a[df])fix|
      (?:u|bi|ter|)nary
      )
      \b\s*)*
      \s*\b
      (?:
      def|func?|fn|macro|proc|sub
      |let|var|val|const|decl
      |class|given|law|enum|rel|lat
      |proj|prot|ext|impl|frag|inter|struct
      |module|nspace|object|record|label
      |raw|data|query|schema|style|trait|alias|type
      |do|redo
      )\b
      )
    captures:
      1: {name: keyword.modifier.saga}
      2: {name: storage.modifier.saga}
      3: {name: storage.type.accessor.saga}
      4: {name: storage.type.property.saga}

  support:
    patterns:
      - include: "#support-constants"
      - include: "#support-types"
      - include: "#support-functions"

  clause-keywords:
    comment: clause keywords
    match: |
      (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(?:
      (def|func?|fn|macro|proc|sub)# function
      |(let|va[rl]|const)# variable
      |(class|ext)# class
      |(given|law)# constraint
      |(enum|rel|lat)# enumeration
      |(proj)# project
      |(frag|struct)# fragment
      |(inter|schema)# interface
      |(module|lat)# module
      |(nspace)# function
      |(object|record)# object
      |(raw)# markup
      |(data|query)# indented GraphQL
      |(style)# inline CSS
      |(trait|impl)# trait
      |(type|alias)# type alias
      |(decl)# declaration
      )\b
    captures:
      1: {name: storage.type.function.saga}
      2: {name: storage.type.saga}
      3: {name: storage.type.class.saga}
      4: {name: storage.type.constraint.saga}
      5: {name: storage.type.enum.saga}
      6: {name: storage.type.project.saga}
      7: {name: storage.type.fragment.saga}
      8: {name: storage.type.interface.saga}
      9: {name: storage.type.module.saga}
      10: {name: storage.type.namespace.saga}
      11: {name: storage.type.object.saga}
      12: {name: storage.type.raw.saga}
      13: {name: storage.type.schema.saga}
      14: {name: storage.type.style.saga}
      15: {name: storage.type.trait.saga}
      16: {name: keyword.other.typedef.saga}
      17: {name: keyword.other.declare.saga}

  general-keywords:
    comment: general keywords
    match: |
      (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(?:
      (if|else|elif|eless|unless|guard|fi)#1
      |(for|each|while|until|repeat|rof)#2
      |(switch|case|fail|esac)#3
      |(match|when|pass|wend)#4
      |(try|retry|throw|raise|catch|rescue|finally|yrt)#5
      |(with|wout)#6
      |(ref|[dr]efer|show|hide|enter|exit)#7
      |(then)#8
      |(debug|check|assert)#9
      |(break|continue|halt|skip|return|give|label|await|yield|throw|raise|yield\b\s+\bfrom)# 10
      |((?:im|ex)port|show|hide)# 11
      |(para|series|spawn|kill)#12
      |(do|redo|done)#13
      |(begin|end)#14
      )\b
    captures:
      1: {name: keyword.control.conditional.saga}
      2: {name: keyword.control.loop.saga}
      3: {name: keyword.control.switch.saga}
      4: {name: keyword.control.match.saga}
      5: {name: keyword.control.error.saga}
      6: {name: keyword.control.with.saga}
      7: {name: keyword.control.saga}
      8: {name: keyword.control.then.saga}
      9: {name: keyword.other.$10.saga}
      10: {name: keyword.control.flow.saga}
      11: {name: keyword.control.module.saga}
      12: {name: keyword.control.parallel.saga}
      13: {name: keyword.control.do.saga}
      14: {name: keyword.control.$14.saga}

  expression-keywords:
    comment: expression keywords
    match: |
      (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(?:
      (in)|(of)|(as)|(is)|(new)|(infer)
      |(typeof|nameof|sizeof|keyof)
      |(valof)|(len)|(del)|(to|til|thru|at|by)|(unset)
      |(and|x?or|not)
      )\b
    captures:
      1: {name: keyword.operator.expression.in.saga}
      2: {name: keyword.operator.expression.of.saga}
      3: {name: keyword.operator.expression.as.saga}
      4: {name: keyword.operator.expression.is.saga}
      5: {name: keyword.operator.expression.new.saga}
      6: {name: keyword.operator.expression.infer.saga}
      7: {name: keyword.operator.expression.$7.saga}
      8: {name: keyword.operator.expression.valueof.saga}
      9: {name: keyword.operator.expression.length.saga}
      10: {name: keyword.operator.expression.delete.saga}
      11: {name: keyword.operator.expression.range.saga}
      12: {name: keyword.operator.expression.void.saga}
      13: {name: keyword.operator.expression.logical.saga}

  keywords:
    patterns:
      - include: "#query-expression"
      - include: "#module-expression"
      - include: "#control-expression"
      - include: "#modifier-keywords"
      - include: "#clause-keywords"
      - include: "#expression-keywords"
      - include: "#general-keywords"

    repository:
      custom-types:
        match: |
          (?x)\s*\b

          (?:
          (?:# Objects and maps
          (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
          ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
          ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
          ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
          )
          (?=(?:[?!~]?\.?=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)

          |
          (?<!\.\.+)(?<=[!?~]?\.|[?!:]:|->)
          (?:# Properties (note all properties are by default, symbols)
          (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
          ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
          ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
          ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
          )

          |
          (?:# Regular variables
          (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
          ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
          ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
          ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
          )
          )\b
        captures: *custom-types

      control-expression:
        applyEndPatternLast: 1
        begin: (?<!\.|::)\s*\b(halt|skip|break|continue|goto|label)\b
        end: (?=\O)|$
        beginCaptures:
          1: {name: keyword.control.flow.saga}
        patterns:
          - match: \s*([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s*
            captures:
              1: {name: constant.other.label.saga}

      module-expression:
        applyEndPatternLast: 1
        begin: |
          (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
          (import|export|open|close|use|using)\b\s*
        end: (?=\O)|$
        beginCaptures:
          1: {name: keyword.control.module.saga}
        patterns:
          - include: "#modifier-keywords"
          - include: "#type-keywords"
          - match: |
              (?x)\s*(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (from|to|as|all|any|show|hide|to|and|x?or|not)\b\s*
            name: keyword.control.module.saga
          - match: \s*\*
            name: keyword.operator.module.all.saga
          - include: "#module-string"
          - include: "#support-types"
          - include: "#custom-types"
          - include: "#types"
          - include: "#operators"
          - include: "#punctuation"
        repository:
          module-string:
            patterns:
              - comment: single quoted raw string
                begin: \s*('{3,})
                contentName: string.quoted.template.saga
                end: \s*((\1)(?!\1))
                captures:
                  1: {name: punctuation.definition.string.saga}
                patterns:
                  - include: "#embedded-raw"
              - comment: simple single quoted raw string
                begin: \s*(')
                contentName: string.quoted.template.saga
                end: \s*((\1)(?!\1))
                captures:
                  1: {name: punctuation.definition.string.saga}
                patterns:
                  - match: "''"
                    name: constant.character.escape.saga
                  - include: "#embedded-raw"
              - comment: double quoted standard string
                begin: \s*("{3,}|")
                contentName: string.quoted.module.saga
                end: \s*((\1)(?!\1))
                captures:
                  1: {name: punctuation.definition.string.saga}
                patterns:
                  - include: "#string-escapes"

      query-expression:
        patterns:
          - begin: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (from)\b\s*
            end: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (in|of)\b\s*
            captures:
              1: {name: keyword.query.saga}
            patterns:
              - include: $self
          - match: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              ((\b(fold|scan)\b)\s*(\b(left|right)\b)?\s*(\b(by|while|until|with)\b)?)\b\s*
            name: keyword.query.saga
          - begin: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (group)\b\s*
            end: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (by)\b\s*
            captures:
              1: {name: keyword.query.saga}
            patterns:
              - include: $self
          - begin: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (join)\b\s*
            end: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (in|of)\b\s*
            captures:
              1: {name: keyword.query.saga}
            patterns:
              - include: $self
          - match: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (equals?|[io]nto)\b\s*
            name: keyword.query.saga
          - match: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              ((\b(order)\b)\s*(\b((a|de)sc)\b)?\s*(\b(by)\b)?)\b\s*
            name: keyword.query.saga
          - match: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (select)\b\s*
            name: keyword.query.saga
          - match: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              ((\b(take|drop)\b)\s*(\b(left|right|init|head|tail|last)\b)?\s*(\b(by|while|until|with)\b)?)\b\s*
            name: keyword.query.saga
          - match: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (where)\b\s*
            name: keyword.query.saga

  parameter-brackets:
    begin: \s*(\()
    end: \s*(\))
    captures:
      1: {name: punctuation.definition.parameters.saga}
    patterns: &function-params
      - include: "#clauses"
      - include: "#keywords"
      - match: (?i)[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
        name: variable.parameter.saga
      - match: (?i)\?[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*\b
        name: variable.parameter.optional.saga
      - match: (?i)\*[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*\b
        name: variable.parameter.spread.saga
      - match: (?i)\&[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*\b
        name: variable.parameter.name.saga
      - match: (?i)\%[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*\b
        name: variable.parameter.reference.saga
      - match: (?i)\$[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*\b
        name: variable.parameter.other.saga
      - include: "$self"

  block-entities:
    repository:
      type-square-brackets: *type-square-brackets
      type-round-brackets: *type-round-brackets
      type-curly-brackets: *type-curly-brackets

    patterns:
      - include: "#type-keywords"
      - include: "#type-square-brackets"
      - include: "#parameter-brackets"
      - include: "#round-brackets"
      - include: "#curly-brackets"
      - include: "#type-annotation"
      - include: "#type-operators"
      - *adfix-operators
      - applyEndPatternLast: 1
        begin: \s*(:)(?:(?=::)|(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\\\#]]))
        end: (?=\O)|$
        beginCaptures:
          1: {name: punctuation.definition.annotation.saga}
        patterns:
          - include: "#types"

  definitions:
    patterns:
      - include: "#function"
      - include: "#raw"
      - include: "#schema"
      - include: "#style"
      - include: "#class"
      - include: "#enum"
      - include: "#interface"
      - include: "#trait"
      - include: "#fragment"
      - include: "#module"
      - include: "#namespace"
      - include: "#object"
      - include: "#constraint"
      - include: "#project"

    repository:
      class:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(class|ext)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.class.saga}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.class.saga}
          - include: "#block-entities"
      constraint:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(given|law)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.constraint.saga}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.constraint.saga}
          - include: "#block-entities"
      enum:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(enum|rel)\s+
        end: $|(?=.)
        name: meta.enum.declaration.saga
        beginCaptures:
          1: {name: storage.type.enum.saga}
          2: {name: entity.name.enum.saga}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.enum.saga}
          - include: "#block-entities"
      project:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(proj)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.project.saga}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.project.saga}
          - include: "#block-entities"
      fragment:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(frag|struct)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.fragment.saga}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.fragment.saga}
          - include: "#block-entities"
      function:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(def|func?|fn|macro|proc|sub)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.function.saga}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.function.saga}
          - include: "#block-entities"
      interface:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(inter|schema)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.interface.saga}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.interface.saga}
          - include: "#block-entities"
      module:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(module|lat)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.module.saga}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.module.saga}
          - include: "#block-entities"
      namespace:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(nspace)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.namespace.saga}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.namespace.saga}
          - include: "#block-entities"
      object:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(object|record)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.object.saga}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.object.saga}
          - include: "#block-entities"
      raw:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(raw)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.raw.saga}
        patterns:
          - match: *entity-name
            name: entity.name.raw.saga
          - include: "#block-entities"
      schema:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(data|query)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.schema.saga}
        patterns:
          - match: *entity-name
            name: entity.name.schema.saga
          - include: "#block-entities"
      style:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(style)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.style.saga}
        patterns:
          - match: *entity-name
            name: entity.name.style.saga
          - include: "#block-entities"
      trait:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(trait|impl)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.trait.saga}
        patterns:
          - match: *entity-name
            captures:
              1: {name: entity.name.trait.saga}
          - include: "#block-entities"

  clauses:
    patterns:
      - include: "#for-clause"
      - include: "#if-clause"
      - include: "#switch-clause"
      - include: "#match-clause"
      - include: "#catch-clause"
      - include: "#with-clause"
      - include: "#thread-clause"
      - include: "#do-clause"
      - include: "#when-clause"
      - include: "#case-clause"
      - include: "#type-clause"
      - include: "#new-clause"
      - include: "#method-clause"
      - include: "#function-clause"

    repository:
      function-params:
        patterns: *function-params

      pattern-brackets:
        begin: \s*(\()
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.saga}
        patterns:
          - include: "#function-params"
          - include: $self

      method-clause:
        patterns:
          - comment: |
              Simple arrow method assignment
              x = x =>
            match: |
              (?x)(?<!\.\.+)(?<=[!?~]?\.|[?!:]:|->)
              ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (:?=)\s+
              ([?*&%$]?[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (=>)(?=$|['"\`\\\s\p{pe}])
            captures:
              1: {name: entity.name.function.method.saga}
              2: {name: keyword.operator.assignment.saga}
              3: {patterns: [{include: "#function-params"}]}
              4: {name: storage.type.function.arrow.saga}
          - comment: |
              Method def before function keyword
              x = def()
            match: |
              (?x)(?<!\.\.+)(?<=[!?~]?\.|[?!:]:|->)
              ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (:?=)\s+
              (?=\b
              (?:\s*\b
              (?:# Access modifiers
              pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager
              |lawful|rogue|early|late|unique|handle|over|abs|vol|stat|dyn|final
              |[gs]et|[dr]ef|trans|part|rec|gen|(?:im)?pure|local|global|native
              |(?:un)?(?:sign|safe|check|lock|fixed|size)
              |# Function or method modifiers
              (?:pre|in|post|suf|a[df])fix|
              (?:u|bi|ter|)nary|
              (?:0|[1-9]\d*)ary
              )
              \b\s*)*
              \s*\b
              (?:def|func?|fn|macro|proc|sub)\b
              )
            captures:
              1: {name: entity.name.function.method.saga}
              2: {name: keyword.operator.assignment.saga}
          - comment: |
              Method def before arrow function
              x = async pub (): void =>
            match: |
              (?x)(?<!\.\.+)(?<=[!?~]?\.|[?!:]:|->)
              ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (:?=)\s+
              ((?:(?:
              pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager
              |lawful|rogue|early|late|unique|handle|over|abs|vol|stat|dyn|final
              |[gs]et|[dr]ef|trans|part|rec|gen|(?:im)?pure|local|global|native
              |(?:un)?(?:sign|safe|check|lock|fixed|size)
              |(?:pre|in|post|suf|a[df])fix
              |(?:u|bi|ter|)nary
              |(?:0|[1-9]\d*)ary
              )\s*\b)*)\s*
              ((?:\(.*?\))*)\s*
              (?:\s*(:)\s*(.*))?\s*
              (=>)(?=$|['"\`\\\s\p{pe}])
            captures:
              1: {name: entity.name.function.method.saga}
              2: {name: keyword.operator.assignment.saga}
              3: {name: storage.modifier.saga}
              4: {patterns: [{include: "#pattern-brackets"}]}
              5: {name: punctuation.definition.annotation.saga}
              6: {patterns: [{include: "#types"}]}
              7: {name: storage.type.function.arrow.saga}

      function-clause:
        patterns:
          - comment: |
              Simple arrow function assignment
              x = x =>
            match: |
              (?x)\s*
              ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\+
              (:?=)\+
              ([?*&%$]?[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\+
              (=>)(?=$|['"\`\\\s\p{pe}])
            captures:
              1: {name: entity.name.function.saga}
              2: {name: keyword.operator.assignment.saga}
              3: {patterns: [{include: "#function-params"}]}
              4: {name: storage.type.function.arrow.saga}
          - comment: |
              Simple arrow function
              x =>
            match: |
              (?x)
              ([?*&%$]?[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (=>)(?=$|['"\`\\\s\p{pe}])
            captures:
              1: {patterns: [{include: "#function-params"}]}
              2: {name: storage.type.function.arrow.saga}
          - comment: |
              Function def before function keyword
              x = def()
            match: |
              (?x)\s*
              ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (:?=)\s+
              (?=\b
              (?:\s*\b
              (?:# Access modifiers
              pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager
              |lawful|rogue|early|late|unique|handle|over|abs|vol|stat|dyn|final
              |[gs]et|[dr]ef|trans|part|rec|gen|(?:im)?pure|local|global|native
              |(?:un)?(?:sign|safe|check|lock|fixed|size)
              |# Function or method modifiers
              (?:pre|in|post|suf|a[df])fix|
              (?:u|bi|ter|)nary|
              (?:0|[1-9]\d*)ary
              )
              \b\s*)*
              \s*\b
              (?:def|func?|fn|macro|proc|sub)\b
              )
            captures:
              1: {name: entity.name.function.saga}
              2: {name: keyword.operator.assignment.saga}
          - comment: |
              Function def before arrow function
              x = async pub (): void =>
            match: |
              (?x)\s*
              ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (:?=)\s+
              ((?:(?:
              pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager
              |lawful|rogue|early|late|unique|handle|over|abs|vol|stat|dyn|final
              |[gs]et|[dr]ef|trans|part|rec|gen|(?:im)?pure|local|global|native
              |(?:un)?(?:sign|safe|check|lock|fixed|size)
              |(?:pre|in|post|suf|a[df])fix
              |(?:u|bi|ter|)nary
              |(?:0|[1-9]\d*)ary
              )\s*\b)*)\s*
              ((?:\(.*?\))*)\s*
              (?:\s*(:)\s*(.*))?\s*
              (=>)(?=$|['"\`\\\s\p{pe}])
            captures:
              1: {name: entity.name.function.saga}
              2: {name: keyword.operator.assignment.saga}
              3: {name: storage.modifier.saga}
              4: {patterns: [{include: "#pattern-brackets"}]}
              5: {name: punctuation.definition.annotation.saga}
              6: {patterns: [{include: "#types"}]}
              7: {name: storage.type.function.arrow.saga}
          - comment: |
              Arrow function with modifiers
              async pub (): void =>
            match: |
              (?x)
              ((?:(?:
              pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager
              |lawful|rogue|early|late|unique|handle|over|abs|vol|stat|dyn|final
              |[gs]et|[dr]ef|trans|part|rec|gen|(?:im)?pure|local|global|native
              |(?:un)?(?:sign|safe|check|lock|fixed|size)
              |(?:pre|in|post|suf|a[df])fix
              |(?:u|bi|ter|)nary
              |(?:0|[1-9]\d*)ary
              )\s*\b)*)\s+
              ((?:\(.*?\))*)\s*
              (?:\s*(:)\s*(.*))?\s+
              (=>)(?=$|['"\`\\\s\p{pe}])
            captures:
              1: {name: storage.modifier.saga}
              2: {patterns: [{include: "#pattern-brackets"}]}
              3: {name: punctuation.definition.annotation.saga}
              4: {patterns: [{include: "#types"}]}
              5: {name: storage.type.function.arrow.saga}

      new-clause:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(new)\b
        end: (?=\O)|$
        beginCaptures:
          1: {name: keyword.operator.expression.$1.saga}
        patterns:
          - match: \s*([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
            name: entity.name.instance.saga
          - include: "#block-entities"

      type-clause:
        patterns:
          - applyEndPatternLast: 1
            begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(as|is)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.operator.expression.$1.saga}
            patterns:
              - include: "#types"
          - applyEndPatternLast: 1
            begin: (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(type|alias)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.other.typedef.saga}
            patterns:
              - match: \s*(:?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.saga}
              - include: "#types"
          - applyEndPatternLast: 1
            begin: (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(decl)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.other.declare.saga}
            patterns:
              - match: \s*(:?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.saga}
              - include: "#types"
          - applyEndPatternLast: 1
            begin: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(
              (?:return|give|await|yield|throw|raise)s
              )\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.control.modifier.saga}
            patterns:
              - include: "#types"

      case-clause:
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(case|fail)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.saga}
        beginCaptures:
          1: {name: keyword.control.switch.saga}
        patterns:
          - include: "#clause-content"

      catch-clause:
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(try|retry|catch|rescue|finally)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.saga}
        name: meta.catch.saga
        beginCaptures:
          1: {name: keyword.control.error.saga}
        patterns:
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: meta.brace.round.saga}
            patterns:
              - match: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(as)\b
                name: keyword.control.error.saga
              - include: "#clause-content"
          - include: "#curly-brackets"
          - match: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(as)\b
            name: keyword.control.error.saga
          - include: "#clause-content"

      thread-clause:
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(para|series|spawn)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.saga}
        name: meta.parallel.saga
        beginCaptures:
          1: {name: keyword.control.parallel.saga}
        patterns:
          - begin: \s*(\()
            end: \s*(\))
            beginCaptures:
              1: {name: meta.brace.round.saga}
            patterns:
              - match: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(as)\b
                name: keyword.control.parallel.saga
              - include: "#clause-content"
          - include: "#curly-brackets"
          - match: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(as)\b
            name: keyword.control.parallel.saga
          - include: "#clause-content"

      do-clause:
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(do|redo)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.saga}
        name: meta.do.saga
        beginCaptures:
          1: {name: keyword.control.do.saga}
        patterns:
          - include: "#round-brackets"
          - include: "#curly-brackets"
          - include: "#clause-content"

      for-clause:
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(for|each|while|until|repeat)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.saga}
        name: meta.for.saga
        beginCaptures:
          1: {name: keyword.control.loop.saga}
        patterns:
          - match: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(in|of|to|til|thru|at|by)\b
            name: keyword.control.loop.saga
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: meta.brace.round.saga}
            patterns:
              - match: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(in|of|to|til|thru|at|by)\b
                name: keyword.control.loop.saga
              - include: "#clause-content"
          - include: "#curly-brackets"
          - include: "#clause-content"

      if-clause:
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(if|elif|else|unless|eless|guard)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.saga}
        name: meta.if.saga
        beginCaptures:
          1: {name: keyword.control.conditional.saga}
        patterns:
          - include: "#curly-brackets"
          - include: "#round-brackets"
          - include: "#clause-content"

      match-clause:
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(match)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.saga}
        name: meta.match.saga
        beginCaptures:
          1: {name: keyword.control.match.saga}
        patterns:
          - include: "#clause-content"

      switch-clause:
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(switch)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.saga}
        name: meta.switch.saga
        beginCaptures:
          1: {name: keyword.control.switch.saga}
        patterns:
          - include: "#round-brackets"
          - begin: \s*({)
            end: \s*(?=})
            beginCaptures:
              1: {name: meta.brace.curly.switchStart.saga}
            patterns:
              - include: "#case-clause"
              - include: "#clause-content"
          - include: "#clause-content"

      when-clause:
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(when)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.saga}
        beginCaptures:
          1: {name: keyword.control.match.saga}
        patterns:
          - applyEndPatternLast: 1
            begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(as|is)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.control.match.saga}
            patterns:
              - include: "#types"
          - applyEndPatternLast: 1
            begin: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b((?:return|give|await|yield|throw|raise)s?)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.control.match.saga}
            patterns:
              - include: "#types"
          - begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(if|elif|else|unless|eless|guard)\b
            end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
            endCaptures:
              0: {name: punctuation.separator.colon.saga}
            beginCaptures:
              1: {name: keyword.control.match.saga}
            patterns:
              - include: "#clause-content"
          - include: "#type-operators"
          - include: "#clause-content"

      with-clause:
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(with)\b
        end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
        endCaptures:
          0: {name: punctuation.separator.colon.saga}
        name: meta.with.saga
        beginCaptures:
          1: {name: keyword.control.with.saga}
        patterns:
          - include: "#curly-brackets"
          - begin: \s*
            end: \s*(?=[{,])
            patterns:
              - match: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(as)\b
                name: keyword.control.with.saga
              - include: "#clause-content"
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: meta.brace.round.saga}
            patterns:
              - match: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(as)\b
                name: keyword.control.with.saga
              - include: "#clause-content"
          - include: "#clause-content"

  punctuation:
    patterns:
      - include: "#line-continuation"
      - include: "#comma"
      - include: "#right-arrow"
      - include: "#fat-arrow"
      - include: "#semicolon"
      - include: "#double-semi"

    repository:
      line-continuation:
        match: (\\)\s*(?=#|$)
        captures:
          1: {name: punctuation.separator.continuation.line.saga}
      comma:
        match: \s*(,)
        captures:
          1: {name: punctuation.separator.comma.saga}
      right-arrow:
        match: (?:^|['"\`\\\p{ps}\s]*)(->)(?:$|['"\`\\\s\p{pe}])
        captures:
          1: {name: punctuation.definition.arrow.saga}
      fat-arrow:
        match: (?:^|['"\`\\\p{ps}\s]*)(=>)(?:$|['"\`\\\s\p{pe}])
        captures:
          1: {name: storage.type.function.arrow.saga}
      double-semi:
        match: \s*(;;)
        captures:
          1: {name: punctuation.terminator.statement.saga}
      semicolon:
        match: \s*(;)(?!;)
        captures:
          1: {name: punctuation.terminator.expression.saga}

  brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.mapping.saga
          - match: (?<=\b|^|[\p{pe}'"\`\\\s])(:)(?=\b|$|[\p{ps}'"\`\\\s])
            captures:
              1: {name: punctuation.separator.key-value.saga}

    patterns:
      - begin: \s*(\{\|)
        end: \s*(\|\})
        captures:
          1: {name: punctuation.definition.mapping.saga}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(\{)
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.dictionary.saga}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.arguments.saga

    patterns:
      - begin: \s*(\(\|)
        end: \s*(\|\))
        captures:
          1: {name: punctuation.definition.parameters.saga}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: \s*(\()
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.expression.saga}
        patterns:
          - include: "#punctuation"
          - include: $self

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: (?<=\b|^|[\p{pe}'"\`\\\s])(:)(?=\b|$|[\p{ps}'"\`\\\s])
            captures:
              1: {name: punctuation.separator.slice.saga}
          - match: ","
            name: punctuation.separator.sequence.saga

    patterns:
      - begin: \s*(\[<)
        end: \s*(>\])
        captures:
          1: {name: punctuation.definition.typeparameters.saga}
        patterns:
          - include: "#types"
          - include: $self
      - begin: \s*(\[\|)
        end: \s*(\|\])
        captures:
          1: {name: punctuation.definition.sequence.saga}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: \s*(\[)
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.array.saga}
        patterns:
          - include: "#punctuation"
          - include: $self

  patterns:
    - include: "#round-brackets"
    - include: "#square-brackets"
    - include: "#curly-brackets"

  support-modules:
    patterns:
  support-constants:
    patterns:
  support-functions:
    patterns:

  support-types:
    patterns:
      - comment: primitive data types
        match: |
          (?x)\s*\b(
          bool|int|float|[nr]at|real|imag|comp|num
          |char|rune|str|sym|regex|func?|buff|bin
          |# numeric types
          (?:c|i|f|s|u|n|[nr]at|u?int|float|imag|comp)
          (?:8|16|32|64|128)
          |(?:c|i|)(?:half|float|double|quad|oct)
          )\b
        name: support.type.builtin.primitive.saga
      - comment: built-in constant types
        match: |
          (?x)\s*\b(
          true|yes|on|false|no|off
          |null|nil|none|undef|void
          |nan|inf|infin
          |any|empty|obj|rec|unit|mix|this|that|it|self|super
          |arr|tuple|list|set|map|dict|seq|gen|range
          )\b
        name: support.type.builtin.saga
      - comment: built-in primitive classes
        match: |
          (?x)\s*\b(
          Bool|Int|Float|[NR]at|Real|Imag|Comp|Number
          |Char|Rune|String|Symbol|RegExp?|Func|Buffer|Binary
          |# numeric types
          (?:C|I|F|S|U|N|[NR]at|U?Int|Real|Imag|Comp)
          (?:8|16|32|64|128)
          |(?:C|I|)(?:Half|Float|Double|Quad|Oct)
          )\b
        name: support.type.builtin.class.saga
      - comment: built-in primitive type classes
        match: |
          (?x)\s*\b(
          True|False|Nil|Void|NaN|Infin
          |Any|Empty|Object|Record|Unit|Mixed
          |Array|Tuple|List|Set|Map|Dict|Seq|Gen|Range
          )\b
        name: support.type.class.saga
      - comment: interface classes (beginning with I)
        match: (?x)\s*\b(I((\p{lu}\p{ll}*)+))\b
        name: entity.name.interface.saga
      - comment: namespace classes (beginning with NS)
        match: (?x)\s*\b(NS((\p{lu}\p{ll}*)+))\b
        name: entity.name.namespace.saga
      - comment: error classes (ending with Error)
        match: (?x)\s*\b(((\p{lu}\p{ll}*)+)Error)\b
        name: support.class.error.saga
