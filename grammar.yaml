information_for_contributors:
  - This file is a grammar for the Bach programming language, whose syntax is
  - inspired by Python, Ruby, OCaml, Nim, Elixir, F#, Go, Swift, Bash, and Smalltalk.

  - Should you want to provide a fix or improvement, or even a new feature,
  - please create a pull request against this repo - https://github.com/nxltm/nyx
  - and I will be very happy to receive them.

  - Once accepted, I am happy to receive your request and feedback.

  - This document is under construction, and might take several weeks/months
  - to edit.

  - Updates:
      - Only _ is counted as a `_` character. The rest are considered operator characters.

  - To-do:
      - Add object/list/map destructuring syntax
      - Add color, date/time, advanced numeric literals and more.
      - Add YAML/Bash unquoted literals

  - Doing:
      - Add standard library stuff (the bulk of this grammar)
      - - Python, PHP, Perl, CSS, HTML, JS, TS, Swift, R, C, C++,
        - Bash, Shell, SQL and more
        - Dictionaries from Code Spell Checker (see https://github.com/nxltm/cspell-dicts)
        - NumPy, Pandas, NLTK, Gensim and more (see libraries in action)

  - Done:
      - Revamp literals
      - Fixed pipeline/composition operator highlighting
      - Added string, number, symbol and regex literals
      - Fixed highlighting for pipeline operator
      - Added syntax for bracket-less function/method calls
      - Rework regex syntax (brackets)

name: Nyx
scopeName: source.coffee
fileTypes: [bach, coffee]
patterns: [{include: "#core"}]

repository:
  core:
    patterns:
      - include: "#punctuation"
      - include: "#definitions"
      - include: "#clauses"
      - include: "#comments"
      - include: "#brackets"
      - include: "#literals"
      - include: "#type-annotation"
      - include: "#operators"
      - include: "#keywords"
      - include: "#calls"
      - include: "#variables"
      # - include: "#support"

  clause-content:
    patterns:
      - include: "#punctuation"
      - include: "#definitions"
      - include: "#clauses"
      - include: "#comments"
      - include: "#brackets"
      - include: "#literals"
      - include: "#type-annotation"
      - include: "#operators"
      - include: "#keywords"
      - include: "#calls"
      - include: "#variables"

  entities:
    patterns:
      - include: "#function-names"
      - include: "#constant-names"
      - include: "#type-names"

    repository:
      function-names:
        patterns: []
        comment: Names for built-in functions

      method-names:
        patterns: []
        comment: Names for static and instance methods

      constant-names:
        patterns: []
        comment: Names for constants, symbols and static properties

      type-names:
        patterns: []
        comment: Names for types and more

      variable-names:
        patterns: []
        comment: Standard Library variable names

      property-names:
        patterns: []
        comment: Standard Library property names

  symbols:
    patterns:
      - match: |
          (?x)
          (?<=^|\p{ps}|\s+)(:)(
          [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*# prefix

          (?!
          \b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|keyof|valof
          |len|del|to|til|thru|at|by
          |and|x?or|not
          |def|func?|fn|macro|proc|sub
          |let|var|val|const|decl
          |class|given|constr|enum
          |extend|frag|inter|struct
          |module|nspace|object|record|label
          |raw|data|schema|style|trait|alias
          |if|else|elif|eless|unless|guard
          |for|each|while|until|do|redo
          |switch|case|fail|match|when|pass
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |(?:break|continue|halt|skip|return|give|await|yield|throw|raise)s?
          |yield\b\s*\bfrom|import|export|show|hide
          |from|where|join|equals|[io]nto|order
          |take|drop|fold|scan|use|using
          |open|close
          )\b
          )

          [_\p{l}\p{m}\p{n}]+
          (?:[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*# adfix
          [_\p{l}\p{m}\p{n}]+)*
          [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*# suffix
          )(?=\s)
        name: meta.object-literal.key.bach
        captures:
          1: {name: punctuation.definition.symbol.bach}
          2: {patterns: [{include: "#symbol"}]}
    repository:
      symbol:
        match: \S+
        name: constant.other.symbol.bach

  labels:
    patterns:
      - match: |
          (?x)
          (
          [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*# prefix

          (?!
          \b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|keyof|valof
          |len|del|to|til|thru|at|by
          |and|x?or|not
          |def|func?|fn|macro|proc|sub
          |let|var|val|const|decl
          |class|given|constr|enum
          |extend|frag|inter|struct
          |module|nspace|object|record|label
          |raw|data|schema|style|trait|alias
          |if|else|elif|eless|unless|guard
          |for|each|while|until|do|redo
          |switch|case|fail|match|when|pass
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |(?:break|continue|halt|skip|return|give|await|yield|throw|raise)s?
          |yield\b\s*\bfrom|import|export|show|hide
          |from|where|join|equals|[io]nto|order
          |take|drop|fold|scan|use|using
          |open|close
          )\b
          )

          [_\p{l}\p{m}\p{n}]+
          (?:[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*# adfix
          [_\p{l}\p{m}\p{n}]+)*
          [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*# suffix
          )(:)(?=\s)
        name: meta.object-literal.key.bach
        captures:
          1: {patterns: [{include: "#label-keys"}]}
          2: {name: punctuation.separator.key-value.bach}
    repository:
      label-keys:
        patterns:
          - include: "#number"
          - match: '[^\s:]+'
            name: constant.other.object.key.bach

  document:
    patterns:
      - include: "#document-inline-tags"
      - include: "#document-access"
      - include: "#document-as-name-path"
      - include: "#document-simple-name-path"
      - include: "#document-module"
      - include: "#document-type-name"
      - include: "#document-type-no-name"
      - match: (?<=^|[''"\`\s\p{ps}])@([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\b
        name: storage.type.class.bach

    repository:
      document-access:
        match: |
          (?x)
          (@acc)\b\s*\b
          (?:
          (?:
          pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager
          |greedy|early|late|unique|handle|over|abs|vol|stat|dyn|final
          |[gs]et|[dr]ef|trans|part|rec|gen|(?:im)?pure|local|global|native
          |(?:un)?(?:sign|safe|check|lock|fixed|size)
          |(?:pre|in|post|suf|a[df])fix
          |(?:u|bi|ter|)nary
          |(?:0|[1-9]\d*)ary
          )\s*\b
          )*
          (?=\s|$)
        captures:
          1: {name: storage.type.class.bach}
          0: {name: storage.modifier.bach}
      document-as-name-path:
        begin: (@(borrows|lends)\b)\s*(?=(?![}\]]\#)\S+(?:(?:\s*\bas\b\s*(?![}\]]\#)\S+)?)?([\S\s]*))
        end: ^|(?=[}\]]\#)|(?=\3$)
        beginCaptures:
          1: {name: storage.type.class.bach}
        patterns:
          - include: "#document-name-path-scopes"
      document-inline-tags:
        begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
        end: (})
        name: meta.tag.inline.bach
        beginCaptures:
          1: {name: string.linktext.bach}
          2: {name: meta.brace.curly.bach}
        endCaptures:
          1: {name: meta.brace.curly.bach}
        patterns:
          - match: (@(link|tutorial))\b([^}]*)
            captures:
              1: {name: storage.type.class.bach}
              3: {name: string.bach}
      document-module:
        begin: |
          (?x)(@(
          (?:(?:im|ex)port|listen|require|use)s?
          )\b)
          \s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
        end: ^|(?=[}\]]\#)|(?=\5$)
        beginCaptures:
          1: {name: storage.type.class.bach}
        patterns:
          - include: "#document-typedef-scopes"
          - match: (?:(module)(:))?(((?![}\]]\#)\S)+)
            captures:
              1: {name: keyword.module.bach}
              2: {name: punctuation.bach}
              3: {name: string.module-name.bach}
      document-name-scopes:
        patterns:
          - match: ((?![}\]]\#)[\S&&[^\[\]"']])+
            captures:
              0: {name: variable.other.bach}
          - begin: \[
            end: \]|^
            name: variable.other.bach
            patterns:
              - include: "#document-string"
              - include: "#document-name-scopes"
      document-simple-name-path:
        begin: |
          (?x)(@(
          (?:use|call|emit|event|fire)s?|alias|name|mixes|prop
          |this|that|it|self|super
          )\b)
          \s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
        end: ^|(?=[}\]]\#)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.bach}
        patterns:
          - include: "#document-typedef-scopes"
          - include: "#types"
      document-string:
        match: '"(\\"|[^"])*"|''(\\''|[^''])*'''
        name: string.bach
      document-type-name:
        begin: |
          (?x)(@(
          def|func?|fn|macro|proc|sub|class|given|constr?|enum
          |extend|frag|inter|struct|module|nspace|object|record|raw
          |data|schema|style|trait|alias|decl|let|va[rl]
          |arg|ctor|member|method|mixin|param
          )\b)\s*
          (?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
        end: ^|(?=[}\]]\#)|(?=\7$)
        beginCaptures:
          1: {name: storage.type.class.bach}
        patterns:
          - include: "#document-typedef-scopes"
          - include: "#document-name-scopes"
      document-type-no-name:
        begin: |
          (?x)
          (@(
          pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager
          |greedy|early|late|unique|handle|over|abs|vol|stat|dyn|final
          |[gs]et|[dr]ef|trans|part|rec|gen|(?:im)?pure|local|global|native
          |(?:un)?(?:sign|safe|check|lock|fixed|size)
          |except|ext|impl|(?:break|continue|halt|skip|return|give|await|yield|throw|raise)s?
          |(?:pre|in|post|suf|a[df])fix
          |(?:u|bi|ter|)nary
          |(?:0|[1-9]\d*)ary
          )\b)
          \s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*([\S\s]*))
        end: ^|(?=[}\]]\#)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.bach}
        patterns:
          - include: "#document-typedef-scopes"
      document-typedef-obj:
        begin: "{"
        end: "}|^"
        captures:
          0: {name: meta.brace.curly.bach}
        patterns:
          - include: "#types"
      document-typedef-scopes:
        begin: "{"
        end: "}|^"
        name: entity.name.type.instance.bach
        captures:
          0: {name: meta.brace.curly.bach}
        patterns:
          - include: "#types"

  comments:
    patterns:
      - include: "#typed-comments"
      - include: "#special-comments-conditional-compilation"
      - begin: \s*((#\())
        end: (\s*(\)))
        name: comment.block.inline.bach
        captures:
          1: {name: comment.block.inline.bach}
          2: {name: punctuation.definition.comment.bach}
        patterns:
          - include: "#markdown-inline"
          - include: "#nested-inline"
      - begin: \s*((#{))
        end: (\s*(}#))
        name: comment.block.documentation.bach
        captures:
          1: {name: comment.block.documentation.bach}
          2: {name: punctuation.definition.comment.bach}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
          - include: "#nested-document-block"
      - begin: \s*((#\[))
        end: (\s*(\]#))
        name: comment.block.bach
        captures:
          1: {name: comment.block.bach}
          2: {name: punctuation.definition.comment.bach}
        patterns:
          - include: "#markdown-inline"
          - include: "#nested-block"
      - begin: ((^\s*)|\s*)((#=))
        end: \s*$
        name: comment.line.special.bach
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.bach}
          3: {name: comment.line.special.bach}
          4: {name: punctuation.definition.comment.bach}
        endCaptures:
          1: {name: punctuation.definition.comment.bach}
        patterns:
          - include: "#comment-special"
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((##))
        end: \s*$
        name: comment.line.playground.bach
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.bach}
          3: {name: comment.line.playground.bach}
          4: {name: punctuation.definition.comment.bach}
        endCaptures:
          0: {name: comment.line.playground.bach}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((#:))
        end: \s*$
        name: comment.line.documentation.bach
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.bach}
          3: {name: comment.line.documentation.bach}
          4: {name: punctuation.definition.comment.bach}
        endCaptures:
          0: {name: comment.line.documentation.bach}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((#!))
        end: \s*$
        name: comment.line.shebang.bach
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.bach}
          3: {name: comment.line.shebang.bach}
          4: {name: punctuation.definition.comment.bach}
        endCaptures:
          0: {name: comment.line.shebang.bach}
        patterns:
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((#\?))
        end: \s*$
        name: comment.line.doctype.bach
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.bach}
          3: {name: comment.line.doctype.bach}
          4: {name: punctuation.definition.comment.bach}
        endCaptures:
          0: {name: comment.line.doctype.bach}
        patterns:
          - include: "#markdown-inline"
      - begin: ((^\s*)|\s*)((#))
        end: \s*$
        name: comment.line.number-sign.bach
        beginCaptures:
          2: {name: punctuation.whitespace.comment.leading.bach}
          3: {name: comment.line.double-slash.bach}
          4: {name: punctuation.definition.comment.bach}
        endCaptures:
          0: {name: comment.line.number-sign.bach}
        patterns:
          - include: "#markdown-inline"

    repository:
      markdown-inline:
        patterns:
          - include: text.html.markdown#inline
      nested-block:
        begin: (#\[)\s*
        end: \s*(\]#)
        captures:
          1: {name: punctuation.definition.comment.bach}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
          - include: "#nested-block"
      nested-document-block:
        begin: (#{)\s*
        end: \s*(}#)
        captures:
          1: {name: punctuation.definition.comment.bach}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
          - include: "#nested-document-block"
      nested-inline:
        begin: (\()\s*
        end: \s*(\))
        name: comment.block.inline.bach
        captures:
          1: {name: punctuation.definition.comment.bach}
        patterns:
          - include: "#markdown-inline"
          - include: "#nested-inline"
      nested-special:
        begin: (\()\s*
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.comment.bach}
        patterns:
          - include: "#document"
          - include: "#markdown-inline"
          - include: "#nested-special"

  literals:
    patterns:
      - include: "#constants"
      - include: "#numbers"
      - include: "#strings"
      - include: "#symbols"
      - include: "#regexes"

  constants:
    patterns:
      - match: |
          (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(?:
          (true|yes|on)|(false|no|off)|(null|nil|none)|(undef|void)|(nan)|(inf|infin)
          )\b
        captures:
          1: {name: constant.language.boolean.true.bach}
          2: {name: constant.language.boolean.false.bach}
          3: {name: constant.language.null.bach}
          4: {name: constant.language.undefined.bach}
          5: {name: constant.language.nan.bach}
          6: {name: constant.language.infinity.bach}
      - match: |
          (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(?:
          (params|args)|(super|this|self|proto)|(\\proto|main)|(ctor)|(targ)
          )\b
        captures:
          1: {name: variable.language.arguments.bach}
          2: {name: variable.language.$2.bach}
          3: {name: variable.language.prototype.bach}
          4: {name: variable.language.constructor.bach}
          5: {name: variable.language.target.bach}

  numbers:
    patterns:
      - match: (?<=(^|\p{ps})\s*\d\w*)\.
        name: punctuation.separator.decimal.period.bach
      - match: (?<=^\s*|\p{ps}\s*|\s)\.(?=\d)
        name: punctuation.separator.decimal.period.bach
      - match: (?xi)\b(0b(?:[01](?:_*[01]+)*)?(\.)[01](?:_*[01]+)*(?:(r)[01](?:_*[01]+)*)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?)\b
        captures:
          1: {name: constant.numeric.binary.bach}
          2: {name: punctuation.separator.decimal.period.bach}
          3: {name: storage.type.numeric.bach}
          4: {name: storage.type.numeric.bach}
          5: {name: storage.type.numeric.bach}
          6: {name: storage.type.numeric.bach}
      - match: (?xi)\b(0b[01](?:_*[01]+)*(?:(\.)[01](?:_*[01]+)*)?(?:(r)[01](?:_*[01]+)*)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?)\b
        captures:
          1: {name: constant.numeric.binary.bach}
          2: {name: punctuation.separator.decimal.period.bach}
          3: {name: storage.type.numeric.bach}
          4: {name: storage.type.numeric.bach}
          5: {name: storage.type.numeric.bach}
          6: {name: storage.type.numeric.bach}
      - match: (?xi)\b(0q(?:[0-3](?:_*[0-3]+)*)?(\.)[0-3](?:_*[0-3]+)*(?:(r)[0-3](?:_*[0-3]+)*)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?)\b
        captures:
          1: {name: constant.numeric.quaternary.bach}
          2: {name: punctuation.separator.decimal.period.bach}
          3: {name: storage.type.numeric.bach}
          4: {name: storage.type.numeric.bach}
          5: {name: storage.type.numeric.bach}
          6: {name: storage.type.numeric.bach}
      - match: (?xi)\b(0q[0-3](?:_*[0-3]+)*(?:(\.)[0-3](?:_*[0-3]+)*)?(?:(r)[0-3](?:_*[0-3]+)*)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?)\b
        captures:
          1: {name: constant.numeric.quaternary.bach}
          2: {name: punctuation.separator.decimal.period.bach}
          3: {name: storage.type.numeric.bach}
          4: {name: storage.type.numeric.bach}
          5: {name: storage.type.numeric.bach}
          6: {name: storage.type.numeric.bach}
      - match: (?xi)\b(0s(?:[0-5](?:_*[0-5]+)*)?(\.)[0-5](?:_*[0-5]+)*(?:(r)[0-5](?:_*[0-5]+)*)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?)\b
        captures:
          1: {name: constant.numeric.senary.bach}
          2: {name: punctuation.separator.decimal.period.bach}
          3: {name: storage.type.numeric.bach}
          4: {name: storage.type.numeric.bach}
          5: {name: storage.type.numeric.bach}
          6: {name: storage.type.numeric.bach}
      - match: (?xi)\b(0s[0-5](?:_*[0-5]+)*(?:(\.)[0-5](?:_*[0-5]+)*)?(?:(r)[0-5](?:_*[0-5]+)*)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?)\b
        captures:
          1: {name: constant.numeric.senary.bach}
          2: {name: punctuation.separator.decimal.period.bach}
          3: {name: storage.type.numeric.bach}
          4: {name: storage.type.numeric.bach}
          5: {name: storage.type.numeric.bach}
          6: {name: storage.type.numeric.bach}
      - match: (?xi)\b(0o(?:[0-7](?:_*[0-7]+)*)?(\.)[0-7](?:_*[0-7]+)*(?:(r)[0-7](?:_*[0-7]+)*)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?)\b
        captures:
          1: {name: constant.numeric.octal.bach}
          2: {name: punctuation.separator.decimal.period.bach}
          3: {name: storage.type.numeric.bach}
          4: {name: storage.type.numeric.bach}
          5: {name: storage.type.numeric.bach}
          6: {name: storage.type.numeric.bach}
      - match: (?xi)\b(0o[0-7](?:_*[0-7]+)*(?:(\.)[0-7](?:_*[0-7]+)*)?(?:(r)[0-7](?:_*[0-7]+)*)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?)\b
        captures:
          1: {name: constant.numeric.octal.bach}
          2: {name: punctuation.separator.decimal.period.bach}
          3: {name: storage.type.numeric.bach}
          4: {name: storage.type.numeric.bach}
          5: {name: storage.type.numeric.bach}
          6: {name: storage.type.numeric.bach}
      - match: (?xi)\b(0z(?:[\dabetxz](?:_*[\dabetxz]+)*)?(\.)[\dabetxz](?:_*[\dabetxz]+)*(?:(r)[\dabetxz](?:_*[\dabetxz]+)*)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?)\b
        captures:
          1: {name: constant.numeric.duodecimal.bach}
          2: {name: punctuation.separator.decimal.period.bach}
          3: {name: storage.type.numeric.bach}
          4: {name: storage.type.numeric.bach}
          5: {name: storage.type.numeric.bach}
          6: {name: storage.type.numeric.bach}
      - match: (?xi)\b(0z[\dabetxz](?:_*[\dabetxz]+)*(?:(\.)[\dabetxz](?:_*[\dabetxz]+)*)?(?:(r)[\dabetxz](?:_*[\dabetxz]+)*)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?)\b
        captures:
          1: {name: constant.numeric.duodecimal.bach}
          2: {name: punctuation.separator.decimal.period.bach}
          3: {name: storage.type.numeric.bach}
          4: {name: storage.type.numeric.bach}
          5: {name: storage.type.numeric.bach}
          6: {name: storage.type.numeric.bach}
      - match: (?xi)\b(0x(?:\h(?:_*\h+)*)?(\.)\h(?:_*\h+)*(?:(r)\h(?:_*\h+)*)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?)\b
        captures:
          1: {name: constant.numeric.hexadecimal.bach}
          2: {name: punctuation.separator.decimal.period.bach}
          3: {name: storage.type.numeric.bach}
          4: {name: storage.type.numeric.bach}
          5: {name: storage.type.numeric.bach}
          6: {name: storage.type.numeric.bach}
      - match: (?xi)\b(0x\h(?:_*\h+)*(?:(\.)\h(?:_*\h+)*)?(?:(r)\h(?:_*\h+)*)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?)\b
        captures:
          1: {name: constant.numeric.hexadecimal.bach}
          2: {name: punctuation.separator.decimal.period.bach}
          3: {name: storage.type.numeric.bach}
          4: {name: storage.type.numeric.bach}
          5: {name: storage.type.numeric.bach}
          6: {name: storage.type.numeric.bach}
      - match: (?xi)\b((?:\d(?:_*\d+)*)?(\.)\d(?:_*\d+)*(?:(r)\d(?:_*\d+)*)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?)\b
        captures:
          1: {name: constant.numeric.decimal.bach}
          2: {name: punctuation.separator.decimal.period.bach}
          3: {name: storage.type.numeric.bach}
          4: {name: storage.type.numeric.bach}
          5: {name: storage.type.numeric.bach}
          6: {name: storage.type.numeric.bach}
      - match: (?xi)\b(\d(?:_*\d+)*(?:(\.)\d(?:_*\d+)*)?(?:(r)\d(?:_*\d+)*)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?)\b
        captures:
          1: {name: constant.numeric.decimal.bach}
          2: {name: punctuation.separator.decimal.period.bach}
          3: {name: storage.type.numeric.bach}
          4: {name: storage.type.numeric.bach}
          5: {name: storage.type.numeric.bach}
          6: {name: storage.type.numeric.bach}
      - match: (?xi)\b(\d\w(?:\w(?:_*\w+)*)?(\.)\w(?:_*\w+)*(?:(r)\w(?:_*\w+)*)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?)\b
        captures:
          1: {name: constant.numeric.illegal.bach}
          2: {name: punctuation.separator.decimal.period.bach}
          3: {name: storage.type.numeric.bach}
          4: {name: storage.type.numeric.bach}
          5: {name: storage.type.numeric.bach}
          6: {name: storage.type.numeric.bach}
      - match: (?xi)\b(\d\w\w(?:_*\w+)*(?:(\.)\w(?:_*\w+)*)?(?:(r)\w(?:_*\w+)*)?(?:(p[+-]?)\d+)?(?:(s)\d+)?(?:(\\)\w+)?)\b
        captures:
          1: {name: constant.numeric.illegal.bach}
          2: {name: punctuation.separator.decimal.period.bach}
          3: {name: storage.type.numeric.bach}
          4: {name: storage.type.numeric.bach}
          5: {name: storage.type.numeric.bach}
          6: {name: storage.type.numeric.bach}

  strings:
    patterns:
      - comment: single quoted raw string
        begin: \s*('{3,})
        contentName: string.quoted.single.bach
        end: \s*((\1)(?!\1))
        captures:
          1: {name: punctuation.definition.string.bach}
        patterns:
          - include: "#embedded-raw"
      - comment: simple single quoted raw string
        begin: \s*(')
        contentName: string.quoted.single.bach
        end: \s*((\1)(?!\1))
        captures:
          1: {name: punctuation.definition.string.bach}
        patterns:
          - match: "''"
            name: constant.character.escape.bach
          - include: "#embedded-raw"
      - comment: double quoted standard string
        begin: \s*("{3,}|")
        contentName: string.quoted.double.bach
        end: \s*((\1)(?!\1))
        captures:
          1: {name: punctuation.definition.string.bach}
        patterns:
          - include: "#string-escapes"

  string-escapes:
    patterns:
      - match: \\(?=\s*$)
        name: constant.character.escape.newline.bach
      - match: (?i)\\b(?:[01]{1,21}|{[01\s]+?})
        name: constant.character.escape.binary.bach
      - match: (?i)\\q(?:[0-3]{1,11}|{[0-3\s]+?})
        name: constant.character.escape.quaternary.bach
      - match: (?i)\\s(?:[0-5]{1,8}|{[0-5\s]+?})
        name: constant.character.escape.senary.bach
      - match: (?i)\\o(?:[0-7]{1,7}|{[0-7\s]+?})
        name: constant.character.escape.octal.bach
      - match: (?i)\\d?\d{1,7}|\\d{[\d\s]+?}
        name: constant.character.escape.decimal.bach
      - match: (?i)\\z(?:[\dabetxz]{1,6}|{[\s\dabetxz]+?})
        name: constant.character.escape.duodecimal.bach
      - match: (?i)\\x(?:\h{1,6}|{[\h\s]+?})
        name: constant.character.escape.hexadecimal.bach
      - match: (?i)\\u(?:\h{1,6}|{[\h\s]+?})
        name: constant.character.escape.unicode.bach
      - begin: (?i)\\j{
        end: \s*}
        name: constant.character.entity.named.bach
        patterns:
          - include: "#regexp-patterns"
      - match: (?i)\\(a|n|r|t|b|f|v|e|c|l|z|p)
        name: constant.character.escape.bach
      - match: \\[\p{s}\p{p}]
        name: constant.character.escape.symbol.bach
      - match: \\[\p{l}\p{n}]
        name: constant.character.escape.illegal.bach
      - include: "#embedded"

  embedded:
    patterns:
      - match: (\$)(\d+)
        captures:
          1: {name: punctuation.quasi.element.bach}
          2: {name: constant.numeric.decimal.bach}
      - match: (%)((['"\`])(?:\\\g<-1>|.)*?\g<-1>|\w+(?:[^\s'"\`]+\w+)*)
        captures:
          1: {name: punctuation.separator.key-value.bach}
          2: {name: storage.type.format.bach}
      - match: |
          (?xi)
          (?<!\\)# no backslash
          (\$)# prefix
          (
          [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
          )# variable
        captures:
          1: {name: punctuation.quasi.element.bach}
          2: {patterns: [{include: $self}]}
      - begin: (?<!\\)(\${)\s*
        end: (})
        name: entity.quasi.element.bach
        captures:
          1: {name: punctuation.quasi.element.bach}
        patterns:
          - include: $self

  embedded-raw:
    patterns:
      - match: (\$)(\d+)
        captures:
          1: {name: punctuation.quasi.element.bach}
          2: {name: constant.numeric.decimal.bach}
      - match: ([$%]){2}
        name: constant.character.escape.bach
      - match: (%)((['"\`])(?:\\\g<-1>|.)*?\g<-1>|\w+(?:[^\s'"\`]+\w+)*)
        captures:
          1: {name: punctuation.separator.key-value.bach}
          2: {name: storage.type.format.bach}
      - match: |
          (?xi)
          (?<!\$)# no dollar
          (\$)# prefix
          (
          [_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
          (?:(?:[?!~]?\.|[?!:]:|->)
          (?:(?:[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)))*
          )# variable
        captures:
          1: {name: punctuation.quasi.element.bach}
          2: {patterns: [{include: $self}]}
      - begin: (?<!\$)(\${)\s*
        end: (})
        name: entity.quasi.element.bach
        captures:
          1: {name: punctuation.quasi.element.bach}
        patterns:
          - include: $self

  regexes:
    begin: (\p{alnum}*)(\`)\s*
    end: \s*(?!\\)(\`(?!\`))(\p{alnum}*)
    contentName: string.pattern.regexp.bach
    beginCaptures:
      1: {name: keyword.modifier.bach}
      2: {name: punctuation.section.regexp.begin.bach}
    endCaptures:
      1: {name: punctuation.section.regexp.end.bach}
      2: {name: keyword.other.flag.bach}
    patterns:
      - include: "#comments"
      - include: "#regexp-patterns"
      - begin: (\`)(\`)\s*\n?
        end: \s*(?=(?!\\)\`)
        contentName: string.replace.regexp.bach
        beginCaptures:
          1: {name: punctuation.section.regexp.end.bach}
          2: {name: punctuation.section.regexp.begin.bach}
        patterns:
          - include: "#back-references"

  back-references:
    patterns:
      - match: \$[&+-]
        name: keyword.other.back-reference.bach
      - match: \${2}
        name: constant.character.escape.bach
      - begin: (\$<)
        end: \s*(>)
        name: keyword.other.back-reference.bach
        beginCaptures:
          1: {name: keyword.other.back-reference.bach}
        endCaptures:
          1: {name: keyword.other.back-reference.bach}
        patterns:
          - include: "#variables"
          - include: "#operators"
          - include: "#numbers"
      - include: "#string-escapes"

  regexp-patterns:
    patterns:
      - include: "#embedded"
      - include: "#comments"
      - match: \|
        name: keyword.operator.or.bach
      - match: \&
        name: keyword.operator.match.bach
      - match: \!
        name: keyword.operator.disjunction.bach
      - match: \.
        name: constant.character.all.bach
      - match: (?i)\\[by]({\p{alpha}+})?
        name: keyword.control.anchor.bach
      - match: (?i)(\^|\\<|\\a(?:{\p{alpha}+})?)|(\$|\\>|\\z(?:{\p{alpha}+})?)
        captures:
          1: {name: keyword.control.begin.bach}
          2: {name: keyword.control.end.bach}
      - match: (\\\()(?:(\?)|(\+)|(\*))
        captures:
          1: {name: constant.character.escape.other.bach}
          2: {name: keyword.operator.quantifier.lazy.bach}
          3: {name: keyword.operator.quantifier.eager.bach}
          4: {name: keyword.operator.quantifier.greedy.bach}
      - match: \\\d+
        name: keyword.other.back-reference.bach
      - match: \{(\s*\d*\s*(?:,?\s*\d*\s*)*)\}
        name: keyword.operator.quantifier.bach
      - begin: (\\Q)
        contentName: string.quoted.single.bach
        end: (\\E)
        name: string.quoted.raw.bach
        captures:
          1: {name: keyword.control.quote.bach}
        patterns:
          - include: "#string-escapes"
      - begin: (\\q)
        contentName: string.quoted.double.bach
        end: (\\e)
        name: string.quoted.bach
        captures:
          1: {name: keyword.control.quote.bach}
        patterns:
          - include: "#embedded-raw"
      - begin: (\\k<)
        end: \s*(>)
        name: keyword.other.back-reference.bach
        beginCaptures:
          1: {name: keyword.other.back-reference.bach}
        endCaptures:
          1: {name: keyword.other.back-reference.bach}
        patterns:
          - include: "#variables"
          - include: "#numbers"
      - begin: (\\g<)
        end: \s*(>)
        name: keyword.other.subroutine.bach
        beginCaptures:
          1: {name: keyword.other.subroutine.bach}
        endCaptures:
          1: {name: keyword.other.subroutine.bach}
        patterns:
          - include: "#variables"
          - include: "#numbers"
      - include: "#regex-groups"
      - include: "#regex-character-set"
      - include: "#regex-character-class"
      - match: (?i)(?:(\\M)|(\\K)|(\\G)|(\\X))
        captures:
          1: {name: keyword.control.anchor.bach}
          2: {name: keyword.control.keepout.bach}
          3: {name: keyword.control.search.bach}
          4: {name: constant.character.unicode.bach}
      - match: (?<=[*+?}])(?:(\?)|(\+)|(\*))
        captures:
          1: {name: keyword.operator.modifier.lazy.bach}
          2: {name: keyword.operator.modifier.eager.bach}
          3: {name: keyword.operator.modifier.greedy.bach}
      - match: (\?)|(\+)|(\*)
        captures:
          1: {name: keyword.operator.quantifier.lazy.bach}
          2: {name: keyword.operator.quantifier.eager.bach}
          3: {name: keyword.operator.quantifier.greedy.bach}
      - match: \\.
        name: constant.character.escape.other.bach

    repository:
      regex-groups:
        patterns:
          - begin: \(([*+])
            end: \s*(\))
            name: constant.other.pcre.bach
            captures:
              0: {name: punctuation.section.expression.bach}
            patterns:
              - include: source.clojure
          - begin: (\()(\?#)
            contentName: comment.block.regexp.bach
            end: \s*(\))
            name: comment.block.regexp.bach
            captures:
              1: {name: punctuation.definition.comment.bach}
            patterns:
              - match: \\.
                name: comment.block.regexp.bach
          - begin: (\(\?=)
            end: \s*(\))
            name: meta.group.bach
            captures:
              1: {name: punctuation.definition.group.look-ahead.bach}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?<=)
            end: \s*(\))
            name: meta.group.bach
            captures:
              1: {name: punctuation.definition.group.look-behind.bach}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?!)
            end: \s*(\))
            name: meta.group.bach
            captures:
              1: {name: punctuation.definition.group.negative-look-ahead.bach}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?<!)
            end: \s*(\))
            name: meta.group.bach
            captures:
              1: {name: punctuation.definition.group.negative-look-behind.bach}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?(?:([+-]?\d+?)|(\p{upper}+(?:[+-]\p{upper}+)*)|(\p{lower}+(?:[+-]\p{lower}+)*)))\s*(:)?
            end: \s*(\))
            name: meta.group.bach
            captures:
              0: {name: punctuation.definition.group.flag.bach}
              1: {name: punctuation.definition.group.flag.bach}
              2: {name: entity.name.function.method.bach}
              3: {name: keyword.control.recursion.bach}
              4: {name: keyword.other.flag.bach}
              5: {name: punctuation.separator.key-value.bach}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?)(?={)
            end: \s*(\))
            name: meta.group.bach
            captures:
              1: {name: punctuation.definition.group.call-out.bach}
            patterns:
              - begin: (?<=\(\?)({)
                end: \s*(\})([<*>])?(?:(\[)(.*)(\]))?
                name: punctuation.definition.group.call-out.bach
                captures:
                  1: {name: punctuation.definition.group.call-out.bach}
                  2: {name: keyword.operator.range.bach}
                  3: {name: punctuation.type.bach}
                  4: {patterns: [{include: $self}]}
                  5: {name: punctuation.type.bach}
                patterns:
                  - include: $self
              - include: "#regexp-patterns"
          - begin: (\(\?>)
            end: \s*(\))
            name: meta.group.bach
            captures:
              1: {name: punctuation.definition.group.atomic.bach}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?:)
            end: \s*(\))
            name: meta.group.bach
            captures:
              1: {name: punctuation.definition.group.non-capturing.bach}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?)(?=[(|])
            end: \s*(\))
            name: meta.group.bach
            captures:
              1: {name: punctuation.definition.group.branch.bach}
            patterns:
              - include: "#regexp-patterns"
          - begin: (\(\?~)
            end: \s*(\))
            name: meta.group.bach
            captures:
              1: {name: punctuation.definition.group.absent.bach}
            patterns:
              - include: "#regexp-patterns"
          - begin: \((\?(?:&)(?:([+-]?\d+)|([_\p{L}\p{Nl}][_\\d\p{L}\p{M}\p{N}]*)|([+-]?\d*)))(:)?
            end: \s*\)
            name: meta.group.bach
            captures:
              0: {name: punctuation.definition.group.back-reference.bach}
              1: {name: punctuation.definition.group.back-reference.bach}
              2: {name: entity.name.function.method.bach}
              3: {name: variable.other.bach}
              4: {name: punctuation.separator.key-value.bach}
            patterns:
              - include: "#regexp-patterns"
          - begin: \(\?(?=<(?![!=]))
            end: \s*(\))
            name: meta.group.bach
            beginCaptures:
              0: {name: punctuation.definition.group.named.bach}
              1: {patterns: [{include: "#variables"}]}
            endCaptures:
              0: {name: punctuation.definition.group.named.bach}
            patterns:
              - begin: (?<=\(\?)(<)
                end: \s*(>)
                name: punctuation.definition.group.named.bach
                beginCaptures:
                  1: {name: punctuation.definition.group.named.bach}
                endCaptures:
                  1: {name: punctuation.definition.group.named.bach}
                patterns:
                  - include: "#variables"
                  - include: "#numbers"
              - include: "#regexp-patterns"
          - begin: \(
            end: \s*\)
            captures:
              0: {name: punctuation.definition.group.bach}
            patterns:
              - include: "#regexp-patterns"

      regex-character-class:
        patterns:
          - match: \\(?=\s*$)
            name: constant.character.escape.newline.bach
          - begin: (?i)\\p{
            end: \s*}
            name: constant.other.character-class.unicode.bach
            patterns:
              - include: "#expression-keywords"
              - include: "#variables"
              - include: "#operators"
          - begin: \\j{
            end: \s*}
            name: constant.character.entity.named.bach
            patterns:
              - include: "#regexp-patterns"
          - match: (?i)\\b(?:[01]{1,21}|{[01\s]+?})
            name: constant.character.escape.binary.bach
          - match: (?i)\\q(?:[0-3]{1,11}|{[0-3\s]+?})
            name: constant.character.escape.quaternary.bach
          - match: (?i)\\s(?:[0-5]{1,8}|{[0-5\s]+?})
            name: constant.character.escape.senary.bach
          - match: (?i)\\o(?:[0-7]{1,7}|{[0-7\s]+?})
            name: constant.character.escape.octal.bach
          - match: (?i)\\d?\d{1,7}|\\d{[\d\s]+?}
            name: constant.character.escape.decimal.bach
          - match: (?i)\\z(?:[\dabetxz]{1,6}|{[\s\dabetxz]+?})
            name: constant.character.escape.duodecimal.bach
          - match: (?i)\\x(?:\h{1,6}|{[\h\s]+?})
            name: constant.character.escape.hexadecimal.bach
          - match: (?i)\\u(?:\h{1,6}|{[\h\s]+?})
            name: constant.character.escape.unicode.bach
          - match: (?i:\\[cm]\p{alpha})|\\R
            name: constant.character.control.bach
          - match: (?i:\\p\p{alpha}{1,2})|\\O
            name: constant.other.character-class.unicode.bach
          - match: (?i)\\[ci]
            name: constant.other.character-class.xml.bach
          - match: \.|\\(w|s|d|v|n|t|l|u|h)
            name: constant.other.character-class.bach
          - match: \\(W|S|D|V|N|T|L|U|H)
            name: constant.other.character-class.negated.bach
          - match: (?i)\\n{[\w\s]+}
            name: constant.character.escape.unicode.name.bach
          - match: (?i)\\(a|n|r|t|b|f|v|e|c|l|z|p)
            name: constant.character.escape.bach
          - match: \\[\p{s}\p{p}]
            name: constant.character.escape.symbol.bach
          - match: \\\p{z}
            name: constant.character.escape.symbol.bach
          - match: \\[\p{l}\p{n}]
            name: constant.character.escape.illegal.bach
          - include: "#embedded"

      regex-character-operators:
        patterns:
          - match: \--
            name: keyword.operator.optional.bach
          - match: (?<!\\?[\\\[])-(?![-\[\]])
            name: keyword.operator.range.bach
          - match: \|\|
            name: keyword.operator.union.bach
          - match: \&&
            name: keyword.operator.intersection.bach
          - match: \^\^
            name: keyword.operator.only.bach
          - match: ~~
            name: keyword.operator.maybe.bach
          - match: \.
            name: constant.other.character-class.range.bach
          - match: \\.
            name: constant.character.escape.other.bach

      regex-character-set:
        patterns:
          - begin: (\[=)
            end: \s*(=\])
            name: constant.other.character-class.posix.bach
            captures:
              1: {name: punctuation.definition.character-class.posix.bach}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
          - begin: (\[\.)
            end: \s*(\.\])
            name: constant.other.character-class.posix.bach
            captures:
              1: {name: punctuation.definition.character-class.posix.bach}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
          - begin: (\[:)
            end: \s*(:\])
            name: constant.other.character-class.posix.bach
            captures:
              1: {name: punctuation.definition.character-class.posix.bach}
            patterns:
              - include: "#comments"
              - include: "#variables"
              - include: "#operators"
          - begin: (\[\^)
            end: \s*(\])
            name: constant.other.character-class.set.bach
            captures:
              1: {name: punctuation.definition.character-class.negated.bach}
            patterns:
              - include: "#comments"
              - include: "#regex-character-class"
              - include: "#regex-character-operators"
              - include: "#regex-character-set"
          - begin: (\[)
            end: \s*(\])
            name: constant.other.character-class.set.bach
            captures:
              1: {name: punctuation.definition.character-class.bach}
            patterns:
              - include: "#comments"
              - include: "#regex-character-class"
              - include: "#regex-character-operators"
              - include: "#regex-character-set"

  calls:
    patterns:
      - comment: |
          Method calls
          For testing only:
          x.y z.y a .b .c ::d
        match: |
          (?x)
          (?<=[!?~\p{pe}_\p{l}\p{m}\p{n}]?\.|[?!:]:|->)\b

          (?:# method calls
          (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
          ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
          ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
          ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
          )

          (?= \s+
          (?:
          (?!:)
          [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*# prefix

          (?!\b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|keyof|valof
          |len|del|to|til|thru|at|by
          |and|x?or|not
          |def|func?|fn|macro|proc|sub
          |let|var|val|const|decl
          |class|given|constr|enum
          |extend|frag|inter|struct
          |module|nspace|object|record|label
          |raw|data|schema|style|trait|alias
          |if|else|elif|eless|unless|guard
          |for|each|while|until|do|redo
          |switch|case|fail|match|when|pass
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |(?:break|continue|halt|skip|return|give|await|yield|throw|raise)s?
          |yield\b\s*\bfrom|import|export|show|hide
          |from|where|join|equals|[io]nto|order
          |take|drop|fold|scan|use|using
          |open|close
          )\b)

          [_\p{l}\p{m}\p{n}]+
          (?:[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*# adfix
          [_\p{l}\p{m}\p{n}]+)*
          [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*# suffix
          |(?:[~!?]\.?)?\p{ps}|<[|+]\s+)+
          |(?:[~!?]\.?)?\s*(?:\[<|['"\`\p{ps}&&[^\[{]])
          |(?:[~!?]\.?)?!\.?
          )\b
        captures:
          1: {name: entity.name.module.bach}
          2: {name: entity.name.namespace.bach}
          3: {name: entity.name.class.builtin.bach}
          4: {name: entity.name.function.method.bach}
      - comment: |
          Function calls
          For testing only:
          for let x int|str, y int in list arr 'json' if x % 2 < 3
        match: |
          (?x)

          (?<!\p{pe}\s*)(?<=^\s*|\p{ps}\s*|[\p{s}\p{p}]\s+|\s*
          \b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|keyof|valof
          |len|del|to|til|thru|at|by
          |and|x?or|not
          |def|func?|fn|macro|proc|sub
          |let|var|val|const|decl
          |class|given|constr|enum
          |extend|frag|inter|struct
          |module|nspace|object|record|label
          |raw|data|schema|style|trait|alias
          |if|else|elif|eless|unless|guard
          |for|each|while|until|do|redo
          |switch|case|fail|match|when|pass
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |(?:break|continue|halt|skip|return|give|await|yield|throw|raise)s?
          |yield\b\s*\bfrom|import|export|show|hide
          |from|where|join|equals|[io]nto|order
          |take|drop|fold|scan|use|using
          |open|close
          )\b
          \s*)

          (?:# function calls
          (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
          ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
          ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
          ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
          )

          (?= \s+
          (?:
          (?!:)
          [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*# prefix

          (?!
          \b(?:# don't match keywords
          in|of|as|is|new|infer|unset
          |typeof|nameof|sizeof|keyof|valof
          |len|del|to|til|thru|at|by
          |and|x?or|not
          |def|func?|fn|macro|proc|sub
          |let|var|val|const|decl
          |class|given|constr|enum
          |extend|frag|inter|struct
          |module|nspace|object|record|label
          |raw|data|schema|style|trait|alias
          |if|else|elif|eless|unless|guard
          |for|each|while|until|do|redo
          |switch|case|fail|match|when|pass
          |try|retry|throw|raise|catch|rescue|finally
          |with|ref|defer|refer|show|hide|enter|exit
          |then|begin|end|debug|check|assert
          |(?:break|continue|halt|skip|return|give|await|yield|throw|raise)s?
          |yield\b\s*\bfrom|import|export|show|hide
          |from|where|join|equals|[io]nto|order
          |take|drop|fold|scan|use|using
          |open|close
          )\b
          )

          [_\p{l}\p{m}\p{n}]+
          (?:[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*# adfix
          [_\p{l}\p{m}\p{n}]+)*
          [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*# suffix
          |(?:[~!?]\.?)?\p{ps}|<[|+]\s+)+
          |(?:[~!?]\.?)?\s*(?:\[<|['"\`\p{ps}&&[^\[{]])
          |(?:[~!?]\.?)?!\.?
          )\b
        captures:
          1: {name: support.type.primitive.bach}
          2: {name: support.type.builtin.bach}
          3: {name: entity.name.class.bach}
          4: {name: entity.name.function.bach}

  variables:
    comment: |
      For testing only
      _int int_ _int._int INT INT.INT Int Int.Int int int.int

      Four types of variables:
      - underscore variables (either surrounded by _ on one end or both)
      - constant variables: in SHOUT_SNAKE_CASE
      - class variables: in PascalCase
      - regular variables: in camelCase
    match: |
      (?x)\b(?:
      (?:# Objects and maps
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )
      (?=(?:[?!~]?\.=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)

      |
      (?<!\.\.+)(?<=[_\p{l}\p{m}\p{n}]?[!?~]?\.|[?!:]:|->)
      (?:# Properties (note all properties are by default, symbols)
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )

      |
      (?:# Regular variables
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )
      )\b
    captures:
      1: {name: variable.other.global.bach}
      2: {name: variable.other.constant.object.bach}
      3: {name: variable.other.conditional.bach}
      4: {name: variable.other.object.bach}
      5: {name: variable.other.index.bach}
      6: {name: variable.other.constant.property.bach}
      7: {name: variable.other.property.static.bach}
      8: {name: variable.other.property.bach}
      9: {name: variable.other.dollar.bach}
      10: {name: variable.other.constant.bach}
      11: {name: variable.other.class.bach}
      12: {name: variable.other.readwrite.bach}

  operators:
    patterns:
      - include: "#special-operators"
      - include: "#unary-ops"
      - include: "#binary-ops"

    repository:
      binary-ops-builtin:
        patterns:
          - comment: augmented assignment += -= *= /= etc
            match: (?<=^|['"\`\p{ps}\s])([\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]+(?<![!:~.<=>])=)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.assignment.augmented.bach
          - comment: arithmetic + - * ** *** / // /// % %% *> <*
            match: (?<=^|['"\`\p{ps}\s])((?<!<)\+(?!>|\++)|(?<!<)-(?!>|-+)|\*{1,3}|/{1,3}(?!\\)|%%?|\*+>|<\*+)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.arithmetic.bach
          - comment: increment/decrement ++ --
            match: (?<=^|['"\`\p{ps}\s])((?:[+-])+)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.successor.bach
          - comment: logical && || ^^ /\ / \ \\ etc.
            match: (?<=^|['"\`\p{ps}\s])((?:[&^]){2,}|\|\|+(?!>)|/\\|\\/|\\+)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.logical.bach
          - comment: bitwise & | ^ ~
            match: (?<=^|['"\`\p{ps}\s])([&^]|\|(?!>)|~(?![!=<>]))(?=$|['"\`\s\p{pe}])
            name: keyword.operator.bitwise.bach
          - comment: shift << >> <<< >>>>
            match: (?<=^|['"\`\p{ps}\s])(<{2,}(?![!:=+|*])|(?<![!:=+|*])>{2,})(?=$|['"\`\s\p{pe}])
            name: keyword.operator.bitwise.shift.bach
          - comment: function composition +> <+
            match: (?<=^|['"\`\p{ps}\s])(<\++|\++>)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.compose.bach
          - comment: pipeline |> <|
            match: (?<=^|['"\`\p{ps}\s])(<\|+|\|+>)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.pipeline.bach
          - comment: "class <: :> :< >: <:< >:> <:> >:< <! !> !< >! <!< >!> <!> >!<"
            match: (?<=^|['"\`\p{ps}\s])([<>][!:][<>]?|[!:][<>])(?=$|['"\`\s\p{pe}])
            name: keyword.operator.class.bach
          - comment: relational < > <= >=
            match: (?<=^|['"\`\p{ps}\s])([<>]=?)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.relational.bach
          - comment: regex =< <> </ /> <$ $> <$> <+> <*> </> <$> $
            match: (?<=^|['"\`\p{ps}\s])(<>|=<|<(?:[/*+$])+>?|(?:[/*+$])+>)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.regexp.bach
          - comment: equality == != === !==
            match: (?<=^|['"\`\p{ps}\s])([!=]=+)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.comparison.bach
          - comment: similarity operators
            match: (?<=^|['"\`\p{ps}\s])([!=~]+~|~[!=~]+|[<~>]+~[<~>]*|~[<~>]+)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.similarity.bach
          - comment: fat arrow-like => ==> <==
            match: (?<=^|['"\`\p{Ps}\s])([=>]+|[<=]+|[=>]+[<=]+)(?=$|['"\`\s\p{Pe}])
            name: keyword.operator.arrow.fat.bach
          - comment: skinny arrow-like -> <- --> <--
            match: (?<=^|['"\`\p{Ps}\s])([->]+|[<-]+|[->]+[<-]+)(?=$|['"\`\s\p{Pe}])
            name: keyword.operator.arrow.skinny.bach
          - comment: wavy arrow-like ~> <~ ~~> <~~
            match: (?<=^|['"\`\p{Ps}\s])([~>]+|[<~]+|[~>]+[<~]+)(?=$|['"\`\s\p{Pe}])
            name: keyword.operator.arrow.wavy.bach
          - comment: null-coalescing ??
            match: (?<=^|['"\`\p{ps}\s])(\?{2,})(?=$|['"\`\s\p{pe}])
            name: keyword.operator.null-coalescing.bach
          - comment: non-null coalescing !!
            match: (?<=^|['"\`\p{ps}\s])(!{2,})(?=$|['"\`\s\p{pe}])
            name: keyword.operator.coalescing.bach
          - comment: "false coalescing ?:"
            match: (?<=^|['"\`\p{ps}\s])(\?+:+)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.conditional.bach
          - comment: "true coalescing !:"
            match: (?<=^|['"\`\p{ps}\s])(!+:+)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.ternary.bach
          - comment: "infix function $:"
            match: (?<=^|['"\`\p{ps}\s])(\$+:+|\${2,})(?=$|['"\`\s\p{pe}])
            name: keyword.operator.macro.dollar.bach
          - comment: "assignment : :="
            match: (?<=^|['"\`\p{ps}\s])(:?=)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.assignment.bach
          - comment: custom bitwise (leading &|^ ~)
            match: (?<=^|['"\`\p{ps}\s])([&|^~][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]+)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.bitwise.bach
          - comment: custom arithmetic (leading + - * / %)
            match: (?<=^|['"\`\p{ps}\s])([+\-*/%][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]+)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.arithmetic.bach
          - comment: "custom accessor (leading : .)"
            match: (?<=^|['"\`\p{ps}\s])([:.][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]+)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.prototype.bach
          - comment: custom equality (leading = !)
            match: (?<=^|['"\`\p{ps}\s])([!=][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]+)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.comparison.bach
          - comment: custom comparison (leading < >)
            match: (?<=^|['"\`\p{ps}\s])([<>][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]+)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.relational.bach
          - comment: custom optional (leading ?)
            match: (?<=^|['"\`\p{ps}\s])(\?[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]+)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.private.bach
          - comment: custom mathematical (leading Unicode category Sm)
            match: (?<=^|['"\`\p{ps}\s])([\p{sm}&&[\x{80}-\x{10ffff}]][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.math.bach
          - comment: custom currency-based (leading Unicode category Sc)
            match: (?<=^|['"\`\p{ps}\s])([\p{sc}&&[^$]][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.currency.bach
          - comment: custom ASCII (leading Unicode 0x80 to 0xFF)
            match: (?<=^|['"\`\p{ps}\s])([\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[\x{80}-\x{ff}]][\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.ascii.bach
          - comment: other custom (leading anything not covered above)
            match: (?<=^|['"\`\p{ps}\s])([\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]+)(?=$|['"\`\s\p{pe}])
            name: keyword.operator.infix.bach

      binary-ops:
        match: (?<=^|['"\`\s\p{ps}])([\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]+)(?=$|['"\`\s\p{pe}])
        captures:
          0: {patterns: [{include: "#binary-ops-builtin"}]}

      unary-ops:
        patterns:
          - &adfix-operators
            comment: non-spaced-out binary operators
            match: |
              (?x)(?<=\b|^|[\p{pe}'"\`\s])
              (?:([>.]\.[.<])|(\?\.[=!]?)|(~\.[=!]?)|(!\.[=!]?)|(\.[=!]?|::=?)|(->))
              (?=\b|$|[\p{ps}'"\`\s])
            captures:
              1: {name: keyword.operator.range.bach}
              2: {name: punctuation.accessor.optional.bach}
              3: {name: punctuation.accessor.cascade.bach}
              4: {name: punctuation.accessor.call.bach}
              5: {name: punctuation.accessor.bach}
              6: {name: punctuation.accessor.module.bach}

          - &prefix-operators
            comment: prefix operators
            match: |
              (?x)
              (?:(\*)#1
              |(\+)#2
              |(\-)#3
              |(\&)#4
              |(\|)#5
              |(\^)#6
              |(\!)#7
              |(\$)#8
              |(\@)#9
              |(\~)#10
              |(\?)#11
              |(\=)#12
              |(\$)#13
              |[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]])#14
              (?=[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*
              [\p{l}\p{m}\p{n}\p{ps}_,;'"\`])
            name: keyword.operator.prefix.bach
            captures:
              1: {name: keyword.operator.module.all.bach}
              2: {name: keyword.operator.increment.bach}
              3: {name: keyword.operator.decrement.bach}
              4: {name: keyword.operator.intersection.bach}
              5: {name: keyword.operator.union.bach}
              6: {name: keyword.operator.sym-diff.bach}
              7: {name: keyword.operator.logical.bach}
              8: {name: keyword.operator.private.bach}
              9: {name: keyword.operator.decorator.bach}
              10: {name: keyword.operator.bitwise.not.bach}
              11: {name: keyword.operator.existential.bach}
              12: {name: keyword.operator.assignment.bach}
              13: {name: keyword.operator.pipeline.bach}
              14: {name: keyword.operator.prefix.bach}

          - &suffix-operators
            comment: suffix operators
            match: |
              (?x)
              (?<=[\p{l}\p{m}\p{n}\p{pe}_,;'"\`]
              [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*)
              (?:(\*)#1
              |(\+)#2
              |(\-)#3
              |(\&)#4
              |(\|)#5
              |(\^)#6
              |(\!)#7
              |(\$)#8
              |(\@)#9
              |(\~)#10
              |(\?)#11
              |(\=)#12
              |(\$)#13
              |[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]])#14
            name: keyword.operator.suffix.bach
            captures:
              1: {name: keyword.operator.module.all.bach}
              2: {name: keyword.operator.increment.bach}
              3: {name: keyword.operator.decrement.bach}
              4: {name: keyword.operator.intersection.bach}
              5: {name: keyword.operator.union.bach}
              6: {name: keyword.operator.symdiff.bach}
              7: {name: keyword.operator.assertion.bach}
              8: {name: keyword.operator.private.bach}
              9: {name: keyword.operator.decorator.bach}
              10: {name: keyword.operator.bitwise.bach}
              11: {name: keyword.operator.existential.bach}
              12: {name: keyword.operator.assignment.bach}
              13: {name: keyword.operator.pipeline.bach}
              14: {name: keyword.operator.suffix.bach}

      pipeline-operator:
        patterns:
          - applyEndPatternLast: 1
            begin: |
              (?x)\s*(?:(\++>)|(\|+>))(?=\s*(
              [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*# prefix

              (?!
              \b(?:# don't match keywords
              in|of|as|is|new|infer|unset
              |typeof|nameof|sizeof|keyof|valof
              |len|del|to|til|thru|at|by
              |and|x?or|not
              |def|func?|fn|macro|proc|sub
              |let|var|val|const|decl
              |class|given|constr|enum
              |extend|frag|inter|struct
              |module|nspace|object|record|label
              |raw|data|schema|style|trait|alias
              |if|else|elif|eless|unless|guard
              |for|each|while|until|do|redo
              |switch|case|fail|match|when|pass
              |try|retry|throw|raise|catch|rescue|finally
              |with|ref|defer|refer|show|hide|enter|exit
              |then|begin|end|debug|check|assert
              |(?:break|continue|halt|skip|return|give|await|yield|throw|raise)s?
              |yield\b\s*\bfrom|import|export|show|hide
              |from|where|join|equals|[io]nto|order
              |take|drop|fold|scan|use|using
              |open|close
              )\b
              )

              [_\p{l}\p{m}\p{n}]+
              (?:[\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*# adfix
              [_\p{l}\p{m}\p{n}]+)*
              [\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]*# suffix
              )\s*([^(]|$|;))
            end: (?=.)
            beginCaptures:
              1: {name: keyword.operator.compose.bach}
              2: {name: keyword.operator.pipeline.bach}
            patterns:
              - match: |
                  (?x)(?<=(?:\++>)|(?:\|+>))\s*
                  (?!
                  \b(?:# don't match keywords
                  in|of|as|is|new|infer|unset
                  |typeof|nameof|sizeof|keyof|valof
                  |len|del|to|til|thru|at|by
                  |and|x?or|not
                  |def|func?|fn|macro|proc|sub
                  |let|var|val|const|decl
                  |class|given|constr|enum
                  |extend|frag|inter|struct
                  |module|nspace|object|record|label
                  |raw|data|schema|style|trait|alias
                  |if|else|elif|eless|unless|guard
                  |for|each|while|until|do|redo
                  |switch|case|fail|match|when|pass
                  |try|retry|throw|raise|catch|rescue|finally
                  |with|ref|defer|refer|show|hide|enter|exit
                  |then|begin|end|debug|check|assert
                  |(?:break|continue|halt|skip|return|give|await|yield|throw|raise)s?
                  |yield\b\s*\bfrom|import|export|show|hide
                  |from|where|join|equals|[io]nto|order
                  |take|drop|fold|scan|use|using
                  |open|close
                  )\b
                  )
                  ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
                  (?!(?:[?!~]?\.=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)
                captures:
                  1: {name: entity.name.function.bach}
              - match: |
                  (?x)\s*
                  (?!
                  \b(?:# don't match keywords
                  in|of|as|is|new|infer|unset
                  |typeof|nameof|sizeof|keyof|valof
                  |len|del|to|til|thru|at|by
                  |and|x?or|not
                  |def|func?|fn|macro|proc|sub
                  |let|var|val|const|decl
                  |class|given|constr|enum
                  |extend|frag|inter|struct
                  |module|nspace|object|record|label
                  |raw|data|schema|style|trait|alias
                  |if|else|elif|eless|unless|guard
                  |for|each|while|until|do|redo
                  |switch|case|fail|match|when|pass
                  |try|retry|throw|raise|catch|rescue|finally
                  |with|ref|defer|refer|show|hide|enter|exit
                  |then|begin|end|debug|check|assert
                  |(?:break|continue|halt|skip|return|give|await|yield|throw|raise)s?
                  |yield\b\s*\bfrom|import|export|show|hide
                  |from|where|join|equals|[io]nto|order
                  |take|drop|fold|scan|use|using
                  |open|close
                  )\b
                  )
                  ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
                  (?!(?:[?!~]?\.=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)
                captures:
                  1: {name: entity.name.function.method.bach}
              - match: |
                  (?x)\s*
                  (?!
                  \b(?:# don't match keywords
                  in|of|as|is|new|infer|unset
                  |typeof|nameof|sizeof|keyof|valof
                  |len|del|to|til|thru|at|by
                  |and|x?or|not
                  |def|func?|fn|macro|proc|sub
                  |let|var|val|const|decl
                  |class|given|constr|enum
                  |extend|frag|inter|struct
                  |module|nspace|object|record|label
                  |raw|data|schema|style|trait|alias
                  |if|else|elif|eless|unless|guard
                  |for|each|while|until|do|redo
                  |switch|case|fail|match|when|pass
                  |try|retry|throw|raise|catch|rescue|finally
                  |with|ref|defer|refer|show|hide|enter|exit
                  |then|begin|end|debug|check|assert
                  |(?:break|continue|halt|skip|return|give|await|yield|throw|raise)s?
                  |yield\b\s*\bfrom|import|export|show|hide
                  |from|where|join|equals|[io]nto|order
                  |take|drop|fold|scan|use|using
                  |open|close
                  )\b
                  )
                  ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
                  ((?:[?!~]?\.=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)
                captures:
                  1: {name: variable.other.object.bach}
                  2: {patterns: [{include: "#unary-ops"}]}
              - include: "#comments"

      special-operators:
        patterns:
          - include: "#pipeline-operator"
          - begin: (?<=\s)(\?)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.conditional.bach}
            patterns:
              - begin: \s*(?=([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s*:)
                end: \s*(?=:)
                patterns:
                  - include: "#constants"
                  - include: "#variables"
              - include: $self
          - begin: (?<=\s)(\!)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            captures:
              1: {name: keyword.operator.ternary.bach}
            patterns:
              - begin: \s*(?=([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s*:)
                end: \s*(?=:)
                patterns:
                  - include: "#constants"
                  - include: "#variables"
              - include: $self
          - begin: (?<=\s)(\$)(?=\s)
            end: (?<=^|\s)(:)(?=\s|$)
            name: keyword.operator.macro.dollar.bach
            beginCaptures:
              1: {name: keyword.operator.macro.dollar.bach}
            captures:
              1: {name: keyword.operator.macro.dollar.bach}
            patterns:
              - begin: \s*(?=([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s*:)
                end: \s*(?=:)
                patterns:
                  - include: "#function-name"
                  - include: "#method-name"
              - include: $self

  constant-types:
    - include: "#numbers"
    - include: "#strings"
    - include: "#regexes"

  custom-types:
    comment: |
      For testing only
      _int int_ _int._int INT INT.INT Int Int.Int int int.int

      Four types of variables:
      - underscore variables (either surrounded by _ on one end or both)
      - constant variables: in SHOUT_SNAKE_CASE
      - class variables: in PascalCase
      - regular variables: in camelCase
    match: |
      (?x)\s*\b

      (?!
      \b(?:# don't match keywords
      in|of|as|is|new|unset
      |len|del|to|til|thru|at|by
      |and|x?or|not
      |def|func?|fn|macro|proc|sub
      |let|var|val|const|decl
      |class|given|constr|enum
      |extend|frag|inter|struct
      |module|nspace|object|record|label
      |raw|data|schema|style|trait|alias
      |if|else|elif|eless|unless|guard
      |for|each|while|until|do|redo
      |switch|case|fail|match|when|pass
      |try|retry|throw|raise|catch|rescue|finally
      |with|ref|defer|refer|show|hide|enter|exit
      |then|begin|end|debug|check|assert
      |(?:break|continue|halt|skip|return|give|await|yield|throw|raise)s?
      |yield\b\s*\bfrom|import|export|show|hide
      |from|where|join|equals|[io]nto|order
      |take|drop|fold|scan|use|using
      |open|close
      )\b
      )

      (?:
      (?:# Objects and maps
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )
      (?=(?:[?!~]?\.=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)

      |
      (?<!\.\.+)(?<=[_\p{l}\p{m}\p{n}]?[!?~]?\.|[?!:]:|->)
      (?:# Properties (note all properties are by default, symbols)
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )

      |
      (?:# Regular variables
      (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
      ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
      ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
      ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
      )
      )\b
    captures: &custom-types
      1: {name: entity.name.tag.bach}
      2: {name: entity.name.module.bach}
      3: {name: entity.name.namespace.bach}
      4: {name: entity.name.interface.bach}
      5: {name: entity.name.tag.block.bach}
      6: {name: entity.name.tag.script.bach}
      7: {name: entity.name.tag.style.bach}
      8: {name: entity.name.tag.inline.bach}
      9: {name: entity.name.label.bach}
      10: {name: entity.name.interface.bach}
      11: {name: entity.name.class.bach}
      12: {name: entity.name.type.bach}

  type-brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"

    repository:
      curly-brackets: &type-curly-brackets
        patterns:
          - begin: \s*(\{\|)
            end: \s*(\|\})
            captures:
              1: {name: punctuation.definition.mapping.bach}
            patterns:
              - include: "#types"
              - include: $self
          - begin: \s*(\{)
            end: \s*(\})
            captures:
              1: {name: punctuation.definition.dictionary.bach}
            patterns:
              - include: "#types"
              - include: $self

      round-brackets: &type-round-brackets
        patterns:
          - begin: \s*(\(\|)
            end: \s*(\|\))
            captures:
              1: {name: punctuation.definition.parameters.bach}
            patterns:
              - include: "#types"
              - include: $self
          - begin: \s*(\()
            end: \s*(\))
            captures:
              1: {name: punctuation.definition.expression.bach}
            patterns:
              - include: "#types"
              - include: $self

      square-brackets: &type-square-brackets
        patterns:
          - begin: \s*(\[<)
            end: \s*(>\])
            captures:
              1: {name: punctuation.definition.typeparameters.bach}
            patterns:
              - include: "#types"
              - include: $self
          - begin: \s*(\[\|)
            end: \s*(\|\])
            captures:
              1: {name: punctuation.definition.sequence.bach}
            patterns:
              - include: "#types"
              - include: $self
          - begin: \s*(\[)
            end: \s*(\])
            captures:
              1: {name: punctuation.definition.array.bach}
            patterns:
              - include: "#types"
              - include: $self

  type-keywords:
    patterns:
      - match: |
          (?x)\s*(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
          ((?:type|name|size|key)of|only|infer)\b\s*
        name: keyword.operator.expression.$1.bach
      - match: |
          (?x)\s*(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
          (valof)\b\s*
        name: keyword.operator.expression.valueof.bach
      - match: |
          (?x)\s*(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
          (ext|from)\b\s*
        name: storage.type.extends.bach
      - match: |
          (?x)\s*(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
          (impl|with)\b\s*
        name: storage.type.implements.bach

  type-operators:
    patterns:
      - comment: non-spaced-out binary operators
        match: |
          (?x)(?<=^|[\p{pe}_\p{l}\p{m}\p{n}'"\`])
          (?:(\?[:.])|(~[:.])|(![:.])|(::|\.)|(->))
          (?=$|[\p{ps}_\p{l}\p{m}\p{n}'"\`])
        captures:
          1: {name: punctuation.accessor.optional.bach}
          2: {name: punctuation.accessor.cascade.bach}
          3: {name: punctuation.accessor.call.bach}
          4: {name: punctuation.accessor.bach}
          5: {name: punctuation.accessor.module.bach}

      - comment: sum type +
        match: \s*(\+)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]])
        name: keyword.operator.sum.bach
      - comment: difference type -
        match: \s*(\-)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]])
        name: keyword.operator.difference.bach
      - comment: product type *
        match: \s*(\*)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]])
        name: keyword.operator.product.bach
      - comment: quotient type /
        match: \s*(\/)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]])
        name: keyword.operator.quotient.bach
      - comment: remainder type %
        match: \s*(\/)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]])
        name: keyword.operator.remainder.bach
      - comment: result/return type !
        match: \s*(\!)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]])
        name: keyword.operator.only.bach
      - comment: some or maybe type ?
        match: \s*(\?)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]])
        name: keyword.operator.maybe.bach
      - comment: intersection type &
        match: \s*(\&)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]])
        name: keyword.operator.intersection.bach
      - comment: union type |
        match: \s*(\|)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]])
        name: keyword.operator.union.bach
      - comment: symmetric difference type ^
        match: \s*(\^)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]])
        name: keyword.operator.sym-diff.bach
      - comment: complement type ~
        match: \s*(\~)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]])
        name: keyword.operator.negation.bach
      - comment: class type < >
        match: \s*([<>])(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]])
        name: keyword.operator.class.bach
      - comment: "type operator :"
        match: \s*(:)(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]])
        name: punctuation.definition.annotation.bach

  type-annotation:
    applyEndPatternLast: 1
    begin: (:)(?=\s|$)
    end: (?=\O)|$
    beginCaptures:
      1: {name: punctuation.definition.annotation.bach}
    patterns:
      - include: "#types"

  types:
    patterns:
      - include: "#type-keywords"
      - include: "#modifier-keywords"
      - include: "#constant-types"
      - include: "#support-types"
      - include: "#custom-types"
      - include: "#type-operators"
      - include: "#type-brackets"

      - match: (?<=\))\s*(=>)\s*
        name: storage.type.function.arrow.bach

      - match: (?!^)\s*\b((?>WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|strings|SIMD.Uint8x16|SIMD.Uint32x4|SIMD.Uint16x8|SIMD.Int8x16|SIMD.Int32x4|SIMD.Int16x8|SIMD.Float64x2|SIMD.Float32x4|SIMD.Bool8x16|SIMD.Bool64x2|SIMD.Bool32x4|SIMD.Bool16x8|SIMD|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|numbers|NaN|Math|Map|JSON|Intl.NumberFormat|Intl.DateTimeFormat|Intl.Collator|Intl|InternalError|Int8Array|Int32Array|Int16Array|Infinity|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array))\b
        captures:
          1: {name: support.type.builtin.class.bach}
      - match: \s*\b((SIMD)((\.)(Uint8x16|Uint32x4|Uint16x8|Int8x16|Int32x4|Int16x8|Float64x2|Float32x4|Bool8x16|Bool64x2|Bool32x4|Bool16x8))?)\b
        captures:
          2: {name: support.type.builtin.class.bach}
          4: {name: keyword.operator.accessor.bach}
          5: {name: support.type.builtin.class.bach}
      - match: \s*\b((Intl)((\.)(NumberFormat|DateTimeFormat|Collator))?)\b
        captures:
          2: {name: support.type.builtin.class.bach}
          4: {name: keyword.operator.accessor.bach}
          5: {name: support.type.builtin.class.bach}

  modifier-keywords:
    comment: Modifier keywords only activate when they are next to a declaration.
    match: |
      (?x)
      (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
      (# Generator modifiers
      (?:throw|raise|yield|return|give|await|break|skip|halt|continue)s|
      prev|next
      )|
      (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(?:
      (# Access modifiers
      pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager
      |greedy|early|late|unique|handle|over|abs|vol|stat|dyn|final
      |trans|part
      )|
      (# Function or method modifiers
      [gs]et|[dr]ef|rec|gen|(?:im)?pure|local|global|native
      |(?:un)?(?:sign|safe|check|lock|fixed|size)
      )|
      (# Property modifiers
      (?:pre|in|post|suf|a[df])fix|
      (?:u|bi|ter|)nary|
      (?:0|[1-9]\d*)ary
      )
      )\b(?=\b
      (?:\s*\b
      (?:# Access modifiers
      pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager
      |greedy|early|late|unique|handle|over|abs|vol|stat|dyn|final
      |[gs]et|[dr]ef|trans|part|rec|gen|(?:im)?pure|local|global|native
      |(?:un)?(?:sign|safe|check|lock|fixed|size)
      |# Function or method modifiers
      (?:pre|in|post|suf|a[df])fix|
      (?:u|bi|ter|)nary|
      (?:0|[1-9]\d*)ary
      )
      \b\s*)*
      \s*\b
      (?:
      def|func?|fn|macro|proc|sub
      |let|var|val|const|decl
      |class|given|constr|enum
      |extend|frag|inter|struct
      |module|nspace|object|record|label
      |raw|data|schema|style|trait|alias
      )\b
      )
    captures:
      1: {name: keyword.modifier.bach}
      2: {name: storage.modifier.bach}
      3: {name: storage.type.accessor.bach}
      4: {name: storage.type.property.bach}

  support:
    patterns:
      - include: "#support-constants"
      - include: "#support-types"
      - include: "#support-functions"

  clause-keywords:
    comment: clause keywords
    match: |
      (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(?:
      (def|func?|fn|macro|proc|sub)# function
      |(let|va[rl]|const)# variable
      |(class)# class
      |(given|constr)# constraint
      |(enum)# enumeration
      |(extend)# extension
      |(frag)# fragment
      |(inter|struct)# interface
      |(module)# module
      |(nspace)# function
      |(object|record)# object
      |(raw)# markup
      |(data|schema)# indented GraphQL
      |(style)# inline CSS
      |(trait)# trait
      |(alias)# type alias
      |(decl)# declaration
      )\b
    captures:
      1: {name: storage.type.function.bach}
      2: {name: storage.type.bach}
      3: {name: storage.type.class.bach}
      4: {name: storage.type.constraint.bach}
      5: {name: storage.type.enum.bach}
      6: {name: storage.type.extension.bach}
      7: {name: storage.type.fragment.bach}
      8: {name: storage.type.interface.bach}
      9: {name: storage.type.module.bach}
      10: {name: storage.type.namespace.bach}
      11: {name: storage.type.object.bach}
      12: {name: storage.type.raw.bach}
      13: {name: storage.type.schema.bach}
      14: {name: storage.type.style.bach}
      15: {name: storage.type.trait.bach}
      16: {name: keyword.other.typedef.bach}
      17: {name: keyword.other.declare.bach}

  general-keywords:
    comment: general keywords
    match: |
      (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(?:
      (if|else|elif|eless|unless|guard)#1
      |(for|each|while|until)#2
      |(switch|case|fail)#3
      |(match|when|pass)#4
      |(try|retry|throw|raise|catch|rescue|finally)#5
      |(with)#6
      |(ref|[dr]efer|show|hide|enter|exit)#7
      |(then)#8
      |(debug|check|assert)#9
      |(break|continue|halt|skip|return|give|label|await|yield|throw|raise|yield\b\s+\bfrom)# 10
      |((?:im|ex)port|show|hide)# 11
      |(para|serie)#12
      |(do|redo)#13
      |(begin|end)#14
      )\b
    captures:
      1: {name: keyword.control.conditional.bach}
      2: {name: keyword.control.loop.bach}
      3: {name: keyword.control.switch.bach}
      4: {name: keyword.control.match.bach}
      5: {name: keyword.control.error.bach}
      6: {name: keyword.control.with.bach}
      7: {name: keyword.control.bach}
      8: {name: keyword.control.then.bach}
      9: {name: keyword.other.$10.bach}
      10: {name: keyword.control.flow.bach}
      11: {name: keyword.control.module.bach}
      12: {name: keyword.control.parallel.bach}
      13: {name: keyword.control.do.bach}
      14: {name: keyword.control.$14.bach}

  expression-keywords:
    comment: expression keywords
    match: |
      (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(?:
      (in)|(of)|(as)|(is)|(new)|(infer)
      |(typeof|nameof|sizeof|keyof)
      |(valof)|(len)|(del)|(to|til|thru|at|by)|(unset)
      |(and|x?or|not)
      )\b
    captures:
      1: {name: keyword.operator.expression.in.bach}
      2: {name: keyword.operator.expression.of.bach}
      3: {name: keyword.operator.expression.as.bach}
      4: {name: keyword.operator.expression.is.bach}
      5: {name: keyword.operator.expression.new.bach}
      6: {name: keyword.operator.expression.infer.bach}
      7: {name: keyword.operator.expression.$7.bach}
      8: {name: keyword.operator.expression.valueof.bach}
      9: {name: keyword.operator.expression.length.bach}
      10: {name: keyword.operator.expression.delete.bach}
      11: {name: keyword.operator.expression.range.bach}
      12: {name: keyword.operator.expression.void.bach}
      13: {name: keyword.operator.expression.logical.bach}

  keywords:
    patterns:
      - include: "#query-expression"
      - include: "#module-expression"
      - include: "#control-expression"
      - include: "#modifier-keywords"
      - include: "#clause-keywords"
      - include: "#expression-keywords"
      - include: "#general-keywords"

    repository:
      custom-types:
        match: |
          (?x)\s*\b

          (?:
          (?:# Objects and maps
          (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
          ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
          ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
          ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
          )
          (?=(?:[?!~]?\.=?)?\[(?!<)|(?![>.]\.[.<]?)[?!~]?\.=?|[?!:]:|->)

          |
          (?<!\.\.+)(?<=[_\p{l}\p{m}\p{n}]?[!?~]?\.|[?!:]:|->)
          (?:# Properties (note all properties are by default, symbols)
          (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
          ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
          ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
          ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
          )

          |
          (?:# Regular variables
          (_+[\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*(?!_+)|[\p{l}\p{nl}][\p{l}\p{m}\p{n}]*_+)|
          ([\p{lu}\p{lt}\p{lo}\p{nl}][_\p{lu}\p{lt}\p{lo}\p{nl}\p{n}\p{m}]*)|
          ((?:[_\p{lu}\p{lt}\p{lo}\p{nl}]+[_\p{ll}\p{m}\p{n}]*)+)|
          ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
          )
          )\b
        captures: *custom-types

      control-expression:
        applyEndPatternLast: 1
        begin: (?<!\.|::)\s*\b(halt|skip|break|continue|goto|label)\b
        end: (?=\O)|$
        beginCaptures:
          1: {name: keyword.control.flow.bach}
        patterns:
          - match: \s*([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s*
            captures:
              1: {name: constant.other.label.bach}

      module-expression:
        applyEndPatternLast: 1
        begin: |
          (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
          (import|export|open|close)\b\s*
        end: (?=\O)|$
        beginCaptures:
          1: {name: keyword.control.module.bach}
        patterns:
          - include: "#modifier-keywords"
          - include: "#typed-keywords"
          - match: |
              (?x)\s*(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (from|to|as|all|any|show|hide|to|and|x?or|not)\b\s*
            name: keyword.control.module.bach
          - match: \s*\*
            name: keyword.operator.module.all.bach
          - include: "#module-string"
          - include: "#support-types"
          - include: "#custom-types"
          - include: "#types"
          - include: "#operator"
          - include: "#operators"
          - include: "#punctuation"
        repository:
          module-string:
            patterns:
              - comment: single quoted raw string
                begin: \s*('{3,})
                contentName: string.quoted.template.bach
                end: \s*((\1)(?!\1))
                captures:
                  1: {name: punctuation.definition.string.bach}
                patterns:
                  - include: "#embedded-raw"
              - comment: simple single quoted raw string
                begin: \s*(')
                contentName: string.quoted.template.bach
                end: \s*((\1)(?!\1))
                captures:
                  1: {name: punctuation.definition.string.bach}
                patterns:
                  - match: "''"
                    name: constant.character.escape.bach
                  - include: "#embedded-raw"
              - comment: double quoted standard string
                begin: \s*("{3,}|")
                contentName: string.quoted.module.bach
                end: \s*((\1)(?!\1))
                captures:
                  1: {name: punctuation.definition.string.bach}
                patterns:
                  - include: "#string-escapes"

      query-expression:
        patterns:
          - begin: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (from)\b\s*
            end: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (in|of)\b\s*
            captures:
              1: {name: keyword.query.bach}
            patterns:
              - include: $self
          - include: "#where-clause"
          - include: "#join-clause"
          - include: "#join-keywords"
          - include: "#group-clause"
          - include: "#select-clause"
          - include: "#order-clause"
          - include: "#fold-clause"
          - include: "#take-clause"
        repository:
          fold-clause:
            match: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              ((\b(fold|scan)\b)\s*(\b(left|right)\b)?\s*(\b(by|while|until|with)\b)?)\b\s*
            name: keyword.query.bach
          group-clause:
            begin: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (group)\b\s*
            end: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (by)\b\s*
            captures:
              1: {name: keyword.query.bach}
            patterns:
              - include: $self
          join-clause:
            begin: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (join)\b\s*
            end: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (in|of)\b\s*
            captures:
              1: {name: keyword.query.bach}
            patterns:
              - include: $self
          join-keywords:
            match: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (equals?|[io]nto)\b\s*
            name: keyword.query.bach
          order-clause:
            match: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              ((\b(order)\b)\s*(\b((a|de)sc)\b)?\s*(\b(by)\b)?)\b\s*
            name: keyword.query.bach
          select-clause:
            match: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (select)\b\s*
            name: keyword.query.bach
          take-clause:
            match: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              ((\b(take|drop)\b)\s*(\b(left|right|init|head|tail|last)\b)?\s*(\b(by|while|until|with)\b)?)\b\s*
            name: keyword.query.bach
          where-clause:
            match: |
              (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b
              (where)\b\s*
            name: keyword.query.bach

  parameter-brackets:
    begin: \s*(\()
    end: \s*(\))
    captures:
      1: {name: punctuation.definition.parameters.bach}
    patterns: &function-params
      - include: "#clauses"
      - include: "#keywords"
      - match: (?i)[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*
        name: variable.parameter.bach
      - match: (?i)\?[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*\b
        name: variable.parameter.optional.bach
      - match: (?i)\*[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*\b
        name: variable.parameter.spread.bach
      - match: (?i)\&[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*\b
        name: variable.parameter.name.bach
      - match: (?i)\%[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*\b
        name: variable.parameter.reference.bach
      - match: (?i)\$[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*\b
        name: variable.parameter.other.bach
      - include: "$self"

  block-entities:
    repository:
      type-square-brackets: *type-square-brackets
      type-round-brackets: *type-round-brackets
      type-curly-brackets: *type-curly-brackets

    patterns:
      - include: "#type-square-brackets"
      - include: "#curly-brackets"
      - include: "#parameter-brackets"
      - include: "#round-brackets"
      - *adfix-operators
      - match: \s*\b((ext)|(impl)|(only))\b\s*
        captures:
          1: {name: meta.class.extends.bach}
          2: {name: storage.type.extends.bach}
          3: {name: storage.type.implements.bach}
          4: {name: keyword.operator.expression.only.bach}
      - applyEndPatternLast: 1
        begin: \s*(:)(?:(?=::)|(?![\p{s}\p{po}\p{pd}\p{pi}\p{pf}\p{pc}&&[^_,;'"\`\#]]))
        end: (?=\O)|$
        beginCaptures:
          1: {name: punctuation.definition.annotation.bach}
        patterns:
          - include: "#types"
      - begin: \s*({)
        end: \s*(})
        beginCaptures:
          1: {name: punctuation.section.class.begin.bach}
        endCaptures:
          1: {name: punctuation.section.class.end.bach}
        patterns:
          - include: "#typed-method"
          - include: $self
      - match: \s*(\.)
        captures:
          1: {name: keyword.operator.accessor.bach}

  definitions:
    patterns:
      - include: "#function"
      - include: "#raw"
      - include: "#schema"
      - include: "#style"
      - include: "#class"
      - include: "#enum"
      - include: "#interface"
      - include: "#trait"
      - include: "#fragment"
      - include: "#module"
      - include: "#namespace"
      - include: "#object"
      - include: "#constraint"
      - include: "#extension"

    repository:
      class:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(class)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.class.bach}
        patterns:
          - match: \s*\b([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
            captures:
              1: {name: entity.name.class.bach}
          - include: "#block-entities"
      constraint:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(given|constr)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.constraint.bach}
        patterns:
          - match: \s*\b([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
            captures:
              1: {name: entity.name.constraint.bach}
          - include: "#block-entities"
      enum:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(enum)\s+
        end: $|(?=.)
        name: meta.enum.declaration.bach
        beginCaptures:
          1: {name: storage.type.enum.bach}
          2: {name: entity.name.enum.bach}
        patterns:
          - match: \s*\b([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
            captures:
              1: {name: entity.name.enum.bach}
          - include: "#block-entities"
      extension:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(extend|extn)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.extension.bach}
        patterns:
          - match: \s*\b([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
            captures:
              1: {name: entity.name.extension.bach}
          - include: "#block-entities"
      fragment:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(frag|struct)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.fragment.bach}
        patterns:
          - match: \s*\b([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
            captures:
              1: {name: entity.name.fragment.bach}
          - include: "#block-entities"
      function:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(def|func?|fn|macro|proc|sub)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.function.bach}
        patterns:
          - match: \s*\b([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
            captures:
              1: {name: entity.name.function.bach}
          - include: "#block-entities"
      interface:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(inter|schema)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.interface.bach}
        patterns:
          - match: \s*\b([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
            captures:
              1: {name: entity.name.interface.bach}
          - include: "#block-entities"
      module:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(module)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.module.bach}
        patterns:
          - match: \s*\b([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
            captures:
              1: {name: entity.name.module.bach}
          - include: "#block-entities"
      namespace:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(nspace)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.namespace.bach}
        patterns:
          - match: \s*\b([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
            captures:
              1: {name: entity.name.namespace.bach}
          - include: "#block-entities"
      object:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(object|record)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.object.bach}
        patterns:
          - match: \s*\b([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
            captures:
              1: {name: entity.name.object.bach}
          - include: "#block-entities"
      raw:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(raw)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.raw.bach}
        patterns:
          - match: \s*\b([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
            name: entity.name.raw.bach
          - include: "#block-entities"
      schema:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(data|query)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.schema.bach}
        patterns:
          - match: \s*\b([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
            name: entity.name.schema.bach
          - include: "#block-entities"
      style:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(style)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.style.bach}
        patterns:
          - match: \s*\b([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
            name: entity.name.style.bach
          - include: "#block-entities"
      trait:
        applyEndPatternLast: 1
        begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(trait)\s+
        end: $|(?=.)
        beginCaptures:
          1: {name: storage.type.trait.bach}
        patterns:
          - match: \s*\b([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
            captures:
              1: {name: entity.name.trait.bach}
          - include: "#block-entities"

  clauses:
    patterns:
      - include: "#for-clause"
      - include: "#if-clause"
      - include: "#switch-clause"
      - include: "#match-clause"
      - include: "#catch-clause"
      - include: "#with-clause"
      - include: "#concur-clause"
      - include: "#do-clause"
      - include: "#when-clause"
      - include: "#case-clause"
      - include: "#type-clause"
      - include: "#new-clause"
      - include: "#method-clause"
      - include: "#function-clause"

    repository:
      function-params:
        patterns: *function-params

      pattern-brackets:
        begin: \s*(\()
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.parameters.bach}
        patterns:
          - include: "#function-params"
          - include: $self

      method-clause:
        patterns:
          - comment: |
              Simple arrow method assignment
              x = x =>
            match: |
              (?x)(?<!\.\.+)(?<=[_\p{l}\p{m}\p{n}]?[!?~]?\.|[?!:]:|->)
              ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (:?=)\s+
              ([?*&%$]?[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (=>)(?=$|['"\`\s\p{pe}])
            captures:
              1: {name: entity.name.function.method.bach}
              2: {name: keyword.operator.assignment.bach}
              3: {patterns: [{include: "#function-params"}]}
              4: {name: storage.type.function.arrow.bach}
          - comment: |
              Method def before function keyword
              x = def()
            match: |
              (?x)(?<!\.\.+)(?<=[_\p{l}\p{m}\p{n}]?[!?~]?\.|[?!:]:|->)
              ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (:?=)\s+
              (?=\b
              (?:\s*\b
              (?:# Access modifiers
              pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager
              |greedy|early|late|unique|handle|over|abs|vol|stat|dyn|final
              |[gs]et|[dr]ef|trans|part|rec|gen|(?:im)?pure|local|global|native
              |(?:un)?(?:sign|safe|check|lock|fixed|size)
              |# Function or method modifiers
              (?:pre|in|post|suf|a[df])fix|
              (?:u|bi|ter|)nary|
              (?:0|[1-9]\d*)ary
              )
              \b\s*)*
              \s*\b
              (?:
              def|func?|fn|macro|proc|sub
              )\b
              )
            captures:
              1: {name: entity.name.function.method.bach}
              2: {name: keyword.operator.assignment.bach}
          - comment: |
              Method def before arrow function
              x = async pub (): void =>
            match: |
              (?x)(?<!\.\.+)(?<=[_\p{l}\p{m}\p{n}]?[!?~]?\.|[?!:]:|->)
              ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (:?=)\s+
              ((?:(?:
              pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager
              |greedy|early|late|unique|handle|over|abs|vol|stat|dyn|final
              |[gs]et|[dr]ef|trans|part|rec|gen|(?:im)?pure|local|global|native
              |(?:un)?(?:sign|safe|check|lock|fixed|size)
              |(?:pre|in|post|suf|a[df])fix
              |(?:u|bi|ter|)nary
              |(?:0|[1-9]\d*)ary
              )\s*\b)*)\s*
              ((?:\(.*?\))*)\s*
              (?:\s*(:)\s*(.*))?\s*
              (=>)(?=$|['"\`\s\p{pe}])
            captures:
              1: {name: entity.name.function.method.bach}
              2: {name: keyword.operator.assignment.bach}
              3: {name: storage.modifier.bach}
              4: {patterns: [{include: "#pattern-brackets"}]}
              5: {name: punctuation.definition.annotation.bach}
              6: {patterns: [{include: "#types"}]}
              7: {name: storage.type.function.arrow.bach}

      function-clause:
        patterns:
          - comment: |
              Simple arrow function assignment
              x = x =>
            match: |
              (?x)\s*
              ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\+
              (:?=)\+
              ([?*&%$]?[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\+
              (=>)(?=$|['"\`\s\p{pe}])
            captures:
              1: {name: entity.name.function.bach}
              2: {name: keyword.operator.assignment.bach}
              3: {patterns: [{include: "#function-params"}]}
              4: {name: storage.type.function.arrow.bach}
          - comment: |
              Simple arrow function
              x =>
            match: |
              (?x)
              ([?*&%$]?[_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (=>)(?=$|['"\`\s\p{pe}])
            captures:
              1: {patterns: [{include: "#function-params"}]}
              2: {name: storage.type.function.arrow.bach}
          - comment: |
              Function def before function keyword
              x = def()
            match: |
              (?x)\s*
              ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (:?=)\s+
              (?=\b
              (?:\s*\b
              (?:# Access modifiers
              pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager
              |greedy|early|late|unique|handle|over|abs|vol|stat|dyn|final
              |[gs]et|[dr]ef|trans|part|rec|gen|(?:im)?pure|local|global|native
              |(?:un)?(?:sign|safe|check|lock|fixed|size)
              |# Function or method modifiers
              (?:pre|in|post|suf|a[df])fix|
              (?:u|bi|ter|)nary|
              (?:0|[1-9]\d*)ary
              )
              \b\s*)*
              \s*\b
              (?:
              def|func?|fn|macro|proc|sub
              )\b
              )
            captures:
              1: {name: entity.name.function.bach}
              2: {name: keyword.operator.assignment.bach}
          - comment: |
              Function def before arrow function
              x = async pub (): void =>
            match: |
              (?x)\s*
              ([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)\s+
              (:?=)\s+
              ((?:(?:
              pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager
              |greedy|early|late|unique|handle|over|abs|vol|stat|dyn|final
              |[gs]et|[dr]ef|trans|part|rec|gen|(?:im)?pure|local|global|native
              |(?:un)?(?:sign|safe|check|lock|fixed|size)
              |(?:pre|in|post|suf|a[df])fix
              |(?:u|bi|ter|)nary
              |(?:0|[1-9]\d*)ary
              )\s*\b)*)\s*
              ((?:\(.*?\))*)\s*
              (?:\s*(:)\s*(.*))?\s*
              (=>)(?=$|['"\`\s\p{pe}])
            captures:
              1: {name: entity.name.function.bach}
              2: {name: keyword.operator.assignment.bach}
              3: {name: storage.modifier.bach}
              4: {patterns: [{include: "#pattern-brackets"}]}
              5: {name: punctuation.definition.annotation.bach}
              6: {patterns: [{include: "#types"}]}
              7: {name: storage.type.function.arrow.bach}
          - comment: |
              Arrow function with modifiers
              async pub (): void =>
            match: |
              (?x)
              ((?:(?:
              pub|prot|pvt|priv|read|a?sync|inline|fixed|lazy|eager
              |greedy|early|late|unique|handle|over|abs|vol|stat|dyn|final
              |[gs]et|[dr]ef|trans|part|rec|gen|(?:im)?pure|local|global|native
              |(?:un)?(?:sign|safe|check|lock|fixed|size)
              |(?:pre|in|post|suf|a[df])fix
              |(?:u|bi|ter|)nary
              |(?:0|[1-9]\d*)ary
              )\s*\b)*)\s+
              ((?:\(.*?\))*)\s*
              (?:\s*(:)\s*(.*))?\s+
              (=>)(?=$|['"\`\s\p{pe}])
            captures:
              1: {name: storage.modifier.bach}
              2: {patterns: [{include: "#pattern-brackets"}]}
              3: {name: punctuation.definition.annotation.bach}
              4: {patterns: [{include: "#types"}]}
              5: {name: storage.type.function.arrow.bach}

      new-clause:
        patterns:
          - applyEndPatternLast: 1
            begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(new)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.operator.expression.$1.bach}
            patterns:
              - match: \s*([_\p{l}\p{nl}][_\p{l}\p{m}\p{n}]*)
                name: entity.name.instance.bach
              - include: "#block-entities"

      type-clause:
        patterns:
          - applyEndPatternLast: 1
            begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(as|is)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.operator.expression.$1.bach}
            patterns:
              - include: "#types"
          - applyEndPatternLast: 1
            begin: (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(alias)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.other.typedef.bach}
            patterns:
              - match: \s*(:?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.bach}
              - include: "#types"
          - applyEndPatternLast: 1
            begin: (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(decl)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.other.declare.bach}
            patterns:
              - match: \s*(:?=)\s*
                captures:
                  1: {name: keyword.operator.assignment.bach}
              - include: "#types"
          - applyEndPatternLast: 1
            begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b((?:throw|raise|yield|return|give|await|break|skip|halt|continue)s)\b
            end: (?=\O)|$
            beginCaptures:
              1: {name: keyword.modifier.bach}
            patterns:
              - include: "#types"

      case-clause:
        patterns:
          - begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(case|fail)\b
            end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
            endCaptures:
              0: {name: punctuation.separator.colon.bach}
            beginCaptures:
              1: {name: keyword.control.switch.bach}
            patterns:
              - include: "#clause-content"

      catch-clause:
        patterns:
          - begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(try|retry|catch|rescue|finally)\b
            end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
            endCaptures:
              0: {name: punctuation.separator.colon.bach}
            name: meta.catch.bach
            beginCaptures:
              1: {name: keyword.control.error.bach}
            patterns:
              - begin: \s*(\()
                end: \s*(\))
                captures:
                  1: {name: meta.brace.round.bach}
                patterns:
                  - match: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(as)\b
                    name: keyword.control.error.bach
                  - include: "#clause-content"
              - include: "#curly-brackets"
              - match: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(as)\b
                name: keyword.control.error.bach
              - include: "#clause-content"

      concur-clause:
        patterns:
          - begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(para|serie)\b
            end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
            endCaptures:
              0: {name: punctuation.separator.colon.bach}
            name: meta.parallel.bach
            beginCaptures:
              1: {name: keyword.control.parallel.bach}
            patterns:
              - begin: \s*(\()
                end: \s*(\))
                beginCaptures:
                  1: {name: meta.brace.round.bach}
                patterns:
                  - match: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(as)\b
                    name: keyword.control.parallel.bach
                  - include: "#clause-content"
              - include: "#curly-brackets"
              - match: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(as)\b
                name: keyword.control.parallel.bach
              - include: "#clause-content"

      do-clause:
        patterns:
          - begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(do|redo)\b
            end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
            endCaptures:
              0: {name: punctuation.separator.colon.bach}
            name: meta.do.bach
            beginCaptures:
              1: {name: keyword.control.do.bach}
            patterns:
              - include: "#round-brackets"
              - include: "#curly-brackets"
              - include: "#clause-content"

      for-clause:
        patterns:
          - begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(for|each|while|until)\b
            end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
            endCaptures:
              0: {name: punctuation.separator.colon.bach}
            name: meta.for.bach
            beginCaptures:
              1: {name: keyword.control.loop.bach}
            patterns:
              - match: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(in|of|to|til|thru|at|by)\b
                name: keyword.control.loop.bach
              - begin: \s*(\()
                end: \s*(\))
                captures:
                  1: {name: meta.brace.round.bach}
                patterns:
                  - match: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(in|of|to|til|thru|at|by)\b
                    name: keyword.control.loop.bach
                  - include: "#clause-content"
              - include: "#curly-brackets"
              - include: "#clause-content"

      if-clause:
        patterns:
          - begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(if|elif|else|unless|eless|guard)\b
            end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
            endCaptures:
              0: {name: punctuation.separator.colon.bach}
            name: meta.if.bach
            beginCaptures:
              1: {name: keyword.control.conditional.bach}
            patterns:
              - include: "#curly-brackets"
              - include: "#round-brackets"
              - include: "#clause-content"

      match-clause:
        patterns:
          - begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(match)\b
            end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
            endCaptures:
              0: {name: punctuation.separator.colon.bach}
            name: meta.match.bach
            beginCaptures:
              1: {name: keyword.control.match.bach}
            patterns:
              - include: "#clause-content"

      switch-clause:
        patterns:
          - begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(switch)\b
            end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
            endCaptures:
              0: {name: punctuation.separator.colon.bach}
            name: meta.switch.bach
            beginCaptures:
              1: {name: keyword.control.switch.bach}
            patterns:
              - include: "#round-brackets"
              - begin: \s*({)
                end: \s*(?=})
                beginCaptures:
                  1: {name: meta.brace.curly.switchStart.bach}
                patterns:
                  - include: "#case-clause"
                  - include: "#clause-content"
              - include: "#clause-content"

      when-clause:
        patterns:
          - begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(when)\b
            end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
            endCaptures:
              0: {name: punctuation.separator.colon.bach}
            beginCaptures:
              1: {name: keyword.control.match.bach}
            patterns:
              - applyEndPatternLast: 1
                begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(as|is)\b
                end: (?=\O)|$
                beginCaptures:
                  1: {name: keyword.control.match.bach}
                patterns:
                  - include: "#types"
              - applyEndPatternLast: 1
                begin: |
                  (?x)(?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(
                    (?:throw|raise|yield|return|give|await|break|skip|halt|continue)s
                  )\b
                end: (?=\O)|$
                beginCaptures:
                  1: {name: keyword.control.match.bach}
                patterns:
                  - include: "#types"
              - begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(if|elif|eless|unless|guard|where)\b
                end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
                endCaptures:
                  0: {name: punctuation.separator.colon.bach}
                beginCaptures:
                  1: {name: keyword.control.match.bach}
                patterns:
                  - include: "#clause-content"
              - include: "#type-operators"
              - include: "#clause-content"

      with-clause:
        patterns:
          - begin: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(with)\b
            end: (?<=^|\s*)(:)(?=\s|$)|(?=[\p{pe};]|(?<=\s)(?:->|\b(?:begin|then))|$)
            endCaptures:
              0: {name: punctuation.separator.colon.bach}
            name: meta.with.bach
            beginCaptures:
              1: {name: keyword.control.with.bach}
            patterns:
              - include: "#curly-brackets"
              - begin: \s*
                end: \s*(?=[{,])
                patterns:
                  - match: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(as)\b
                    name: keyword.control.with.bach
                  - include: "#clause-content"
              - begin: \s*(\()
                end: \s*(\))
                captures:
                  1: {name: meta.brace.round.bach}
                patterns:
                  - match: (?<![!?~]\.=|(?<!\.)\.=|[!?~]\.|(?<!\.)\.|[?!:]:|->)\b(as)\b
                    name: keyword.control.with.bach
                  - include: "#clause-content"
              - include: "#clause-content"

  punctuation:
    patterns:
      - include: "#line-continuation"
      - include: "#comma"
      - include: "#right-arrow"
      - include: "#fat-arrow"
      - include: "#semicolon"
      - include: "#double-semi"

    repository:
      line-continuation:
        match: (\\)\s*(?=#|$)
        captures:
          1: {name: punctuation.separator.continuation.line.bach}
      comma:
        match: \s*(,)
        captures:
          1: {name: punctuation.separator.comma.bach}
      right-arrow:
        match: (?:^|['"\`\p{ps}\s]*)(->)(?:$|['"\`\s\p{pe}])
        captures:
          1: {name: punctuation.definition.arrow.bach}
      fat-arrow:
        match: (?:^|['"\`\p{ps}\s]*)(=>)(?:$|['"\`\s\p{pe}])
        captures:
          1: {name: storage.type.function.arrow.bach}
      double-semi:
        match: \s*(;;)
        captures:
          1: {name: punctuation.terminator.statement.bach}
      semicolon:
        match: \s*(;)(?!;)
        captures:
          1: {name: punctuation.terminator.expression.bach}

  brackets:
    patterns:
      - include: "#curly-brackets"
      - include: "#square-brackets"
      - include: "#round-brackets"

  curly-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.mapping.bach
          - match: (?<=\b|^|[\p{pe}'"\`\s])(:)(?=\b|$|[\p{ps}'"\`\s])
            captures:
              1: {name: punctuation.separator.key-value.bach}

    patterns:
      - begin: \s*(\{\|)
        end: \s*(\|\})
        captures:
          1: {name: punctuation.definition.mapping.bach}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self
      - begin: \s*(\{)
        end: \s*(\})
        captures:
          1: {name: punctuation.definition.dictionary.bach}
        patterns:
          - include: "#labels"
          - include: "#punctuation"
          - include: $self

  round-brackets:
    repository:
      punctuation:
        patterns:
          - match: ","
            name: punctuation.separator.arguments.bach

    patterns:
      - begin: \s*(\(\|)
        end: \s*(\|\))
        captures:
          1: {name: punctuation.definition.parameters.bach}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: \s*(\()
        end: \s*(\))
        captures:
          1: {name: punctuation.definition.expression.bach}
        patterns:
          - include: "#punctuation"
          - include: $self

  square-brackets:
    repository:
      punctuation:
        patterns:
          - match: (?<=\b|^|[\p{pe}'"\`\s])(:)(?=\b|$|[\p{ps}'"\`\s])
            captures:
              1: {name: punctuation.separator.slice.bach}
          - match: ","
            name: punctuation.separator.sequence.bach

    patterns:
      - begin: \s*(\[<)
        end: \s*(>\])
        captures:
          1: {name: punctuation.definition.typeparameters.bach}
        patterns:
          - include: "#types"
          - include: $self
      - begin: \s*(\[\|)
        end: \s*(\|\])
        captures:
          1: {name: punctuation.definition.sequence.bach}
        patterns:
          - include: "#punctuation"
          - include: $self
      - begin: \s*(\[)
        end: \s*(\])
        captures:
          1: {name: punctuation.definition.array.bach}
        patterns:
          - include: "#punctuation"
          - include: $self

  patterns:
    - include: "#round-brackets"
    - include: "#square-brackets"
    - include: "#curly-brackets"

  support-modules:
    patterns:
  support-constants:
    patterns:
  support-functions:
    patterns:

  support-types:
    patterns:
      - comment: primitive data types
        match: |
          (?x)\s*\b(
          bool|int|float|[nr]at|real|imag|comp|num
          |char|rune|str|sym|regex|func?|buff|bin
          |# numeric types
          (?:c|i|f|s|u|n|[nr]at|u?int|float|imag|comp)
          (?:8|16|32|64|128)
          |(?:c|i|)(?:half|float|double|quad|oct)
          )\b
        name: support.type.builtin.primitive.bach
      - comment: built-in constant types
        match: |
          (?x)\s*\b(
          true|yes|on|false|no|off
          |null|nil|none|undef|void
          |nan|inf|infin
          |any|empty|obj|rec|unit|mix|this|that|it|self|super
          |arr|tuple|list|set|map|dict|seq|gen|range
          )\b
        name: support.type.builtin.bach
      - comment: built-in primitive classes
        match: |
          (?x)\s*\b(
          Bool|Int|Float|[NR]at|Real|Imag|Comp|Number
          |Char|Rune|String|Symbol|RegExp?|Func|Buffer|Binary
          |# numeric types
          (?:C|I|F|S|U|N|[NR]at|U?Int|Real|Imag|Comp)
          (?:8|16|32|64|128)
          |(?:C|I|)(?:Half|Float|Double|Quad|Oct)
          )\b
        name: support.type.builtin.class.bach
      - comment: built-in primitive type classes
        match: |
          (?x)\s*\b(
          True|False|Nil|Void|NaN|Infin
          |Any|Empty|Object|Record|Unit|Mixed
          |Array|Tuple|List|Set|Map|Dict|Seq|Gen|Range
          )\b
        name: support.type.class.bach
      - comment: interface classes (beginning with I)
        match: (?x)\s*\b(I((\p{upper}\p{lower}*)+))\b
        name: entity.name.interface.bach
      - comment: namespace classes (beginning with NS)
        match: (?x)\s*\b(NS((\p{upper}\p{lower}*)+))\b
        name: entity.name.namespace.bach
      - comment: error classes (ending with Error)
        match: (?x)\s*\b(((\p{upper}\p{lower}*)+)Error)\b
        name: support.class.error.bach
