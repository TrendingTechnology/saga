firstLineMatch: ^#!\s*/.*\b(nova)$\n?
foldingEndMarker: (\*/|\}|\))
foldingStartMarker: (/\*|{|\()
infoForContributors: |-
  This file is a fork of the Babel JavaScript TextMate grammar and features many 
    customizations for Nova, another programming language that compiles to JavaScript.  
    This file is constantly regenerated with a custom build pipeline.
  Should you want to provide a fix or improvement, or even a new feature,
    please create a pull request against this repo: https://github.com/NoxUltima/nova,
    and I will be very happy to receive them.
name: Nova
scopeName: source.coffee
bugfixes:
- Functions and methods are scoped to their initial starting letter, in the meantime, until the StdLib is out.
- Fixed modifier keyword parsing (technically). They should activate only before a declaration, say `dyn val x = 1`, or other modifiers.
- Fixed operator parsing in JSX and regex literals. Inline regexes should wherever possible be spaced out on both sides. This is intentional.
bugs:
- Find out how to escape keyword-like identifiers with a trailing backslash - repeat\ for example.
Changes:
- Block comments can be nested thanks to Swift's codes, and can now support Markdown.
- Same thing for JSX markup.
- Identifiers can now include `\`.
- Added Scala `match` and `with` clauses.
- Added tons of new keywords and operators; as well as support for space-delimited unary and binary operators.
- Numeric literals support every possible even base except 14, as well as extended numeric notation for all bases.
- All operators are colored differently based on their type.
fileTypes:
  - nova
  - coffee
  - ne
fixes:
- Revamp regex syntax (more syntax scopes for constructs)
- Add TypeScript, ReScript and JavaScript to raw code blocks
- Fix trailing semicolon issue in type declarations/imports and functions
- Added indentation. Now all the Styles / GraphQL are broken. Template strings still work however.
- Indented SASS and HAML code in place of CSS and HTML, plus YAML in place for JSON.
patterns:
- include: '#core'
repository:
  arrow-expression:
    begin: (?<==>)\s*$
    end: (?=\s*([,;}]|$))|(?<=})
    patterns:
    - include: '#core'
  arrow-function:
    patterns:
    - begin: \s*+(\basync\b)?(?=\s*(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
      end: ((?<=})|(?:\s*(=>)(?!\s*{)))
      name: meta.function.arrow.nova
      beginCaptures:
        1: {name: storage.type.nova}
      endCaptures:
        2: {name: storage.type.function.arrow.nova}
      patterns:
      - include: '#types'
      - include: '#fat-arrow-braced-body'
    - match: \s*+(\basync\b)?\s*+(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))\s*(=>)
      name: meta.function.arrow.nova
      captures:
        1: {name: storage.type.nova}
        2: {name: meta.function.parameters.nova}
        3: {name: variable.other.readwrite.nova}
        4: {name: storage.type.function.arrow.nova}
    - include: '#arrow-function-simple-assignments'
    - begin: \s*+(\#?)(\b[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)?(?:(\?\.)|(\.))(proto)(?:(\?\.)|(\.))(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(\basync\b)?(?=\s*(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*%checks\b|\s*(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))+|\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)|(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)+|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
      end: ((?<=})|(?:\s*(=>)(?!\s*{)))
      name: meta.prototype.function.arrow.nova
      beginCaptures:
        1: {name: keyword.operator.private.nova}
        2: {name: entity.name.class.nova}
        3: {name: keyword.operator.existential.nova}
        4: {name: keyword.operator.accessor.nova}
        5: {name: variable.language.prototype.nova}
        6: {name: keyword.operator.existential.nova}
        7: {name: keyword.operator.accessor.nova}
        8: {name: keyword.operator.private.nova}
        9: {patterns: [{include: '#function-name'}]}
        10: {name: keyword.operator.assignment.nova}
        11: {name: storage.type.nova}
      endCaptures:
        2: {name: storage.type.function.arrow.nova}
      patterns:
      - include: '#types'
      - include: '#fat-arrow-braced-body'
    - match: \s*+(\#?)(\b[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)?\s*(?:(\?\.)|(\.))(proto)(?:(\?\.)|(\.))(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(\basync\b)?\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*(=>)
      name: meta.prototype.function.arrow.nova
      captures:
        1: {name: keyword.operator.private.nova}
        2: {name: entity.name.class.nova}
        3: {name: keyword.operator.existential.nova}
        4: {name: keyword.operator.accessor.nova}
        5: {name: variable.language.prototype.nova}
        6: {name: keyword.operator.existential.nova}
        7: {name: keyword.operator.accessor.nova}
        8: {name: keyword.operator.private.nova}
        9: {patterns: [{include: '#function-name'}]}
        10: {name: keyword.operator.assignment.nova}
        11: {name: storage.type.nova}
        12: {name: variable.other.readwrite.nova}
        13: {name: storage.type.function.arrow.nova}
    - begin: \s*+(\#?)(\b[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)?(?:(\?\.)|(\.))(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(\basync\b)?(?=\s*+(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*%checks\b|\s*(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))+|\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)|(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)+|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
      end: ((?<=})|(?:\s*(=>)(?!\s*{)))
      name: meta.function.static.arrow.nova
      beginCaptures:
        1: {name: keyword.operator.private.nova}
        2: {name: entity.name.class.nova}
        3: {name: keyword.operator.existential.nova}
        4: {name: keyword.operator.accessor.nova}
        5: {name: keyword.operator.private.nova}
        6: {patterns: [{include: '#function-name'}]}
        7: {name: keyword.operator.assignment.nova}
        8: {name: storage.type.nova}
      endCaptures:
        2: {name: storage.type.function.arrow.nova}
      patterns:
      - include: '#types'
      - include: '#fat-arrow-braced-body'
    - match: \s*+(\#?)(\b[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)?(?:(\?\.)|(\.))(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(\basync\b)?\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*(=>)
      name: meta.function.static.arrow.nova
      captures:
        1: {name: keyword.operator.private.nova}
        2: {name: entity.name.class.nova}
        3: {name: keyword.operator.existential.nova}
        4: {name: keyword.operator.accessor.nova}
        5: {name: keyword.operator.private.nova}
        6: {patterns: [{include: '#function-name'}]}
        7: {name: keyword.operator.assignment.nova}
        8: {name: storage.type.nova}
        9: {name: variable.other.readwrite.nova}
        10: {name: storage.type.function.arrow.nova}
  arrow-function-labels:
    patterns:
    - include: '#async-arrow-function-labels'
    - begin: (?<=^|{|,)\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(:)\s*+(\basync\b)?\s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*%checks\b|\s*(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))+|\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)|(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)+|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
      end: ((?<=})|(?:\s*(=>)(?!\s*{)))
      name: meta.function.json.arrow.nova
      beginCaptures:
        1: {patterns: [{include: '#function-name'}]}
        2: {name: punctuation.separator.key-value.nova}
        3: {name: storage.type.nova}
      endCaptures:
        2: {name: storage.type.function.arrow.nova}
      patterns:
      - include: '#types'
      - include: '#fat-arrow-braced-body'
    - match: (?<=^|{|,)\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(:)\s*+(\basync\b)?\s*+(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))\s*(=>)
      name: meta.function.json.arrow.nova
      captures:
        1: {patterns: [{include: '#function-name'}]}
        2: {name: keyword.operator.assignment.nova}
        3: {name: storage.type.nova}
        4: {name: meta.function.parameters.nova}
        5: {name: variable.other.readwrite.nova}
        6: {name: storage.type.function.arrow.nova}
    - begin: (?<=^|{|,)\s*+(('|")([^"']*)(\k<-3>))\s*(:)\s*+(\basync\b)?\s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*%checks\b|\s*(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))+|\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)|(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)+|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
      end: ((?<=})|(?:\s*(=>)(?!\s*{)))
      name: meta.function.json.arrow.nova
      beginCaptures:
        1: {name: string.quoted.nova}
        2: {name: punctuation.definition.string.begin.nova}
        3: {patterns: [{include: '#function-name'}]}
        4: {name: punctuation.definition.string.end.nova}
        5: {name: punctuation.separator.key-value.nova}
        6: {name: storage.type.nova}
      endCaptures:
        2: {name: storage.type.function.arrow.nova}
      patterns:
      - include: '#types'
      - include: '#fat-arrow-braced-body'
    - match: (?<=^|{|,)\s*+(('|")([^"']*)(\k<-3>))\s*+(:)\s*+(\basync\b)?\s*+(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))\s*(=>)
      name: meta.function.json.arrow.nova
      captures:
        1: {name: string.quoted.nova}
        2: {name: punctuation.definition.string.begin.nova}
        3: {patterns: [{include: '#function-name'}]}
        4: {name: punctuation.definition.string.end.nova}
        5: {name: keyword.operator.assignment.nova}
        6: {name: storage.type.nova}
        7: {name: meta.function.parameters.nova}
        8: {name: variable.other.readwrite.nova}
        9: {name: storage.type.function.arrow.nova}
  arrow-function-simple-assignments:
    patterns:
    - include: '#async-arrow-function-simple-assignments'
    - begin: \s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(\basync\b)?(?=(\s*+<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(((?::(?:(\s*+(&|\|)?(\s*%checks\b|\s*(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))+|\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)|(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)+|\s*+({(?:(?>[^{}]+)|\g<-1>)*\})|\s*+(\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(\s*(["']).*?\k<-1>(?<!\\.))|\s*[+-x]?\h+))|(?:\s*+/\*.*?\*/))*+)*)|(?:/\*.*?\*/))\s*=>)
      end: ((?<=})|(?:\s*(=>)(?!\s*{)))
      name: meta.function.arrow.nova
      beginCaptures:
        1: {name: keyword.operator.private.nova}
        2: {patterns: [{include: '#function-name'}]}
        3: {name: keyword.operator.assignment.nova}
        4: {name: storage.type.nova}
      endCaptures:
        2: {name: storage.type.function.arrow.nova}
      patterns:
      - include: '#types'
      - include: '#fat-arrow-braced-body'
    - match: \s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+\s*+(\basync\b)?\s*+(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))\s*(=>)
      name: meta.function.arrow.nova
      captures:
        1: {name: keyword.operator.private.nova}
        2: {patterns: [{include: '#function-name'}]}
        3: {name: keyword.operator.assignment.nova}
        4: {name: storage.type.nova}
        5: {name: meta.function.parameters.nova}
        6: {name: variable.other.readwrite.nova}
        7: {name: storage.type.function.arrow.nova}
  async-arrow-function-labels:
    patterns:
    - begin: (?<=^|{|,)\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(:)\s*+(?:(\basync)\s+)(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+\()
      end: ((?<=})|(?:\s*(=>)(?!\s*{)))
      name: meta.function.json.arrow.nova
      beginCaptures:
        1: {patterns: [{include: '#function-name'}]}
        2: {name: punctuation.separator.key-value.nova}
        3: {name: storage.type.nova}
      endCaptures:
        2: {name: storage.type.function.arrow.nova}
      patterns:
      - include: '#types'
      - include: '#fat-arrow-braced-body'
    - begin: (?<=^|{|,)\s*+(('|")([^"']*)(\k<-3>))\s*(:)\s*+(?:(\basync)\s+)(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+\()
      end: ((?<=})|(?:\s*(=>)(?!\s*{)))
      name: meta.function.json.arrow.nova
      beginCaptures:
        1: {name: string.quoted.nova}
        2: {name: punctuation.definition.string.begin.nova}
        3: {patterns: [{include: '#function-name'}]}
        4: {name: punctuation.definition.string.end.nova}
        5: {name: punctuation.separator.key-value.nova}
        6: {name: storage.type.nova}
      endCaptures:
        2: {name: storage.type.function.arrow.nova}
      patterns:
      - include: '#types'
      - include: '#fat-arrow-braced-body'
  async-arrow-function-simple-assignments:
    patterns:
    - begin: \s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(=)\s*+(?:(\basync)\s+)(?=\s*(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+\()
      end: ((?<=})|(?:\s*(=>)(?!\s*{)))
      name: meta.function.arrow.nova
      beginCaptures:
        1: {name: keyword.operator.private.nova}
        2: {patterns: [{include: '#function-name'}]}
        3: {name: keyword.operator.assignment.nova}
        4: {name: storage.type.nova}
      endCaptures:
        2: {name: storage.type.function.arrow.nova}
      patterns:
      - include: '#types'
      - include: '#fat-arrow-braced-body'
  backreferences:
    patterns:
    - match: \$\d+|\$[+-]
      name: keyword.other.back-reference.nova
    - match: \$\$
      name: constant.character.escape.nova
    - begin: (\$<)
      end: \s*(>)
      name: keyword.other.back-reference.nova
      beginCaptures:
        1: {name: keyword.other.back-reference.nova}
      endCaptures:
        1: {name: keyword.other.back-reference.nova}
      patterns:
      - include: '#regex-group-name'
    - include: '#string-content'
  block-entities:
    patterns:
    - include: '#type-argument-brackets'
    - include: '#typed-trap'
    - include: '#operator'
    - include: '#operators'
    - match: \s*+\b((ext)|(impl)|(only))\b\s*+
      captures:
        1: {name: meta.class.extends.nova}
        2: {name: storage.type.extends.nova}
        3: {name: storage.type.implements.nova}
        4: {name: keyword.operator.expression.only.nova}
    - include: '#types'
    - begin: \s*+({)
      end: \s*(})
      beginCaptures:
        1: {name: punctuation.section.class.begin.nova}
      endCaptures:
        1: {name: punctuation.section.class.end.nova}
      patterns:
      - include: '#typed-method'
      - include: '#core'
    - match: \s*(\.)
      captures:
        1: {name: keyword.operator.accessor.nova}
    - include: '#core'
  blocks:
    patterns:
    - include: '#raw'
    - include: '#schema'
    - include: '#style'
    - include: '#class'
    - include: '#enum'
    - include: '#interface'
    - include: '#trait'
    - include: '#fragment'
    - include: '#module'
    - include: '#namespace'
    - include: '#object'
    - include: '#constraint'
    - include: '#extension'
    repository:
      class:
        begin: (?<![\#\.])\s*+\b(class)(\s+|$)
        end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        beginCaptures:
          1: {name: storage.type.class.nova}
        endCaptures:
          1: {name: keyword.operator.assignment.nova}
        patterns:
        - match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
          name: entity.name.class.nova
        - include: '#block-entities'
      constraint:
        begin: (?<![\#\.])\s*+\b(given|constr)(\s+|$)
        end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        beginCaptures:
          1: {name: storage.type.constraint.nova}
        endCaptures:
          1: {name: keyword.operator.assignment.nova}
        patterns:
        - match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
          name: entity.name.constraint.nova
        - include: '#block-entities'
      enum:
        begin: (?<![\#\.])\s*+\b(enum)\s+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)?(\s+|$)
        end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        name: meta.enum.declaration.nova
        beginCaptures:
          1: {name: storage.type.enum.nova}
          2: {name: entity.name.enum.nova}
        endCaptures:
          1: {name: keyword.operator.assignment.nova}
        patterns:
        - match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
          name: entity.name.enum.nova
        - include: '#block-entities'
      extension:
        begin: (?<![\#\.])\s*+\b(extend|extn)(\s+|$)
        end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        beginCaptures:
          1: {name: storage.type.extension.nova}
        endCaptures:
          1: {name: keyword.operator.assignment.nova}
        patterns:
        - match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
          name: entity.name.extension.nova
        - include: '#block-entities'
      fragment:
        begin: (?<![\#\.])\s*+\b(frag|struct)(\s+|$)
        end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        beginCaptures:
          1: {name: storage.type.fragment.nova}
        endCaptures:
          1: {name: keyword.operator.assignment.nova}
        patterns:
        - match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
          name: entity.name.fragment.nova
        - include: '#block-entities'
      interface:
        begin: (?<![\#\.])\s*+\b(inter|iface)(\s+|$)
        end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        beginCaptures:
          1: {name: storage.type.interface.nova}
        endCaptures:
          1: {name: keyword.operator.assignment.nova}
        patterns:
        - match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
          name: entity.name.interface.nova
        - include: '#block-entities'
      module:
        begin: (?<![\#\.])\s*+\b(module)(\s+|$)
        end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        beginCaptures:
          1: {name: storage.type.module.nova}
        endCaptures:
          1: {name: keyword.operator.assignment.nova}
        patterns:
        - match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
          name: entity.name.module.nova
        - include: '#block-entities'
      namespace:
        begin: (?<![\#\.])\s*+\b(nspace)(\s+|$)
        end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        beginCaptures:
          1: {name: storage.type.namespace.nova}
        endCaptures:
          1: {name: keyword.operator.assignment.nova}
        patterns:
        - match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
          name: entity.name.namespace.nova
        - include: '#block-entities'
      object:
        begin: (?<![\#\.])\s*+\b(object|record)(\s+|$)
        end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        beginCaptures:
          1: {name: storage.type.object.nova}
        endCaptures:
          1: {name: keyword.operator.assignment.nova}
        patterns:
        - match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
          name: entity.name.object.nova
        - include: '#block-entities'
      raw:
        begin: (?<![\#\.])\s*+\b(raw)(\s+|$)
        end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        beginCaptures:
          1: {name: storage.type.raw.nova}
        endCaptures:
          1: {name: keyword.operator.assignment.nova}
        patterns:
        - match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
          name: entity.name.raw.nova
        - include: '#block-entities'
      schema:
        begin: (?<![\#\.])\s*+\b(data|schema)(\s+|$)
        end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        beginCaptures:
          1: {name: storage.type.schema.nova}
        endCaptures:
          1: {name: keyword.operator.assignment.nova}
        patterns:
        - match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
          name: entity.name.schema.nova
        - include: '#block-entities'
      style:
        begin: (?<![\#\.])\s*+\b(style)(\s+|$)
        end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        beginCaptures:
          1: {name: storage.type.style.nova}
        endCaptures:
          1: {name: keyword.operator.assignment.nova}
        patterns:
        - match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
          name: entity.name.style.nova
        - include: '#block-entities'
      trait:
        begin: (?<![\#\.])\s*+\b(trait)(\s+|$)
        end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
        beginCaptures:
          1: {name: storage.type.trait.nova}
        endCaptures:
          1: {name: keyword.operator.assignment.nova}
        patterns:
        - match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
          name: entity.name.trait.nova
        - include: '#block-entities'
  brackets:
    patterns:
    - include: '#round-brackets'
    - include: '#square-brackets'
    - include: '#curly-brackets'
  cast-expression:
    match: (?x)(\()\s*(.*)\s*(\))(?=\s*[\p{S}\p{Po}\p{Pd}&&[^,;'"`</>\\$]]*?[_\\\p{L}\p{M}\p{N}\p{Ps}\p{Pe}])
    captures:
      1: {name: punctuation.definition.cast.begin.nova}
      2: {patterns: [{include: '#function-name'}, {include: $self}]}
      3: {name: punctuation.definition.cast.end.nova}
  clauses:
    patterns:
    - include: '#for-clause'
    - include: '#if-clause'
    - include: '#switch-clause'
    - include: '#match-clause'
    - include: '#catch-clause'
    - include: '#with-clause'
    - include: '#parallel-clause'
    - include: '#do-clause'
    - include: '#when-clause'
    - include: '#case-clause'
    repository:
      case-clause:
        patterns:
        - begin: (?<![\#\.])\s*+\b(case|fail)\b
          end: \s*(?=\p{Pe}|$|->|(?<![\#\.])\s*+\bthen\b)
          beginCaptures:
            1: {name: keyword.control.switch.nova}
          endCaptures:
            0: {name: keyword.operator.nova}
          patterns:
          - include: $self
      catch-clause:
        patterns:
        - begin: (?<![\#\.])\s*+\b(try|catch|rescue|finally)\b\s*(await)?\b
          end: \s*(?=\p{Pe}|$|->|(?<![\#\.])\s*+\bthen\b)
          name: meta.catch.nova
          beginCaptures:
            1: {name: keyword.control.trycatch.nova}
            2: {name: keyword.control.flow.nova}
          patterns:
          - begin: \s*+(\()
            end: \s*(\))
            beginCaptures:
              1: {name: meta.brace.round.nova}
            endCaptures:
              1: {name: meta.brace.round.nova}
            patterns:
            - match: (?<![\#\.])\s*+\b(as)\b
              name: keyword.control.trycatch.nova
            - include: $self
          - include: '#curly-brackets'
          - match: (?<![\#\.])\s*+\b(as)\b
            name: keyword.control.trycatch.nova
          - include: $self
      do-clause:
        patterns:
        - begin: (?<![\#\.])\s*+\b(do)\b\s*(await)?\b
          end: \s*(?=\p{Pe}|$|->|(?<![\#\.])\s*+\bthen\b)
          name: meta.do.nova
          beginCaptures:
            1: {name: keyword.control.do.nova}
            2: {name: keyword.control.flow.nova}
          patterns:
          - include: '#round-brackets'
          - include: '#curly-brackets'
          - include: $self
      for-clause:
        patterns:
        - begin: (?<![\#\.])\s*+\b(for|each|while|until)\b\s*(await)?\b
          end: \s*(?=\p{Pe}|$|->|(?<![\#\.])\s*+\bthen\b)
          name: meta.for.nova
          beginCaptures:
            1: {name: keyword.control.loop.nova}
            2: {name: keyword.control.flow.nova}
          patterns:
          - match: (?<![\#\.])\s*+\b(in|of|by|to|til)\b
            name: keyword.control.loop.nova
          - include: '#let-clause'
          - begin: \s*+(\()
            end: \s*(\))
            beginCaptures:
              1: {name: meta.brace.round.nova}
            endCaptures:
              1: {name: meta.brace.round.nova}
            patterns:
            - match: (?<![\#\.])\s*+\b(in|of|by|to|til)\b
              name: keyword.control.loop.nova
            - include: '#let-clause'
            - include: $self
          - include: '#curly-brackets'
          - include: $self
        repository:
          let-clause:
            match: (?<![\#\.])\s*+\b(const|con|let|var|val)\b\s*
            name: storage.type.nova
      if-clause:
        patterns:
        - begin: (?<![\#\.])\s*+\b(if|els?if|ell?ess?|unless?|guard)\b\s*(await)?\b
          end: \s*(?=\p{Pe}|$|->|(?<![\#\.])\s*+\bthen\b)
          name: meta.if.nova
          beginCaptures:
            1: {name: keyword.control.conditional.nova}
            2: {name: keyword.control.flow.nova}
          patterns:
          - include: '#curly-brackets'
          - include: '#round-brackets'
          - include: $self
      match-clause:
        patterns:
        - begin: (?<![\#\.])\s*+\b(match)\b
          end: \s*(?=\p{Pe}|$|->|(?<![\#\.])\s*+\bthen\b)
          name: meta.match.nova
          beginCaptures:
            1: {name: keyword.control.match.nova}
          patterns:
          - include: $self
      parallel-clause:
        patterns:
        - begin: (?<![\#\.])\s*+\b(para|seq)\b\s*(await)?\b
          end: \s*(?=\p{Pe}|$|->|(?<![\#\.])\s*+\bthen\b)
          name: meta.parallel.nova
          beginCaptures:
            1: {name: keyword.control.parallel.nova}
            2: {name: keyword.control.flow.nova}
          patterns:
          - begin: \s*+(\()
            end: \s*(\))
            beginCaptures:
              1: {name: meta.brace.round.nova}
            endCaptures:
              1: {name: meta.brace.round.nova}
            patterns:
            - match: (?<![\#\.])\s*+\b(as)\b
              name: keyword.control.parallel.nova
            - include: $self
          - include: '#curly-brackets'
          - match: (?<![\#\.])\s*+\b(as)\b
            name: keyword.control.parallel.nova
          - include: $self
      switch-clause:
        patterns:
        - begin: (?<![\#\.])\s*+\b(switch)\b
          end: \s*(?=\p{Pe}|$|->|(?<![\#\.])\s*+\bthen\b)
          name: meta.switch.nova
          beginCaptures:
            1: {name: keyword.control.switch.nova}
          endCaptures:
            1: {name: meta.brace.curly.switchEnd.nova}
          patterns:
          - include: '#round-brackets'
          - begin: \s*+({)
            end: \s*(?=})
            beginCaptures:
              1: {name: meta.brace.curly.switchStart.nova}
            patterns:
            - include: '#case-clause'
            - include: $self
          - include: $self
      when-clause:
        patterns:
        - begin: (?<![\#\.])\s*+\b(when)\b
          end: \s*(?=\p{Pe}|$|->|(?<![\#\.])\s*+\bthen\b)
          beginCaptures:
            1: {name: keyword.control.match.nova}
          endCaptures:
            0: {patterns: [{include: $self}]}
          patterns:
          - include: '#match-clause'
          - include: '#as-clause'
          - include: '#case-separator'
          - include: $self
        repository:
          as-clause:
            begin: (?<![\#\.])\s*\b([ai]s|with)\b\s*
            end: (?<![\#\.])\s*\b(?=[ai]s|with)|\s*(?=->|(?<![\#\.])\s*+\bthen\b)|$
            beginCaptures:
              1: {name: keyword.control.match.nova}
            endCaptures:
              1: {patterns: [{include: $self}]}
            patterns:
            - include: '#match-clause'
            - include: '#as-clause'
            - include: '#case-separator'
            - include: '#typed-parse-types'
          case-separator:
            begin: ([,;])
            end: (?<![\#\.])\s*\b(?=[ai]s|with|if|unless|where)|\s*(?=->|(?<![\#\.])\s*+\bthen\b)|$
            beginCaptures:
              1: {patterns: [{include: $self}]}
            endCaptures:
              1: {patterns: [{include: $self}]}
            patterns:
            - include: '#match-clause'
            - include: '#as-clause'
            - include: '#case-separator'
            - include: $self
          match-clause:
            begin: (?<![\#\.])\s*\b(if|unless|where)\b\s*
            end: (?<![\#\.])\s*\b(?=if|unless|where)|\s*(?=->|(?<![\#\.])\s*+\bthen\b)|$
            beginCaptures:
              1: {name: keyword.control.match.nova}
            endCaptures:
              1: {patterns: [{include: $self}]}
            patterns:
            - include: '#match-clause'
            - include: '#as-clause'
            - include: '#case-separator'
            - include: $self
      with-clause:
        patterns:
        - begin: (?<![\#\.])\s*+\b(with)\b\s*(await)?\b
          end: \s*(?=\p{Pe}|$|->|(?<![\#\.])\s*+\bthen\b)
          name: meta.with.nova
          beginCaptures:
            1: {name: keyword.control.with.nova}
            2: {name: keyword.control.flow.nova}
          patterns:
          - include: '#curly-brackets'
          - begin: \s*
            end: \s*(?=[{,])
            patterns:
            - match: (?<![\#\.])\s*+\b(as)\b
              name: keyword.control.with.nova
            - include: $self
          - begin: \s*+(\()
            end: \s*(\))
            beginCaptures:
              1: {name: meta.brace.round.nova}
            endCaptures:
              1: {name: meta.brace.round.nova}
            patterns:
            - match: (?<![\#\.])\s*+\b(as)\b
              name: keyword.control.with.nova
            - include: $self
          - include: $self
  comma:
    patterns:
    - match: \s*+(,)
      captures:
        1: {name: meta.delimiter.comma.nova}
  comments:
    patterns:
    - include: '#typed-comments'
    - include: '#special-comments-conditional-compilation'
    - begin: \s*+((/\*\*))(?!/|\*)
      contentName: comment.block.documentation.nova
      end: (\s*(\*/))
      captures:
        1: {name: comment.block.documentation.nova}
        2: {name: punctuation.definition.comment.nova}
      patterns:
      - include: '#jsdoc'
      - include: text.html.markdown#inline
      - include: '#nested'
    - begin: \s*+((/\*))
      contentName: comment.block.nova
      end: (\s*(\*/))
      captures:
        1: {name: comment.block.nova}
        2: {name: punctuation.definition.comment.nova}
      patterns:
      - include: text.html.markdown#inline
      - include: '#nested'
    - begin: \s*+(<!--)
      contentName: comment.block.html.nova
      end: \s*+(-->)
      beginCaptures:
        1: {name: punctuation.definition.comment.nova}
      endCaptures:
        1: {name: punctuation.definition.comment.nova}
    - begin: ((^\s*)|\s*)((///))
      contentName: comment.line.triple-slash.nova
      end: \s*$
      beginCaptures:
        2: {name: punctuation.whitespace.comment.leading.nova}
        3: {name: comment.line.triple-slash.nova}
        4: {name: punctuation.definition.comment.nova}
      endCaptures:
        0: {name: comment.line.triple-slash.nova}
      patterns:
      - include: '#jsdoc'
      - include: text.html.markdown#inline
    - begin: ((^\s*)|\s*)((//))
      contentName: comment.line.double-slash.nova
      end: \s*$
      beginCaptures:
        2: {name: punctuation.whitespace.comment.leading.nova}
        3: {name: comment.line.double-slash.nova}
        4: {name: punctuation.definition.comment.nova}
      endCaptures:
        0: {name: comment.line.double-slash.nova}
    - match: ^(\#!).*$\n?
      name: comment.line.shebang.nova
      captures:
        1: {name: punctuation.definition.comment.nova}
    repository:
      nested:
        begin: /\*\*?
        end: \*/
        beginCaptures:
          0: {name: punctuation.definition.comment.nova}
        endCaptures:
          0: {name: punctuation.definition.comment.nova}
        patterns:
        - include: '#jsdoc'
        - include: text.html.markdown#inline
        - include: '#nested'
  core:
    patterns:
    - include: '#operator'
    - include: '#sigils'
    - include: '#clauses'
    - include: '#object'
    - include: '#new'
    - include: '#query'
    - include: '#module'
    - include: '#function'
    - include: '#arrow-function'
    - include: '#prototype'
    - include: '#blocks'
    - include: '#modifiers'
    - include: '#keyword-storage'
    - include: '#keywords'
    - include: '#typed-keywords'
    - include: '#typed-trap'
    - include: '#method-call'
    - include: '#function-call'
    - include: '#multiline-arrow-function-generics'
    - include: '#jsx'
    - include: '#es7-decorators'
    - include: '#js-label'
    - include: '#regexp-multiline'
    - include: '#regexp'
    - include: '#number'
    - include: '#quasi'
    - include: '#string'
    - include: '#language-constant'
    - include: '#language-variable'
    - include: '#support'
    - include: '#implicit-call'
    - include: '#support-properties'
    - include: '#variable-typed'
    - include: '#variable'
    - include: '#brackets'
    - include: '#operators'
    - include: '#punctuation'
    - include: '#comments'
    - include: '#fat-arrow'
  curly-brackets:
    patterns:
    - begin: \s*+(#?\{\|)
      end: \s*(\|\})
      beginCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      endCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      patterns:
      - include: '#object-body'
      - include: '#labels'
      - include: '#core'
    - begin: \s*+(\#\{)
      end: \s*(\})
      beginCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      endCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      patterns:
      - include: '#object-body'
      - include: '#labels'
      - include: '#core'
    - begin: \s*+(\{)
      end: \s*(\})
      beginCaptures:
        1: {name: meta.brace.curly.nova}
      endCaptures:
        1: {name: meta.brace.curly.nova}
      patterns:
      - include: '#js-label'
      - include: '#labels'
      - include: '#core'
  embedded-haml:
    patterns:
    - begin: ^(\s*)==
      contentName: string.quoted.double.ruby
      end: $\n*
      patterns:
      - include: '#interpolated_ruby'
    - begin: ^(\s*):ruby
      end: ^(?!\1\s+|$\n*)
      name: source.ruby.embedded.filter.haml
      patterns:
      - include: source.ruby
    - match: ^(!!!)($|\s.*)
      name: meta.prolog.haml
      captures:
        1: {name: punctuation.definition.prolog.haml}
    - begin: ^(\s*):javascript
      end: ^(?!\1\s+|$\n*)
      name: js.haml
      patterns:
      - include: source.js
    - begin: ^(\s*):ruby$
      end: ^(?!\1\s+|$\n*)
      name: source.ruby.embedded.filter.haml
      patterns:
      - include: source.ruby
    - match: ^(\s*)(\/\[[^\]].*?$\n?)
      name: comment.line.slash.haml
      captures:
        1: {name: punctuation.section.comment.haml}
    - begin: ^(\s*)(\-\#|\/|\-\s*\/\*+)
      end: ^(?!\1\s+|\n)
      name: comment.block.haml
      beginCaptures:
        2: {name: punctuation.section.comment.haml}
      patterns:
      - include: text.haml
    - begin: ^\s*(?:((%)([-\w:]+))|(?=\.|#))
      end: $|(?!\.|#|\{|\(|\[|&amp;|=|-|~|!=|&=|/)
      captures:
        1: {name: meta.tag.haml}
        2: {name: punctuation.definition.tag.haml}
        3: {name: entity.name.tag.haml}
      patterns:
      - begin: '=='
        contentName: string.quoted.double.ruby
        end: $\n?
        patterns:
        - include: '#interpolated_ruby'
      - match: (\.[\w\-\:]+)
        name: meta.selector.css
        captures:
          1: {name: entity.other.attribute-name.class}
      - match: (#[\w-]+)
        name: meta.selector.css
        captures:
          1: {name: entity.other.attribute-name.id}
      - begin: (?<!\#)\{(?=.+(,|(do)|\{|\}|\||(\#.*))\s*)
        end: \s*\}(?!\s*\,)(?!\s*\|)(?!\#\{.*\})
        name: meta.section.attributes.haml
        patterns:
        - include: source.ruby
        - include: '#continuation'
        - include: '#rubyline'
      - begin: \(
        end: \)
        name: meta.section.attributes.plain.haml
        patterns:
        - match: ([\w-]+)
          name: constant.other.symbol.ruby
        - match: \=
          name: punctuation
        - include: '#variables'
        - begin: '"'
          end: '"'
          name: string.quoted.double.ruby
          patterns:
          - match: \\(x\h{2}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.)
            name: constant.character.escape.ruby
          - include: '#interpolated_ruby'
        - include: '#interpolated_ruby'
      - begin: \[(?=.+(,|\[|\]|\||(\#.*))\s*)
        end: \s*\](?!.*(?!\#\[)\])
        name: meta.section.object.haml
        patterns:
        - include: source.ruby
        - include: '#continuation'
        - include: '#rubyline'
      - include: '#interpolated_ruby_line'
      - include: '#rubyline'
      - match: /
        name: punctuation.terminator.tag.haml
    - begin: ^(\s*):(ruby|opal)$
      end: ^(?!\1\s+|$\n*)
      name: source.ruby.embedded.filter.haml
      patterns:
      - include: source.ruby
    - begin: ^(\s*):ruby$
      end: ^(?!\1\s+|$\n*)
      name: source.ruby.embedded.filter.haml
      patterns:
      - include: source.ruby
    - begin: ^(\s*):(style|sass)$
      end: ^(?=\1\s+|$\n*)
      name: source.sass.embedded.filter.haml
      patterns:
      - include: source.sass
    - begin: ^(\s*):coffee(script)?
      end: ^(?!\1\s+|$\n*)
      name: source.coffee.embedded.filter.haml
      patterns:
      - include: source.coffee
    - begin: ^(\s*):plain$
      end: ^(?=\1\s+|$\n*)
      name: text.plain.embedded.filter.haml
      patterns:
      - include: text.plain
    - begin: ^(\s*)(:ruby)
      end: (?m:(?<=\n)(?!\1\s+|$\n*))
      name: source.ruby.embedded.filter.haml
      beginCaptures:
        2: {name: keyword.control.filter.haml}
      patterns:
      - include: source.ruby
    - begin: ^(\s*)(:sass)
      end: ^(?!\1\s+|$\n*)
      name: source.embedded.filter.sass
      beginCaptures:
        2: {name: keyword.control.filter.haml}
      patterns:
      - include: source.sass
    - begin: ^(\s*):(styles|sass)$
      end: ^(?=\1\s+|$\n*)
      name: source.sass.embedded.filter.haml
      patterns:
      - include: source.sass
    - begin: ^(\s*):plain$
      end: ^(?=\1\s+|$\n*)
      name: text.plain.embedded.filter.haml
      patterns:
      - include: text.plain
    - match: ^\s*(\.)
      captures:
        1: {name: meta.escape.haml}
    - begin: ^\s*(?==|-|~|!=|&=)
      end: $
      patterns:
      - include: '#interpolated_ruby_line'
      - include: '#rubyline'
    - begin: ^(\s*)(:php)
      end: ^(?!\1\s+|$\n*)
      name: meta.embedded.php
      captures:
        2: {name: entity.name.tag.haml}
      patterns:
      - include: text.html.php#language
    - begin: ^(\s*)(:markdown)
      end: ^(?!\1\s+|$\n*)
      name: meta.embedded.markdown
      captures:
        2: {name: entity.name.tag.haml}
      patterns:
      - include: text.html.markdown
    - begin: ^(\s*)(:(css|styles?))$
      end: ^(?!\1\s+|$\n*)
      name: meta.embedded.css
      captures:
        2: {name: entity.name.tag.haml}
      patterns:
      - include: source.css
    - begin: ^(\s*)(:sass)$
      end: ^(?!\1\s+|$\n*)
      name: meta.embedded.sass
      captures:
        2: {name: entity.name.tag.haml}
      patterns:
      - include: source.sass
    - begin: ^(\s*)(:scss)$
      end: ^(?!\1\s+|$\n*)
      name: meta.embedded.scss
      captures:
        2: {name: entity.name.tag.haml}
      patterns:
      - include: source.scss
    repository:
      continuation:
        match: (\|)\s*\n
        captures:
          1: {name: punctuation.separator.continuation.haml}
      interpolated_ruby:
        patterns:
        - match: '#\{(\})'
          name: source.ruby.embedded.source
          captures:
            0: {name: punctuation.section.embedded.ruby}
            1: {name: source.ruby.embedded.source.empty}
        - begin: '#\{'
          end: (\})
          name: source.ruby.embedded.source
          captures:
            0: {name: punctuation.section.embedded.ruby}
          patterns:
          - include: '#nest_curly_and_self'
          - include: source.ruby
        - include: '#variables'
      interpolated_ruby_line:
        begin: '!?=='
        contentName: string.source.ruby.embedded.haml
        end: $
        name: meta.line.ruby.interpolated.haml
        patterns:
        - include: '#interpolated_ruby'
        - include: source.ruby#escaped_char
      nest_curly_and_self:
        patterns:
        - begin: \{
          end: \}
          captures:
            0: {name: punctuation.section.scope.ruby}
          patterns:
          - include: '#nest_curly_and_self'
          - include: source.ruby
      rubyline:
        begin: (&amp|!)?(=|-|~)
        contentName: source.ruby.embedded.haml
        end: ((do|\{)( \|[.*]+\|)?)$|$|^(?!.*\|\s*)$\n?
        name: meta.line.ruby.haml
        endCaptures:
          1: {name: source.ruby.embedded.html}
          2: {name: keyword.control.ruby.start-block}
        patterns:
        - match: \s+((elseif|foreach|switch|declare|default|use))(?=\s|\()
          captures:
            1: {name: keyword.control.php}
        - match: \s+(require_once|include_once)(?=\s|\()
          captures:
            1: {name: keyword.control.import.include.php}
        - match: \s+(catch|try|throw|exception|finally|die)(?=\s|\(|\n*)
          name: keyword.control.exception.php
        - match: \s+(function\s*)((?=\())
          captures:
            1: {name: storage.type.function.php}
        - match: \s+(use\s*)((?=\())
          captures:
            1: {name: keyword.control.php}
        - match: (\||,|<|do|\{)\s*(\#.*)?$\n*
          name: source.ruby
          patterns:
          - include: '#rubyline'
        - match: '#.*$'
          name: comment.line.number-sign.ruby
        - include: source.ruby
        - include: '#continuation'
      variables:
        patterns:
        - match: (#@)[a-zA-Z_]\w*
          name: variable.other.readwrite.instance.ruby
          captures:
            1: {name: punctuation.definition.variable.ruby}
        - match: (#@@)[a-zA-Z_]\w*
          name: variable.other.readwrite.class.ruby
          captures:
            1: {name: punctuation.definition.variable.ruby}
        - match: (#\$)[a-zA-Z_]\w*
          name: variable.other.readwrite.global.ruby
          captures:
            1: {name: punctuation.definition.variable.ruby}
  embedded-raml:
    entities:
      patterns:
      - match: ^[ \t]*([a-zA-Z0-9:]+)
        name: comment.line.number-sign.ruby
        captures:
          1: {name: comment.line.number-sign.ruby}
          3: {name: comment.line.number-sign.ruby}
      - match: '&'
        name: invalid.illegal.bad-ampersand.html
    patterns:
    - match: ^(#%[RY]AML\s+(\d+\.\d+))$
      name: constant.other.directive.yaml
      captures:
        1: {name: constant.language.directive.yaml}
        2: {name: constant.language.version.yaml}
    - begin: (^[ \t]+)?(?=#)
      end: (?!\G)
      beginCaptures:
        1: {name: punctuation.whitespace.comment.leading.yaml}
      patterns:
      - begin: '#'
        end: \Z|\n
        name: comment.line.number-sign.yaml
        beginCaptures:
          0: {name: punctuation.definition.comment.yaml}
    - match: ^---\s*$
      name: constant.language.document.yaml
    - match: ^\.\.\.\s*$
      name: constant.language.document.yaml
    - match: ^((?:%TAG)(?:\s+)(\!(?:[^\!]*\!)?)(?:\s+)([^$]*))$
      name: constant.other.tag.directive.yaml
      captures:
        1: {name: constant.language.directive.yaml}
        2: {name: constant.language.tag.name.yaml}
        3: {name: constant.language.tag.uri.yaml}
    - begin: ^(\s*)((?:(-\s*)?(schema\s*(:))))\s*
      end: ^(?!\1|\s*$)|(\/[^:]+)(:)|^(?=\1(-|\w+\s*:)|#)
      name: punctuation.colon.key-value.yaml
      beginCaptures:
        0: {name: constant.numeric.yaml}
        1: {name: constant.numeric.yaml}
      endCaptures:
        1: {name: keyword.other.omap.yaml}
        2: {name: punctuation.colon.key-value.yaml}
      patterns:
      - match: ^[ \t]*(?:(-)|[^:\/]+)(:)((?:(\![\w\!]+)\s+?)?|\Z|(?#))
        name: string.unquoted.yaml
        captures:
          {}
        patterns:
        - match: ^[ \t]*((\d)+)(:)((?:(\![\w\!]+)\s+?)?|\Z|(?#))
          name: support.type.function.yaml
          captures:
            {}
    - begin: ^(\s*)((?:(-\s*)?(types\s*(:))))\s*
      end: ^(?!\1|\s*$)|(\/[^:]+)(:)|^(?=\1(-|\w+\s*:)|#)
      name: punctuation.colon.key-value.yaml
      beginCaptures:
        0: {name: constant.numeric.yaml}
        1: {name: constant.numeric.yaml}
      endCaptures:
        1: {name: keyword.other.omap.yaml}
        2: {name: punctuation.colon.key-value.yaml}
      patterns:
      - match: ^[ \t]*(?:(-)|[^:\/]+)(:)((?:(\![\w\!]+)\s+?)?|\Z|(?#))
        name: string.unquoted.yaml
        captures:
          {}
        patterns:
        - match: ^[ \t]*((\d)+)(:)((?:(\![\w\!]+)\s+?)?|\Z|(?#))
          name: support.type.function.yaml
          captures:
            {}
      - begin: '#'
        end: \Z|\n
        name: comment.line.number-sign.yaml
        beginCaptures:
          0: {name: punctuation.definition.comment.yaml}
    - begin: ^[ \t]*(baseUri|authorizationUri|authorizationGrants|accessTokenUri|requestTokenUri|tokenCredentialsUri)(:)((?:(\![\w\!]+)\s+?)?|\Z|(?#))
      end: $
      name: meta.key-value
      beginCaptures:
        1: {name: constant.numeric.yaml}
        2: {name: punctuation.colon.key-value.yaml}
        3: {name: support.type.tag.yaml}
      patterns:
      - begin: '#'
        end: \Z|\n
        name: comment.line.number-sign.yaml
        beginCaptures:
          0: {name: punctuation.definition.comment.yaml}
      - include: '#uri'
    - begin: ^[ \t]*((\/)|(\/[^:]+))(:)((?:(\![\w\!]+)\s+?)?|\Z|(?#))
      end: $
      name: meta.resource
      beginCaptures:
        1: {name: entity.name.tag.yaml}
        2: {name: entity.name.tag.yaml}
        3: {name: entity.name.tag.yaml}
      patterns:
      - begin: '#'
        end: \Z|\n
        name: comment.line.number-sign.yaml
        beginCaptures:
          0: {name: punctuation.definition.comment.yaml}
      - include: '#scalars'
    - begin: ^[ \t]*((\d)+)(:)((?:(\![\w\!]+)\s+?)?|\Z|(?#))
      end: $
      name: meta.resource
      beginCaptures:
        1: {name: support.type.function.yaml}
        2: {name: support.type.function.yaml}
        3: {name: support.type.function.yaml}
      patterns:
      - begin: '#'
        end: \Z|\n
        name: comment.line.number-sign.yaml
        beginCaptures:
          0: {name: punctuation.definition.comment.yaml}
      - include: '#scalars'
    - begin: ^[ \t]*((?:securitySchemes|resourceTypes|annotationTypes|traits|get|post|put|patch|head|delete|options)\??)(:)((?:(\![\w\!]+)\s+?)?|\Z|(?#))
      end: $
      name: meta.method
      beginCaptures:
        1: {name: constant.character.method.yaml}
        2: {name: punctuation.colon.key-value.yaml}
        3: {name: support.type.tag.yaml}
      patterns:
      - begin: '#'
        end: \Z|\n
        name: comment.line.number-sign.yaml
        beginCaptures:
          0: {name: punctuation.definition.comment.yaml}
      - include: '#scalars'
    - begin: ^[ \t]*((?!\/)[^:]+)(:)((?:(\![\w\!]+)\s+?)?|\Z|(?#))
      end: $
      name: meta.key-value
      beginCaptures:
        1: {name: entity.name.function.yaml}
        2: {name: punctuation.colon.key-value.yaml}
        3: {name: support.type.tag.yaml}
      patterns:
      - begin: '#'
        end: \Z|\n
        name: comment.line.number-sign.yaml
        beginCaptures:
          0: {name: punctuation.definition.comment.yaml}
      - include: '#scalars'
      - include: '#includes'
      - include: '#resourceParameter'
    repository:
      includes:
        begin: '!include'
        end: \Z|\n|\s
        name: meta.key-value.include
        beginCaptures:
          0: {name: meta.key-value.include.path}
      markdown:
        patterns:
        - begin: '#'
          end: \Z|\n
          name: comment.line.number-sign.yaml
          beginCaptures:
            0: {name: punctuation.definition.comment.yaml}
        - include: '#ampersand'
        - include: '#bracket'
        - include: '#bold'
        - include: '#italic'
        - include: '#raw'
        - include: '#escape'
        - include: '#image-inline'
        - include: '#image-ref'
        - include: '#link-email'
        - include: '#link-inet'
        - include: '#link-inline'
        - include: '#link-ref'
        - include: '#link-ref-literal'
        repository:
          ampersand:
            match: '&(?!([a-zA-Z0-9]+|#[0-9]+|#x[0-9a-fA-F]+);)'
            name: meta.other.valid-ampersand.markdown
          bold:
            begin: |-
              (?x)
              (\*\*|__)(?=\S)                                             # Open
              (?=
              (
              <[^>]*>                                    # HTML tags
              | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*\k<raw>
              # Raw
              | \\[\\`*_{}\[\]()#.!+\->]?+                       # Escapes
              | \[
              (
              (?<square>                            # Named group
              [^\[\]\\]                               # Match most chars
              | \\.                                     # Escaped chars
              | \[ \g<square>* \]                 # Nested brackets
              )*
              \]
              (
              (                                       # Reference Link
              [ ]?                                # Optional space
              \[[^\]]*\]                          # Ref name
              )
              | (                                       # Inline Link
              \(                                  # Opening paren
              [ \t]*                          # Optional whtiespace
              <?(.*?)>?                 # URL
              [ \t]*                          # Optional whtiespace
              (                               # Optional Title
              (?<title>['"])
              (.*?)
              \k<title>
              )?
              \)
              )
              )
              )
              | (?!(?<=\S)\1).                                   # Everything besides
              # style closer
              )+
              (?<=\S)\1                                            # Close
              )
            end: (?<=\S)(\1)
            name: markup.bold.markdown
            captures:
              1: {name: punctuation.definition.bold.markdown}
            patterns:
            - applyEndPatternLast: 1
              begin: (?=<[^>]*?>)
              end: (?<=>)
              patterns:
              - include: text.html.basic
            - include: '#escape'
            - include: '#ampersand'
            - include: '#bracket'
            - include: '#raw'
            - include: '#italic'
            - include: '#image-inline'
            - include: '#link-inline'
            - include: '#link-inet'
            - include: '#link-email'
            - include: '#image-ref'
            - include: '#link-ref-literal'
            - include: '#link-ref'
          bracket:
            match: <(?![a-z/?\$!])
            name: meta.other.valid-bracket.markdown
          escape:
            match: \\[-`*_#+.!(){}\[\]\\>]
            name: constant.character.escape.markdown
          image-inline:
            match: |-
              (?x:
              \!                                  # Images start with !
              (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*\])*)(\])
              # Match the link text.
              ([ ])?                              # Space not allowed
              (\()                                # Opening paren for url
              (<?)(\S+?)(>?)                # The url
              [ \t]*                              # Optional whitespace
              (?:
              ((\().+?(\)))                 # Match title in parens
              | ((").+?("))         # or in quotes.
              )?                                  # Title is optional
              \s*                                 # Optional whitespace
              (\))
              )
            name: meta.image.inline.markdown
            captures:
              1: {name: punctuation.definition.string.begin.markdown}
              2: {name: string.other.link.description.markdown}
              4: {name: punctuation.definition.string.end.markdown}
              5: {name: invalid.illegal.whitespace.markdown}
              6: {name: punctuation.definition.metadata.markdown}
              7: {name: punctuation.definition.link.markdown}
              8: {name: markup.underline.link.image.markdown}
              9: {name: punctuation.definition.link.markdown}
              10: {name: string.other.link.description.title.markdown}
              11: {name: punctuation.definition.string.markdown}
              12: {name: punctuation.definition.string.markdown}
              13: {name: string.other.link.description.title.markdown}
              14: {name: punctuation.definition.string.markdown}
              15: {name: punctuation.definition.string.markdown}
              16: {name: punctuation.definition.metadata.markdown}
          image-ref:
            match: \!(\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*\])*)(\])[ ]?(\[)(.*?)(\])
            name: meta.image.reference.markdown
            captures:
              1: {name: punctuation.definition.string.begin.markdown}
              2: {name: string.other.link.description.markdown}
              4: {name: punctuation.definition.string.begin.markdown}
              5: {name: punctuation.definition.constant.markdown}
              6: {name: constant.other.reference.link.markdown}
              7: {name: punctuation.definition.constant.markdown}
          italic:
            begin: |-
              (?x)
              (\*|_)(?=\S)                                            # Open
              (?=
              (
              <[^>]*>                                # HTML tags
              | (?<raw>`+)([^`]|(?!(?<!`)\k<raw>(?!`))`)*\k<raw>
              # Raw
              | \\[\\`*_{}\[\]()#.!+\->]?+                   # Escapes
              | \[
              (
              (?<square>                            # Named group
              [^\[\]\\]                                # Match most chars
              | \\.                                     # Escaped chars
              | \[ \g<square>* \]                 # Nested brackets
              )*
              \]
              (
              (                                       # Reference Link
              [ ]?                                # Optional space
              \[[^\]]*\]                          # Ref name
              )
              | (                                       # Inline Link
              \(                                  # Opening paren
              [ \t]*                          # Optional whtiespace
              <?(.*?)>?                 # URL
              [ \t]*                          # Optional whtiespace
              (                               # Optional Title
              (?<title>['"])
              (.*?)
              \k<title>
              )?
              \)
              )
              )
              )
              | \1\1                                            # Must be bold closer
              | (?!(?<=\S)\1).                               # Everything besides
              # style closer
              )+
              (?<=\S)\1                                        # Close
              )
            end: (?<=\S)(\1)((?!\1)|(?=\1\1))
            name: markup.italic.markdown
            captures:
              1: {name: punctuation.definition.italic.markdown}
            patterns:
            - begin: '#'
              end: \Z|\n
              name: comment.line.number-sign.yaml
              beginCaptures:
                0: {name: punctuation.definition.comment.yaml}
            - applyEndPatternLast: 1
              begin: (?=<[^>]*?>)
              end: (?<=>)
              patterns:
              - include: text.html.basic
            - include: '#escape'
            - include: '#ampersand'
            - include: '#bracket'
            - include: '#raw'
            - include: '#bold'
            - include: '#image-inline'
            - include: '#link-inline'
            - include: '#link-inet'
            - include: '#link-email'
            - include: '#image-ref'
            - include: '#link-ref-literal'
            - include: '#link-ref'
          link-email:
            match: (<)((?:mailto:)?[-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(>)
            name: meta.link.email.lt-gt.markdown
            captures:
              1: {name: punctuation.definition.link.markdown}
              2: {name: markup.underline.link.markdown}
              4: {name: punctuation.definition.link.markdown}
          link-inet:
            match: (<)((?:https?|ftp)://.*?)(>)
            name: meta.link.inet.markdown
            captures:
              1: {name: punctuation.definition.link.markdown}
              2: {name: markup.underline.link.markdown}
              3: {name: punctuation.definition.link.markdown}
          link-inline:
            match: |-
              (?x:
              (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*\])*)(\])
              # Match the link text.
              ([ ])?                             # Space not allowed
              (\()                               # Opening paren for url
              (<?)(.*?)(>?)                # The url
              [ \t]*                             # Optional whitespace
              (?:
              ((\().+?(\)))                # Match title in parens
              | ((").+?("))        # or in quotes.
              )?                                 # Title is optional
              \s*                                # Optional whitespace
              (\))
              )
            name: meta.link.inline.markdown
            captures:
              1: {name: punctuation.definition.string.begin.markdown}
              2: {name: string.other.link.title.markdown}
              4: {name: punctuation.definition.string.end.markdown}
              5: {name: invalid.illegal.whitespace.markdown}
              6: {name: punctuation.definition.metadata.markdown}
              7: {name: punctuation.definition.link.markdown}
              8: {name: markup.underline.link.markdown}
              9: {name: punctuation.definition.link.markdown}
              10: {name: string.other.link.description.title.markdown}
              11: {name: punctuation.definition.string.begin.markdown}
              12: {name: punctuation.definition.string.end.markdown}
              13: {name: string.other.link.description.title.markdown}
              14: {name: punctuation.definition.string.begin.markdown}
              15: {name: punctuation.definition.string.end.markdown}
              16: {name: punctuation.definition.metadata.markdown}
          link-ref:
            match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*\])*)(\])[ ]?(\[)([^\]]*)(\])
            name: meta.link.reference.markdown
            captures:
              1: {name: punctuation.definition.string.begin.markdown}
              2: {name: string.other.link.title.markdown}
              4: {name: punctuation.definition.string.end.markdown}
              5: {name: punctuation.definition.constant.begin.markdown}
              6: {name: constant.other.reference.link.markdown}
              7: {name: punctuation.definition.constant.end.markdown}
          link-ref-literal:
            match: (\[)((?<square>[^\[\]\\]|\\.|\[\g<square>*\])*)(\])[ ]?(\[)(\])
            name: meta.link.reference.literal.markdown
            captures:
              1: {name: punctuation.definition.string.begin.markdown}
              2: {name: string.other.link.title.markdown}
              4: {name: punctuation.definition.string.end.markdown}
              5: {name: punctuation.definition.constant.begin.markdown}
              6: {name: punctuation.definition.constant.end.markdown}
          raw:
            match: (`+)([^`]|(?!(?<!`)\1(?!`))`)*(\1)
            name: markup.raw.inline.markdown
            captures:
              1: {name: punctuation.definition.raw.markdown}
              2: {}
              3: {name: punctuation.definition.raw.markdown}
      resourceParameter:
        begin: '<<'
        end: '>>'
        name: variable
        beginCaptures:
          0: {name: variable}
      scalars:
        patterns:
        - begin: '#'
          end: \Z|\n
          name: comment.line.number-sign.yaml
          beginCaptures:
            0: {name: punctuation.definition.comment.yaml}
        - include: '#boolean'
        - include: '#float'
        - include: '#int'
        - include: '#single-quote'
        - include: '#double-quote'
        - include: '#unquoted'
        repository:
          boolean:
            match: \b(y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF)\b
            captures:
              1: {name: constant.language.boolean.yaml}
          double-quote:
            match: (")([^"]*)(")
            captures:
              1: {name: punctuation.definition.string.begin.yaml}
              2: {name: string.double-quoted.yaml}
              3: {name: punctuation.definition.string.end.yaml}
          float:
            match: ([-+]?([0-9][0-9_]*)?\.[0-9.]*([eE][-+][0-9]+)?)|([-+]?[0-9][0-9_]*(:[0-5]?[0-9])+\.[0-9_]*)|([-+]?\.(inf|Inf|INF))|(\.(nan|NaN|NAN))
            captures:
              1: {name: constant.numeric.yaml}
          int:
            match: ([-+]?(0|[1-9][0-9_]*))
            captures:
              1: {name: constant.numeric.yaml}
          single-quote:
            match: (')([^']*)(')
            captures:
              1: {name: punctuation.definition.string.begin.yaml}
              2: {name: string.single-quoted.yaml}
              3: {name: punctuation.definition.string.end.yaml}
          unquoted:
            match: (.*?)(?=$)
            captures:
              1: {name: string.unquoted.yaml}
      uri:
        match: (.*?)(?=$)
        name: meta.link.inline.markdown
        captures:
          1: {name: support.type.tag.yaml}
  embedded-stylus:
    patterns:
    - include: '#comment'
    - include: '#at_rule'
    - include: '#language_keywords'
    - include: '#language_constants'
    - include: '#variable_declaration'
    - include: '#function'
    - include: '#selector'
    - include: '#declaration'
    - match: (\{)(\})
      name: meta.brace.curly.css
      captures:
        1: {name: punctuation.section.property-list.begin.css}
        2: {name: punctuation.section.property-list.end.css}
    - match: \{|\}
      name: meta.brace.curly.css
    - include: '#numeric'
    - include: '#string'
    - include: '#operator'
    repository:
      at_rule:
        patterns:
        - begin: \s*(@)(import|require)\b\s*
          end: \s*((?=;|$|\n))
          name: meta.at-rule.import.css
          beginCaptures:
            1: {name: punctuation.definition.keyword.stylus}
            2: {name: keyword.control.at-rule.import.stylus}
          endCaptures:
            1: {name: punctuation.terminator.rule.css}
          patterns:
          - include: '#string'
        - begin: \s*(@)(extend[s]?)\b\s*
          end: \s*((?=;|$|\n))
          name: meta.at-rule.extend.css
          beginCaptures:
            1: {name: punctuation.definition.keyword.stylus}
            2: {name: keyword.control.at-rule.extend.stylus}
          endCaptures:
            1: {name: punctuation.terminator.rule.css}
          patterns:
          - include: '#selector'
        - match: ^\s*(@)(font-face)\b
          name: meta.at-rule.fontface.stylus
          captures:
            1: {name: punctuation.definition.keyword.stylus}
            2: {name: keyword.control.at-rule.fontface.stylus}
        - match: ^\s*(@)(css)\b
          name: meta.at-rule.css.stylus
          captures:
            1: {name: punctuation.definition.keyword.stylus}
            2: {name: keyword.control.at-rule.css.stylus}
        - begin: \s*(@)(charset)\b\s*
          end: \s*((?=;|$|\n))
          name: meta.at-rule.charset.stylus
          beginCaptures:
            1: {name: punctuation.definition.keyword.stylus}
            2: {name: keyword.control.at-rule.charset.stylus}
          patterns:
          - include: '#string'
        - begin: \s*(@)(keyframes)\b\s+([a-zA-Z_-][a-zA-Z0-9_-]*)
          end: \s*((?=\{|$|\n))
          name: meta.at-rule.keyframes.stylus
          beginCaptures:
            1: {name: punctuation.definition.keyword.stylus}
            2: {name: keyword.control.at-rule.keyframes.stylus}
            3: {name: entity.name.function.keyframe.stylus}
        - begin: (?=(\b(\d+%|from\b|to\b)))
          end: (?=(\{|\n))
          name: meta.at-rule.keyframes.stylus
          patterns:
          - match: (\b(\d+%|from\b|to\b))
            name: entity.other.attribute-name.stylus
        - match: ^\s*(@)(media)\b
          name: meta.at-rule.media.stylus
          captures:
            1: {name: punctuation.definition.keyword.stylus}
            2: {name: keyword.control.at-rule.media.stylus}
        - match: (?:(?=\w)(?<![\w-]))(width|scan|resolution|orientation|monochrome|min-width|min-resolution|min-monochrome|min-height|min-device-width|min-device-height|min-device-aspect-ratio|min-color-index|min-color|min-aspect-ratio|max-width|max-resolution|max-monochrome|max-height|max-device-width|max-device-height|max-device-aspect-ratio|max-color-index|max-color|max-aspect-ratio|height|grid|device-width|device-height|device-aspect-ratio|color-index|color|aspect-ratio)(?:(?<=\w)(?![\w-]))
          name: support.type.property-name.media-feature.media.css
        - match: (?:(?=\w)(?<![\w-]))(tv|tty|screen|projection|print|handheld|embossed|braille|aural|all)(?:(?<=\w)(?![\w-]))
          name: support.constant.media-type.media.css
        - match: (?:(?=\w)(?<![\w-]))(portrait|landscape)(?:(?<=\w)(?![\w-]))
          name: support.constant.property-value.media-property.media.css
      char_escape:
        match: \\(.)
        name: constant.character.escape.stylus
      color:
        patterns:
        - begin: \b(rgb|rgba|hsl|hsla)(\()
          end: (\))
          name: meta.function.color.css
          beginCaptures:
            1: {name: support.function.color.css}
            2: {name: punctuation.section.function.css}
          endCaptures:
            1: {name: punctuation.section.function.css}
          patterns:
          - match: \s*(,)\s*
            name: punctuation.separator.parameter.css
          - include: '#numeric'
          - include: '#property_variable'
        - match: (#)([0-9a-fA-F]{3}|[0-9a-fA-F]{6})\b
          name: constant.other.color.rgb-value.css
          captures:
            1: {name: punctuation.definition.constant.css}
        - match: \b(aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)\b
          name: support.constant.color.w3c-standard-color-name.css
        - match: \b(aliceblue|antiquewhite|aquamarine|azure|beige|bisque|blanchedalmond|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|gainsboro|ghostwhite|gold|goldenrod|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|limegreen|linen|magenta|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|oldlace|olivedrab|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|thistle|tomato|turquoise|violet|wheat|whitesmoke|yellowgreen)\b
          name: support.constant.color.w3c-extended-color-name.css
      comment_block:
        begin: /\*
        end: \*/
        name: comment.block.css
        beginCaptures:
          0: {name: punctuation.definition.comment.begin.css}
        endCaptures:
          0: {name: punctuation.definition.comment.end.css}
      comment_line:
        begin: (^[ \t]+)?(?=//)
        end: (?!\G)
        beginCaptures:
          1: {name: punctuation.whitespace.comment.leading.stylus}
        patterns:
        - begin: //
          end: (?=\n)
          name: comment.line.double-slash.stylus
          beginCaptures:
            0: {name: punctuation.definition.comment.stylus}
      declaration:
        begin: ((?<=^)[^\S\n]+)|((?<=;)[^\S\n]*)|((?<=\{)[^\S\n]*)
        end: (?=\n)|(;)|(?=\})|(\n)
        name: meta.property-list.css
        endCaptures:
          2: {name: punctuation.terminator.rule.css}
        patterns:
        - include: '#language_keywords'
        - include: '#language_constants'
        - match: (?:(?<=^)[^\S\n]+(\n))
        - match: \G\s*(counter-reset|counter-increment)(?:(:)|[^\S\n])[^\S\n]*([a-zA-Z_-][a-zA-Z0-9_-]*)
          name: meta.property.counter.css
          captures:
            1: {name: support.type.property-name.css}
            2: {name: punctuation.separator.key-value.css}
            3: {name: variable.section.css}
        - begin: \G\s*(filter)(?:(:)|[^\S\n])[^\S\n]*
          end: (?=\n|;|\}|$)
          name: meta.property.filter.css
          beginCaptures:
            1: {name: support.type.property-name.css}
            2: {name: punctuation.separator.key-value.css}
          patterns:
          - include: '#function'
          - include: '#property_values'
        - include: '#property'
        - include: '#interpolation'
        - include: $self
      font_name:
        match: (\b(?i:arial|century|comic|courier|cursive|fantasy|futura|garamond|georgia|helvetica|impact|lucida|monospace|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif)\b)
        name: support.constant.font-name.css
      function:
        begin: (?=[a-zA-Z_-][a-zA-Z0-9_-]*\()
        end: (\))
        endCaptures:
          1: {name: punctuation.section.function.css}
        patterns:
        - begin: (format|url|local)(\()
          end: (?=\))
          name: meta.function.misc.css
          beginCaptures:
            1: {name: support.function.misc.css}
            2: {name: punctuation.section.function.css}
          patterns:
          - match: (?<=\()[^\)\s]*(?=\))
            name: string.css
          - include: '#string'
          - include: '#variable'
          - include: '#operator'
          - match: \s*
        - match: (counter)(\()([a-zA-Z_-][a-zA-Z0-9_-]*)(?=\))
          name: meta.function.misc.counter.css
          captures:
            1: {name: support.function.misc.counter.css}
            2: {name: punctuation.section.function.css}
            3: {name: variable.section.css}
        - begin: (counters)(\()
          end: (?=\))
          name: meta.function.misc.counters.css
          beginCaptures:
            1: {name: support.function.misc.counters.css}
            2: {name: punctuation.section.function.css}
          patterns:
          - match: \G[a-zA-Z_-][a-zA-Z0-9_-]*
            name: variable.section.css
          - match: \s*(,)\s*
            name: punctuation.separator.parameter.css
          - include: '#string'
          - include: '#interpolation'
        - begin: (attr)(\()
          end: (?=\))
          name: meta.function.misc.attr.css
          beginCaptures:
            1: {name: support.function.misc.attr.css}
            2: {name: punctuation.section.function.css}
          patterns:
          - match: \G[a-zA-Z_-][a-zA-Z0-9_-]*
            name: entity.other.attribute-name.attribute.css
          - match: (?<=[a-zA-Z0-9_-])\s*\b(string|color|url|integer|number|length|em|ex|px|rem|vw|vh|vmin|vmax|mm|cm|in|pt|pc|angle|deg|grad|rad|time|s|ms|frequency|Hz|kHz|%)\b
            name: support.type.attr.css
          - match: \s*(,)\s*
            name: punctuation.separator.parameter.css
          - include: '#string'
          - include: '#interpolation'
        - begin: (calc)(\()
          end: (?=\))
          name: meta.function.misc.calc.css
          beginCaptures:
            1: {name: support.function.misc.calc.css}
            2: {name: punctuation.section.function.css}
          patterns:
          - include: '#property_values'
        - begin: (cubic-bezier)(\()
          end: (?=\))
          name: meta.function.timing.cubic-bezier.css
          beginCaptures:
            1: {name: support.function.timing.cubic-bezier.css}
            2: {name: punctuation.section.function.css}
          patterns:
          - match: \s*(,)\s*
            name: punctuation.separator.parameter.css
          - include: '#numeric'
          - include: '#interpolation'
        - begin: (steps)(\()
          end: (?=\))
          name: meta.function.timing.steps.css
          beginCaptures:
            1: {name: support.function.timing.steps.css}
            2: {name: punctuation.section.function.css}
          patterns:
          - match: \s*(,)\s*
            name: punctuation.separator.parameter.css
          - include: '#numeric'
          - match: \b(start|end)\b
            name: support.constant.timing.steps.direction.css
          - include: '#interpolation'
        - begin: (linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient)(\()
          end: (?=\))
          name: meta.function.gradient.css
          beginCaptures:
            1: {name: support.function.gradient.css}
            2: {name: punctuation.section.function.css}
          patterns:
          - match: \s*(,)\s*
            name: punctuation.separator.parameter.css
          - include: '#numeric'
          - include: '#color'
          - match: \b(to|bottom|right|left|top|circle|ellipse|center|closest-side|closest-corner|farthest-side|farthest-corner|at)\b
            name: support.constant.gradient.css
          - include: '#interpolation'
        - begin: (blur|brightness|contrast|grayscale|hue-rotate|invert|opacity|saturate|sepia)(\()
          end: (?=\))
          name: meta.function.filter.css
          beginCaptures:
            1: {name: support.function.filter.css}
            2: {name: punctuation.section.function.css}
          patterns:
          - include: '#numeric'
          - include: '#property_variable'
          - include: '#interpolation'
        - begin: (drop-shadow)(\()
          end: (?=\))
          name: meta.function.filter.drop-shadow.css
          beginCaptures:
            1: {name: support.function.filter.drop-shadow.css}
            2: {name: punctuation.section.function.css}
          patterns:
          - include: '#numeric'
          - include: '#color'
          - include: '#property_variable'
          - include: '#interpolation'
        - begin: (matrix|matrix3d|perspective|rotate|rotate3d|rotate[Xx]|rotate[yY]|rotate[zZ]|scale|scale3d|scale[xX]|scale[yY]|scale[zZ]|skew|skew[xX]|skew[yY]|translate|translate3d|translate[xX]|translate[yY]|translate[zZ])(\()
          end: (?=\))
          name: meta.function.transform.css
          beginCaptures:
            1: {name: support.function.transform.css}
            2: {name: punctuation.section.function.css}
          patterns:
          - include: '#numeric'
          - include: '#property_variable'
          - include: '#interpolation'
        - match: (url|local|format|counter|counters|attr|calc)(?=\()
          name: support.function.misc.css
        - match: (cubic-bezier|steps)(?=\()
          name: support.function.timing.css
        - match: (linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient)(?=\()
          name: support.function.gradient.css
        - match: (blur|brightness|contrast|drop-shadow|grayscale|hue-rotate|invert|opacity|saturate|sepia)(?=\()
          name: support.function.filter.css
        - match: (matrix|matrix3d|perspective|rotate|rotate3d|rotate[Xx]|rotate[yY]|rotate[zZ]|scale|scale3d|scale[xX]|scale[yY]|scale[zZ]|skew|skew[xX]|skew[yY]|translate|translate3d|translate[xX]|translate[yY]|translate[zZ])(?=\()
          name: support.function.transform.css
        - begin: ([a-zA-Z_-][a-zA-Z0-9_-]*)(\()
          end: (?=\))
          name: meta.function.stylus
          beginCaptures:
            1: {name: entity.name.function.stylus}
            2: {name: punctuation.section.function.css}
          patterns:
          - match: \s*(,)\s*
            name: punctuation.separator.parameter.css
          - include: '#interpolation'
          - include: '#property_values'
        - match: \(
          name: punctuation.section.function.css
      interpolation:
        begin: (?:(\{)[^\S\n]*)(?=[^;=]*[^\S\n]*\})
        end: (?:[^\S\n]*(\}))|\n|$
        name: meta.interpolation.stylus
        beginCaptures:
          1: {name: meta.brace.curly}
        endCaptures:
          1: {name: meta.brace.curly}
        patterns:
        - include: '#variable'
        - include: '#numeric'
        - include: '#string'
        - include: '#operator'
      language_constants:
        match: \b(true|false|null)\b
        name: constant.language.stylus
      language_keywords:
        patterns:
        - match: (\b|\s)(return|else|for|unless|if|else)\b
          name: keyword.control.stylus
        - match: (\b|\s)(!important|in|is defined|is a)\b
          name: keyword.other.stylus
        - match: \barguments\b
          name: variable.language.stylus
      numeric:
        patterns:
        - match: (?x) (?<!\w|-)(?:(?:-|\+)?(?:[0-9]+(?:\.[0-9]+)?)|(?:\.[0-9]+)) ((?:px|pt|ch|cm|mm|in|r?em|ex|pc|deg|g?rad|dpi|dpcm|dppx|fr|ms|s|turn|vh|vmax|vmin|vw)\b|%)?
          name: constant.numeric.css
          captures:
            1: {name: keyword.other.unit.css}
      operator:
        patterns:
        - match: ((?:\?|:|!|~|\+|(\s-\s)|(?:\*)?\*|\/|%|(\.)?\.\.|<|>|(?:=|:|\?|\+|-|\*|\/|%|<|>)?=|!=)|\b(?:in|is(?:nt)?|(?<!:)not|or|and)\b)
          name: keyword.operator.stylus
        - include: '#char_escape'
      property:
        begin: |-
          (?x:\G\s*(?:
            (-webkit-[-A-Za-z]+|-moz-[-A-Za-z]+|-o-[-A-Za-z]+|-ms-[-A-Za-z]+|-khtml-[-A-Za-z]+|zoom|z-index|y|x|wrap|word-wrap|word-spacing|word-break|word|width|widows|white-space-collapse|white-space|white|weight|volume|voice-volume|voice-stress|voice-rate|voice-pitch-range|voice-pitch|voice-family|voice-duration|voice-balance|voice|visibility|vertical-align|variant|user-select|up|unicode-bidi|unicode-range|unicode|trim|transition-timing-function|transition-property|transition-duration|transition-delay|transition|transform|touch-action|top-width|top-style|top-right-radius|top-left-radius|top-color|top|timing-function|text-wrap|text-transform|text-shadow|text-replace|text-rendering|text-overflow|text-outline|text-justify|text-indent|text-height|text-emphasis|text-decoration|text-align-last|text-align|text|target-position|target-new|target-name|target|table-layout|tab-size|style-type|style-position|style-image|style|string-set|stretch|stress|stacking-strategy|stacking-shift|stacking-ruby|stacking|src|speed|speech-rate|speech|speak-punctuation|speak-numeral|speak-header|speak|span|spacing|space-collapse|space|sizing|size-adjust|size|shadow|respond-to|rule-width|rule-style|rule-color|rule|ruby-span|ruby-position|ruby-overhang|ruby-align|ruby|rows|rotation-point|rotation|role|right-width|right-style|right-color|right|richness|rest-before|rest-after|rest|resource|resize|reset|replace|repeat|rendering-intent|rate|radius|quotes|punctuation-trim|punctuation|property|profile|presentation-level|presentation|position|pointer-events|point|play-state|play-during|play-count|pitch-range|pitch|phonemes|pause-before|pause-after|pause|page-policy|page-break-inside|page-break-before|page-break-after|page|padding-top|padding-right|padding-left|padding-bottom|padding|pack|overhang|overflow-y|overflow-x|overflow-style|overflow|outline-width|outline-style|outline-offset|outline-color|outline|orphans|origin|orientation|orient|ordinal-group|order|opacity|offset|numeral|new|nav-up|nav-right|nav-left|nav-index|nav-down|nav|name|move-to|model|mix-blend-mode|min-width|min-height|min|max-width|max-height|max|marquee-style|marquee-speed|marquee-play-count|marquee-direction|marquee|marks|mark-before|mark-after|mark|margin-top|margin-right|margin-left|margin-bottom|margin|mask-image|list-style-type|list-style-position|list-style-image|list-style|list|lines|line-stacking-strategy|line-stacking-shift|line-stacking-ruby|line-stacking|line-height|line-break|level|letter-spacing|length|left-width|left-style|left-color|left|label|justify-content|justify|iteration-count|inline-box-align|initial-value|initial-size|initial-before-align|initial-before-adjust|initial-after-align|initial-after-adjust|index|indent|increment|image-resolution|image-orientation|image|icon|hyphens|hyphenate-resource|hyphenate-lines|hyphenate-character|hyphenate-before|hyphenate-after|hyphenate|height|header|hanging-punctuation|gap|grid|grid-area|grid-auto-columns|grid-auto-flow|grid-auto-rows|grid-column|grid-column-end|grid-column-start|grid-row|grid-row-end|grid-row-start|grid-template|grid-template-areas|grid-template-columns|grid-template-rows|row-gap|gap|font-kerning|font-language-override|font-weight|font-variant-caps|font-variant|font-style|font-synthesis|font-stretch|font-size-adjust|font-size|font-family|font|float-offset|float|flex-wrap|flex-shrink|flex-grow|flex-group|flex-flow|flex-direction|flex-basis|flex|fit-position|fit|fill|filter|family|empty-cells|emphasis|elevation|duration|drop-initial-value|drop-initial-size|drop-initial-before-align|drop-initial-before-adjust|drop-initial-after-align|drop-initial-after-adjust|drop|down|dominant-baseline|display-role|display-model|display|direction|delay|decoration-break|decoration|cursor|cue-before|cue-after|cue|crop|counter-reset|counter-increment|counter|count|content|columns|column-width|column-span|column-rule-width|column-rule-style|column-rule-color|column-rule|column-gap|column-fill|column-count|column-break-before|column-break-after|column|color-profile|color|collapse|clip|clear|character|caption-side|break-inside|break-before|break-after|break|box-sizing|box-shadow|box-pack|box-orient|box-ordinal-group|box-lines|box-flex-group|box-flex|box-direction|box-decoration-break|box-align|box|bottom-width|bottom-style|bottom-right-radius|bottom-left-radius|bottom-color|bottom|border-width|border-top-width|border-top-style|border-top-right-radius|border-top-left-radius|border-top-color|border-top|border-style|border-spacing|border-right-width|border-right-style|border-right-color|border-right|border-radius|border-length|border-left-width|border-left-style|border-left-color|border-left|border-image|border-color|border-collapse|border-bottom-width|border-bottom-style|border-bottom-right-radius|border-bottom-left-radius|border-bottom-color|border-bottom|border|bookmark-target|bookmark-level|bookmark-label|bookmark|binding|bidi|before|baseline-shift|baseline|balance|background-blend-mode|background-size|background-repeat|background-position|background-origin|background-image|background-color|background-clip|background-break|background-attachment|background|azimuth|attachment|appearance|animation-timing-function|animation-play-state|animation-name|animation-iteration-count|animation-duration|animation-direction|animation-delay|animation-fill-mode|animation|alignment-baseline|alignment-adjust|alignment|align-self|align-last|align-items|align-content|align|after|adjust|will-change)|
            (writing-mode|text-anchor|stroke-width|stroke-opacity|stroke-miterlimit|stroke-linejoin|stroke-linecap|stroke-dashoffset|stroke-dasharray|stroke|stop-opacity|stop-color|shape-rendering|marker-start|marker-mid|marker-end|lighting-color|kerning|image-rendering|glyph-orientation-vertical|glyph-orientation-horizontal|flood-opacity|flood-color|fill-rule|fill-opacity|fill|enable-background|color-rendering|color-interpolation-filters|color-interpolation|clip-rule|clip-path)|
            ([a-zA-Z_-][a-zA-Z0-9_-]*)
          )(?!([^\S\n]*&)|([^\S\n]*\{))(?=:|([^\S\n]+[^\s])))
        end: (;)|(?=\n|\}|$)
        beginCaptures:
          1: {name: support.type.property-name.css}
          2: {name: support.type.property-name.svg.css}
          3: {name: support.function.mixin.stylus}
        endCaptures:
          1: {name: punctuation.terminator.rule.css}
        patterns:
        - include: '#property_value'
      property_value:
        begin: \G(?:(:)|(\s))(\s*)(?!&)
        end: (?=\n|;|\})
        name: meta.property-value.css
        beginCaptures:
          1: {name: punctuation.separator.key-value.css}
          2: {name: punctuation.separator.key-value.css}
        endCaptures:
          1: {name: punctuation.terminator.rule.css}
        patterns:
        - include: '#property_values'
        - match: '[^\n]+?'
      property_values:
        patterns:
        - include: '#function'
        - include: '#comment'
        - include: '#language_keywords'
        - include: '#language_constants'
        - match: (?:(?=\w)(?<![\w-]))(wrap-reverse|wrap|whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|unicase|underline|ultra-expanded|ultra-condensed|transparent|transform|top|titling-caps|thin|thick|text-top|text-bottom|text|tb-rl|table-row-group|table-row|table-header-group|table-footer-group|table-column-group|table-column|table-cell|table|sw-resize|super|strict|stretch|step-start|step-end|static|square|space-between|space-around|space|solid|soft-light|small-caps|separate|semi-expanded|semi-condensed|se-resize|scroll|screen|saturation|s-resize|running|rtl|row-reverse|row-resize|row|round|right|ridge|reverse|repeat-y|repeat-x|repeat|relative|progressive|progress|pre-wrap|pre-line|pre|pointer|petite-caps|paused|pan-x|pan-left|pan-right|pan-y|pan-up|pan-down|padding-box|overline|overlay|outside|outset|optimizeSpeed|optimizeLegibility|opacity|oblique|nw-resize|nowrap|not-allowed|normal|none|no-repeat|no-drop|newspaper|ne-resize|n-resize|multiply|move|middle|medium|max-height|manipulation|main-size|luminosity|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|local|list-item|linear(?!-)|line-through|line-edge|line|lighter|lighten|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline-block|inline|inherit|infinite|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|hue|horizontal|hidden|help|hard-light|hand|groove|geometricPrecision|forwards|flex-start|flex-end|flex|fixed|extra-expanded|extra-condensed|expanded|exclusion|ellipsis|ease-out|ease-in-out|ease-in|ease|e-resize|double|dotted|distribute-space|distribute-letter|distribute-all-lines|distribute|disc|disabled|difference|default|decimal|dashed|darken|currentColor|crosshair|cover|content-box|contain|condensed|column-reverse|column|color-dodge|color-burn|color|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|border-box|bolder|bold|block|bidi-override|below|baseline|balance|backwards|auto|antialiased|always|alternate-reverse|alternate|all-small-caps|all-scroll|all-petite-caps|all|absolute)(?:(?<=\w)(?![\w-]))
          name: support.constant.property-value.css
        - match: (?:(?=\w)(?<![\w-]))(start|sRGB|square|round|optimizeSpeed|optimizeQuality|nonzero|miter|middle|linearRGB|geometricPrecision |evenodd |end |crispEdges|butt|bevel)(?:(?<=\w)(?![\w-]))
          name: support.constant.property-value.svg.css
        - include: '#font_name'
        - include: '#numeric'
        - include: '#color'
        - include: '#string'
        - match: \!\s*important
          name: keyword.other.important.css
        - include: '#operator'
        - include: '#stylus_keywords'
        - include: '#property_variable'
      property_variable:
        patterns:
        - include: '#variable'
        - match: (?<!^)(\@[a-zA-Z_-][a-zA-Z0-9_-]*)
          name: variable.property.stylus
      selector:
        patterns:
        - match: (?:(?=\w)(?<![\w-]))(a|abbr|acronym|address|area|article|aside|audio|b|base|bdi|bdo|big|blockquote|body|br|button|canvas|caption|cite|code|col|colgroup|data|datalist|dd|del|details|dfn|dialog|div|dl|dt|em|embed|eventsource|fieldset|figure|figcaption|footer|form|frame|frameset|(h[1-6])|head|header|hgroup|hr|html|i|iframe|img|input|ins|kbd|keygen|label|legend|li|link|main|map|mark|math|menu|menuitem|meta|meter|nav|noframes|noscript|object|ol|optgroup|option|output|p|param|picture|pre|progress|q|rb|rp|rt|rtc|ruby|s|samp|script|section|select|small|source|span|strike|strong|style|sub|summary|sup|svg|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video|wbr)(?:(?<=\w)(?![\w-]))
          name: entity.name.tag.css
        - match: (?:(?=\w)(?<![\w-]))(vkern|view|use|tspan|tref|title|textPath|text|symbol|switch|svg|style|stop|set|script|rect|radialGradient|polyline|polygon|pattern|path|mpath|missing-glyph|metadata|mask|marker|linearGradient|line|image|hkern|glyphRef|glyph|g|foreignObject|font-face-uri|font-face-src|font-face-name|font-face-format|font-face|font|filter|feTurbulence|feTile|feSpotLight|feSpecularLighting|fePointLight|feOffset|feMorphology|feMergeNode|feMerge|feImage|feGaussianBlur|feFuncR|feFuncG|feFuncB|feFuncA|feFlood|feDistantLight|feDisplacementMap|feDiffuseLighting|feConvolveMatrix|feComposite|feComponentTransfer|feColorMatrix|feBlend|ellipse|desc|defs|cursor|color-profile|clipPath|circle|animateTransform|animateMotion|animateColor|animate|altGlyphItem|altGlyphDef|altGlyph|a)(?:(?<=\w)(?![\w-]))
          name: entity.name.tag.svg.css
        - match: \s*(\,)\s*
          name: meta.selector.stylus
        - match: \*
          name: meta.selector.stylus
        - match: \s*(\&)([a-zA-Z0-9_-]+)\s*
          name: meta.selector.stylus
          captures:
            2: {name: entity.other.attribute-name.parent-selector-suffix.stylus}
        - match: \s*(\&)\s*
          name: meta.selector.stylus
        - match: (\.)[a-zA-Z0-9_-]+
          name: entity.other.attribute-name.class.css
          captures:
            1: {name: punctuation.definition.entity.css}
        - match: (#)[a-zA-Z][a-zA-Z0-9_-]*
          name: entity.other.attribute-name.id.css
          captures:
            1: {name: punctuation.definition.entity.css}
        - match: (:+)(after|before|content|first-letter|first-line|host|(-(moz|webkit|ms)-)?selection)\b
          name: entity.other.attribute-name.pseudo-element.css
          captures:
            1: {name: punctuation.definition.entity.css}
        - match: (:)((first|last)-child|(first|last|only)-of-type|empty|root|target|first|left|right)\b
          name: entity.other.attribute-name.pseudo-class.css
          captures:
            1: {name: punctuation.definition.entity.css}
        - match: (:)(checked|enabled|default|disabled|indeterminate|invalid|optional|required|valid)\b
          name: entity.other.attribute-name.pseudo-class.ui-state.css
          captures:
            1: {name: punctuation.definition.entity.css}
        - begin: ((:)not)(\()
          end: \)
          beginCaptures:
            1: {name: entity.other.attribute-name.pseudo-class.css}
            2: {name: punctuation.definition.entity.css}
            3: {name: punctuation.section.function.css}
          endCaptures:
            0: {name: punctuation.section.function.css}
          patterns:
          - include: '#selector'
        - match: ((:)nth-(?:(?:last-)?child|(?:last-)?of-type))(\()(\-?(?:\d+n?|n)(?:\+\d+)?|even|odd)(\))
          captures:
            1: {name: entity.other.attribute-name.pseudo-class.css}
            2: {name: punctuation.definition.entity.css}
            3: {name: punctuation.section.function.css}
            4: {name: constant.numeric.css}
            5: {name: punctuation.section.function.css}
        - match: ((:)dir)\s*(?:(\()(ltr|rtl)?(\)))?
          captures:
            1: {name: entity.other.attribute-name.pseudo-class.css}
            2: {name: puncutation.definition.entity.css}
            3: {name: punctuation.section.function.css}
            4: {name: constant.language.css}
            5: {name: punctuation.section.function.css}
        - match: ((:)lang)\s*(?:(\()(\w+(-\w+)?)?(\)))?
          captures:
            1: {name: entity.other.attribute-name.pseudo-class.css}
            2: {name: puncutation.definition.entity.css}
            3: {name: punctuation.section.function.css}
            4: {name: constant.language.css}
            6: {name: punctuation.section.function.css}
        - match: (:)(active|hover|link|visited|focus)\b
          name: entity.other.attribute-name.pseudo-class.css
          captures:
            1: {name: punctuation.definition.entity.css}
        - match: (::)(shadow)\b
          name: entity.other.attribute-name.pseudo-class.css
          captures:
            1: {name: punctuation.definition.entity.css}
        - match: (?i)(\[)\s*(-?[_a-z\\[[:^ascii:]]][_a-z0-9\-\\[[:^ascii:]]]*)(?:\s*([~|^$*]?=)\s*(?:(-?[_a-z\\[[:^ascii:]]][_a-z0-9\-\\[[:^ascii:]]]*)|((?>(['"])(?:[^\\]|\\.)*?(\6)))))?\s*(\])
          name: meta.attribute-selector.css
          captures:
            1: {name: punctuation.definition.entity.css}
            2: {name: entity.other.attribute-name.attribute.css}
            3: {name: punctuation.separator.operator.css}
            4: {name: string.unquoted.attribute-value.css}
            5: {name: string.quoted.double.attribute-value.css}
            6: {name: punctuation.definition.string.begin.css}
            7: {name: punctuation.definition.string.end.css}
            8: {name: punctuation.definition.entity.css}
        - include: '#interpolation'
        - include: '#variable'
      string:
        patterns:
        - begin: '"'
          end: '"'
          name: string.quoted.double.css
          beginCaptures:
            0: {name: punctuation.definition.string.begin.css}
          endCaptures:
            0: {name: punctuation.definition.string.end.css}
          patterns:
          - match: \\([a-fA-F0-9]{1,6}|.)
            name: constant.character.escape.css
        - begin: ''''
          end: ''''
          name: string.quoted.single.css
          beginCaptures:
            0: {name: punctuation.definition.string.begin.css}
          endCaptures:
            0: {name: punctuation.definition.string.end.css}
          patterns:
          - match: \\([a-fA-F0-9]{1,6}|.)
            name: constant.character.escape.css
      variable:
        match: (\$[a-zA-Z_-][a-zA-Z0-9_-]*)
        name: variable.stylus
      variable_declaration:
        begin: ^[^\S\n]*(\$?[a-zA-Z_-][a-zA-Z0-9_-]*)[^\S\n]*(\=|\?\=|\:\=)
        end: (\n)|(;)|(?=\})
        beginCaptures:
          1: {name: variable.stylus}
          2: {name: keyword.operator.stylus}
        endCaptures:
          2: {name: punctuation.terminator.rule.css}
        patterns:
        - include: '#property_values'
  es7-decorators:
    patterns:
    - applyEndPatternLast: 1
      begin: (?<!@)\s*+(?:(@)(\#?)(?:((?:[\p{Lu}\p{Nl}])(?:[_\\\p{L}\p{M}\p{N}])*+)|((?:[_\\\p{L}\p{Nl}])(?:[_\\\p{L}\p{M}\p{N}])*+)))
      end: (?=.)
      beginCaptures:
        1: {name: keyword.operator.decorator.nova}
        2: {name: keyword.operator.private.nova}
        3: {name: entity.name.class.decorator.nova}
        4: {name: variable.other.readwrite.decorator.nova}
      patterns:
      - begin: \s*(?:(\?\.)|(\.))
        commnent: decorator .property or .method which may be on a different line
        end: \s*(\#?)(?:((?:[\p{Lu}\p{Nl}])(?:[_\\\p{L}\p{M}\p{N}])*+)|((?:[_\\\p{L}\p{Nl}])(?:[_\\\p{L}\p{M}\p{N}])*+))
        beginCaptures:
          1: {name: keyword.operator.existential.nova}
          2: {name: keyword.operator.accessor.nova}
        endCaptures:
          1: {name: keyword.operator.private.nova}
          2: {name: entity.name.class.decorator.nova}
          3: {name: variable.other.property.decorator.nova}
        patterns:
        - include: '#comments'
      - include: '#round-brackets'
      - begin: (?:(?<=^|;)|(?=\s))\s*+(\bstatic\b)?\s*+(\basync\b)?\s*+(\*?)\s*+(?<![\#\.])(\#?)((?:[_\\\p{L}\p{Nl}])(?:[_\\\p{L}\p{M}\p{N}])*+)\s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?(\())
        end: (?<=:|})|(?=;|}|,)
        name: meta.function.method.nova
        beginCaptures:
          1: {name: storage.modifier.nova}
          2: {name: storage.type.nova}
          3: {name: keyword.generator.asterisk.nova}
          4: {name: keyword.operator.private.nova}
          5: {name: entity.name.function.method.nova}
        patterns:
        - include: '#types'
        - include: '#curly-brackets'
        - include: '#core'
        - include: $self
      - include: '#comments'
      - match: \s*
  es7-function-bind:
    patterns:
    - match: \s*(::)
      captures:
        1: {name: keyword.operator.accessor.nova}
  esnext-pipeline:
    patterns:
    - applyEndPatternLast: 1
      begin: \s*(\+>)(?=\s*(\#?)(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\??\.?\#?)++\s*([^(]|$|;))
      end: (?=.)
      beginCaptures:
        1: {name: keyword.operator.pipeline.nova}
      patterns:
      - match: (?<=\+>)\s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)(\#?)(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))(?!\?|\.)
        captures:
          2: {name: keyword.operator.private.nova}
          3: {name: meta.function-call.without-arguments.nova}
          4: {patterns: [{include: '#function-name'}]}
      - match: \s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)(\#?)(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))(?!\?|\.)
        captures:
          2: {name: keyword.operator.private.nova}
          3: {name: meta.method-call.without-arguments.nova}
          4: {patterns: [{include: '#method-name'}]}
      - match: \s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(\??)(\.?)
        captures:
          2: {name: keyword.operator.private.nova}
          3: {name: variable.other.object.nova}
          4: {name: keyword.operator.existential.nova}
          5: {name: keyword.operator.accessor.nova}
      - include: '#comments'
    - applyEndPatternLast: 1
      begin: \s*(\|>)(?=\s*(\#?)(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\??\.?\#?)++\s*([^(]|$|;))
      end: (?=.)
      beginCaptures:
        1: {name: keyword.operator.pipeline.nova}
      patterns:
      - match: (?<=\|>)\s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)(\#?)(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))(?!\?|\.)
        captures:
          2: {name: keyword.operator.private.nova}
          3: {name: meta.function-call.without-arguments.nova}
          4: {patterns: [{include: '#function-name'}]}
      - match: \s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)(\#?)(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))(?!\?|\.)
        captures:
          2: {name: keyword.operator.private.nova}
          3: {name: meta.method-call.without-arguments.nova}
          4: {patterns: [{include: '#method-name'}]}
      - match: \s*(?!\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(\??)(\.?)
        captures:
          2: {name: keyword.operator.private.nova}
          3: {name: variable.other.object.nova}
          4: {name: keyword.operator.existential.nova}
          5: {name: keyword.operator.accessor.nova}
      - include: '#comments'
    - match: \s*(\|>|\+>)
      captures:
        1: {name: keyword.operator.pipeline.nova}
  fat-arrow:
    patterns:
    - applyEndPatternLast: 1
      begin: \s*(=>)
      end: (?=.)
      beginCaptures:
        1: {name: storage.type.function.arrow.nova}
      patterns:
      - include: $self
  fat-arrow-braced-body:
    begin: \s*(=>)\s*({)
    end: \s*(})
    beginCaptures:
      1: {name: storage.type.function.arrow.nova}
      2: {name: meta.brace.curly.nova}
    endCaptures:
      1: {name: meta.brace.curly.nova}
    patterns:
    - include: $self
  function:
    patterns:
    - applyEndPatternLast: 1
      begin: \s*+(?:\b(async)\b\s+)?\s*+(?:(?<=\.\.\.)|(?<![\#\.]))(\b(?:defn?|func?|fn|proc|macro)\b)\s*+(\*?)\s*+(#?(?:[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*|[\p{S}\p{Po}\p{Pd}&&[^,;'"`<\/>\\$]]+|'(?:\\'|[^'])*'|"(?:\\"|[^"])*"|`(?:``|[^`])*`))?(?=\s*+(\(|<))
      end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
      beginCaptures:
        1: {name: storage.type.nova}
        2: {name: storage.type.function.nova}
        3: {name: keyword.generator.asterisk.nova}
        4: {patterns: [{include: '#function-name'}]}
      endCaptures:
        1: {name: keyword.operator.assignment.nova}
      patterns:
      - include: '#types'
      - include: '#core'
      - include: '#curly-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(\#?)(#?(?:[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*|[\p{S}\p{Po}\p{Pd}&&[^,;'"`<\/>\\$]]+|'(?:\\'|[^'])*'|"(?:\\"|[^"])*"|`(?:``|[^`])*`))\s*+(=)\s*+(?:(async)\s+)?\s*+((?<![\#\.])\b(?:defn?|func?|fn|proc|macro)\b)\s*+(\*?)\s*+(#?(?:[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*|[\p{S}\p{Po}\p{Pd}&&[^,;'"`<\/>\\$]]+|'(?:\\'|[^'])*'|"(?:\\"|[^"])*"|`(?:``|[^`])*`))?(?=\s*+(\(|<))
      end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
      beginCaptures:
        1: {name: keyword.operator.private.nova}
        2: {patterns: [{include: '#function-name'}]}
        3: {name: keyword.operator.assignment.nova}
        4: {name: storage.type.nova}
        5: {name: storage.type.function.nova}
        6: {name: keyword.generator.asterisk.nova}
        7: {patterns: [{include: '#function-name'}]}
      endCaptures:
        1: {name: keyword.operator.assignment.nova}
      patterns:
      - include: '#types'
      - include: '#core'
      - include: '#curly-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(\#?)((?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}])(?:[_\\\p{L}\p{M}\p{N}])*+)(?:(\?\.)|(\.))(proto)(?:(\?\.)|(\.))(\#?)(#?(?:[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*|[\p{S}\p{Po}\p{Pd}&&[^,;'"`<\/>\\$]]+|'(?:\\'|[^'])*'|"(?:\\"|[^"])*"|`(?:``|[^`])*`))\s*+(=)\s*+(?:(async)\s+)?\s*+((?<![\#\.])\b(?:defn?|func?|fn|proc|macro)\b)\s*+(\*?)\s*+(#?(?:[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*|[\p{S}\p{Po}\p{Pd}&&[^,;'"`<\/>\\$]]+|'(?:\\'|[^'])*'|"(?:\\"|[^"])*"|`(?:``|[^`])*`))?(?=\s*+(\(|<))
      end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
      beginCaptures:
        1: {name: keyword.operator.private.nova}
        2: {name: entity.name.class.nova}
        3: {name: keyword.operator.existential.nova}
        4: {name: keyword.operator.accessor.nova}
        5: {name: variable.language.prototype.nova}
        6: {name: keyword.operator.existential.nova}
        7: {name: keyword.operator.accessor.nova}
        8: {name: keyword.operator.private.nova}
        9: {patterns: [{include: '#function-name'}]}
        10: {name: keyword.operator.assignment.nova}
        11: {name: storage.type.nova}
        12: {name: storage.type.function.nova}
        13: {name: keyword.generator.asterisk.nova}
        14: {patterns: [{include: '#function-name'}]}
      endCaptures:
        1: {name: keyword.operator.assignment.nova}
      patterns:
      - include: '#types'
      - include: '#core'
      - include: '#curly-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(\#?)((?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}])(?:[_\\\p{L}\p{M}\p{N}])*+)(?:(\?\.)|(\.))(\#?)(#?(?:[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*|[\p{S}\p{Po}\p{Pd}&&[^,;'"`<\/>\\$]]+|'(?:\\'|[^'])*'|"(?:\\"|[^"])*"|`(?:``|[^`])*`))\s*+(=)\s*+(?:(async)\s+)?\s*+((?<![\#\.])\b(?:defn?|func?|fn|proc|macro)\b)\s*+(\*?)\s*+(#?(?:[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*|[\p{S}\p{Po}\p{Pd}&&[^,;'"`<\/>\\$]]+|'(?:\\'|[^'])*'|"(?:\\"|[^"])*"|`(?:``|[^`])*`))?(?=\s*+(\(|<))
      end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
      name: meta.function.static.nova
      beginCaptures:
        1: {name: keyword.operator.private.nova}
        2: {name: entity.name.class.nova}
        3: {name: keyword.operator.existential.nova}
        4: {name: keyword.operator.accessor.nova}
        5: {name: keyword.operator.private.nova}
        6: {patterns: [{include: '#function-name'}]}
        7: {name: keyword.operator.assignment.nova}
        8: {name: storage.type.nova}
        9: {name: storage.type.function.nova}
        10: {name: keyword.generator.asterisk.nova}
        11: {patterns: [{include: '#function-name'}]}
      endCaptures:
        1: {name: keyword.operator.assignment.nova}
      patterns:
      - include: '#types'
      - include: '#core'
      - include: '#curly-brackets'
  function-call:
    patterns:
    - include: '#comments'
    - match: (?<![\#\.])\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?(\()\s*+(\)))
      name: meta.new-class.without-arguments.nova
      captures:
        1: {name: keyword.operator.new.nova}
        2: {name: meta.function-call.without-arguments.nova}
        3: {name: keyword.operator.private.nova}
        4: {name: entity.name.type.instance.nova}
        5: {name: keyword.operator.existential.nova}
        6: {name: keyword.operator.cascade.nova}
        7: {name: keyword.operator.assertion.nova}
        8: {name: keyword.operator.accessor.nova}
        9: {name: meta.brace.round.nova}
        10: {name: meta.brace.round.nova}
    - applyEndPatternLast: 1
      begin: (?<![\#\.])\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)\s*+(\()\s*+(\))))
      end: (?=.)
      name: meta.new-class.without-arguments.nova
      beginCaptures:
        1: {name: keyword.operator.new.nova}
        2: {name: meta.function-call.without-arguments.nova}
        3: {name: keyword.operator.private.nova}
        4: {name: entity.name.type.instance.nova}
        5: {name: keyword.operator.existential.nova}
        6: {name: keyword.operator.cascade.nova}
        7: {name: keyword.operator.assertion.nova}
        8: {name: keyword.operator.accessor.nova}
      patterns:
      - include: '#type-argument-brackets'
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: (?<![\#\.])\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\())
      end: (?=.)
      name: meta.new-class.with-arguments.nova
      beginCaptures:
        1: {name: keyword.operator.new.nova}
        2: {name: meta.function-call.with-arguments.nova}
        3: {name: keyword.operator.private.nova}
        4: {name: entity.name.type.instance.nova}
        5: {name: keyword.operator.existential.nova}
        6: {name: keyword.operator.cascade.nova}
        7: {name: keyword.operator.assertion.nova}
        8: {name: keyword.operator.accessor.nova}
      patterns:
      - include: '#type-argument-brackets'
      - include: '#round-brackets'
    - include: '#operators'
    - match: (?<![\#\.])\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?(\()\s*+(\))
      name: meta.function-call.without-arguments.nova
      captures:
        1: {name: keyword.operator.private.nova}
        2: {patterns: [{include: '#function-name'}]}
        3: {name: keyword.operator.existential.nova}
        4: {name: keyword.operator.cascade.nova}
        5: {name: keyword.operator.assertion.nova}
        6: {name: keyword.operator.accessor.nova}
        7: {name: meta.brace.round.nova}
        8: {name: meta.brace.round.nova}
    - applyEndPatternLast: 1
      begin: (?<![\#\.])\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)\s*+(\()\s*+(\)))
      end: (?=.)
      name: meta.function-call.without-arguments.nova
      beginCaptures:
        1: {name: keyword.operator.private.nova}
        2: {patterns: [{include: '#function-name'}]}
        3: {name: keyword.operator.existential.nova}
        4: {name: keyword.operator.cascade.nova}
        5: {name: keyword.operator.assertion.nova}
        6: {name: keyword.operator.accessor.nova}
      patterns:
      - include: '#type-argument-brackets'
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: (?<![\#\.])\s*+((\bnew\b)*)\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(?=\s*(\[(?:(?>[^\[\]]+)|\g<-1>)*\])\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\(\s*+\))
      end: (?=.)
      name: meta.function-call.without-arguments.nova
      beginCaptures:
        2: {name: keyword.operator.new.nova}
        3: {name: keyword.operator.private.nova}
        4: {name: variable.other.object.nova}
      patterns:
      - include: '#square-brackets'
      - include: '#type-argument-brackets'
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: (?<![\#\.])\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?:(\?\.)|(~\.|::)|(!\.)|(::|\.))?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\()
      end: (?=.)
      name: meta.function-call.with-arguments.nova
      beginCaptures:
        1: {name: keyword.operator.private.nova}
        2: {patterns: [{include: '#function-name'}]}
        3: {name: keyword.operator.existential.nova}
        4: {name: keyword.operator.cascade.nova}
        5: {name: keyword.operator.assertion.nova}
        6: {name: keyword.operator.accessor.nova}
      patterns:
      - include: '#type-argument-brackets'
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: (?<![\#\.])\s*+((\bnew\b)*)\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\g<-1>)*\])\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\()
      end: (?=.)
      name: meta.function-call.with-arguments.nova
      beginCaptures:
        2: {name: keyword.operator.new.nova}
        3: {name: keyword.operator.private.nova}
        4: {name: variable.other.object.nova}
      patterns:
      - include: '#square-brackets'
      - include: '#type-argument-brackets'
      - include: '#round-brackets'
    - include: '#keywords'
  function-labels:
    patterns:
    - begin: (?<=^|{|,)\s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(:)\s*+(?:(async)\s+)?\s*+((?<![\#\.])\b(?:defn?|func?|fn|proc|macro)\b)\s*+(?:(\*)\s*)?(?=\s*(\(|<))
      end: \s*(=)|\s*(?<=})
      name: meta.function.json.nova
      beginCaptures:
        1: {patterns: [{include: '#function-name'}]}
        2: {name: punctuation.separator.key-value.nova}
        3: {name: storage.type.nova}
        4: {name: storage.type.function.nova, patterns: [{include: '#string-content'}]}
        5: {name: keyword.generator.asterisk.nova}
      endCaptures:
        1: {name: keyword.operator.assignment.nova}
      patterns:
      - include: '#types'
      - include: '#core'
      - include: '#curly-brackets'
    - begin: (?<=^|{|,)\s*+(('|")([^"']*)(\k<-3>))\s*+(:)\s*+(async)?\s*+((?<![\#\.])\b(?:defn?|func?|fn|proc|macro)\b)\s*(\*\s*)?(?=\s*(\(|<))
      end: \s*(=)|\s*(?<=})
      name: meta.function.json.nova
      beginCaptures:
        1: {name: string.quoted.nova}
        2: {name: punctuation.definition.string.begin.nova}
        3: {patterns: [{include: '#function-name'}]}
        4: {name: punctuation.definition.string.end.nova}
        5: {name: punctuation.separator.key-value.nova}
        6: {name: storage.type.nova}
        7: {name: storage.type.function.nova}
        8: {name: keyword.generator.asterisk.nova}
      endCaptures:
        1: {name: keyword.operator.assignment.nova}
      patterns:
      - include: '#types'
      - include: '#core'
      - include: '#curly-brackets'
  function-name:
    patterns:
    - include: '#support-functions'
    - include: '#support-methods'
    - match: (?i)(?<![\#\.])\s*+\b((?>bool|int|float|[nr]at|real|imag|cmp|num|char|rune|str|sym|regex|re|func|[usn]?(?:byte|short|int|long|cent)|[ci]?(?:half|float|double|quad|oct)))\b
      captures:
        1: {name: support.type.builtin.primitive.nova}
    - match: (?i)(?<![\#\.])\s*+\b((?>this|any|void|empty|object|list|set|map|dict|array|tuple|record|seq|dict|unit|buff|mixed|mix))\b
      captures:
        1: {name: support.type.builtin.nova}
    - match: \b(WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|String|SIMD.Uint8x16|SIMD.Uint32x4|SIMD.Uint16x8|SIMD.Int8x16|SIMD.Int32x4|SIMD.Int16x8|SIMD.Float64x2|SIMD.Float32x4|SIMD.Bool8x16|SIMD.Bool64x2|SIMD.Bool32x4|SIMD.Bool16x8|SIMD|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|Number|NaN|Math|Map|JSON|Intl.NumberFormat|Intl.DateTimeFormat|Intl.Collator|Intl|InternalError|Int8Array|Int32Array|Int16Array|Infinity|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array)\b
      name: support.type.builtin.class.nova
    - match: (([a-zA-Z])[_\\\p{L}\p{M}\p{N}]*)
      name: entity.name.function.$2.nova
    - match: '[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{L}\p{M}\p{N}]*'
      name: support.type.class.nova
    - match: '[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*'
      name: entity.name.function.nova
    - match: |-
        (?x)(?<=['"`])(?:
          ([\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+(?<![!~<=>:])=) #1
          |(\+\++|--+) #2
          |(\+|-(?!>)|\*{1,3}|(?<!<)/(?!>)|\#|~/(?!>)|%%?|\*>|<\*) #3
          |(&&|\|\||\^\^|\\/|/\\) #4
          |([&^]|\|(?!>)|~(?![!=<>])) #5
          |(=\.\.|\.\.=|=\.=|\.\.(?!\.)) #6
          |(<[|+]|[|+]>)|(<<+|>>+) #7-8
          |([<>]:|:[<>]|[<>]:[<>]) #9
          |([!=~]+~|~[!=~]+|[<~>]+~|~[<~>]+) #10
          |(->|<-)|(<=>|[<>]=?)|(=[!:]=|[!=]==?) #11-13
          |(!\?|\?!|!!)|(\?\??)|(\?:)|(!:)|(\.\.\.) #14-18
          |(\?\.|(?<=[_\\\p{M}\p{L}\p{N}\p{Pe}?])\?(?![.:])(?=\B)) #19
          |(!\.|(?<=[_\\\p{M}\p{L}\p{N}\p{Pe}!])\!(?![.:])(?=\B)) #20
          |(~\.)|((?<!(?<!\.\.)\.)\.(?!=)|:::?)|((?:\.|::?)?=) #21-23
          |(=<|<[/*+]?>) #24
        )(?=['"`])
      name: keyword.operator.builtin.nova
      captures:
        1: {name: keyword.operator.assignment.augmented.nova}
        2: {name: keyword.operator.crement.nova}
        3: {name: keyword.operator.arithmetic.nova}
        4: {name: keyword.operator.logical.nova}
        5: {name: keyword.operator.bitwise.nova}
        6: {name: keyword.operator.range.nova}
        7: {name: keyword.operator.pipeline.nova}
        8: {name: keyword.operator.bitwise.shift.nova}
        9: {name: keyword.operator.class.nova}
        10: {name: keyword.operator.similarity.nova}
        11: {name: keyword.operator.then.nova}
        12: {name: keyword.operator.relational.nova}
        13: {name: keyword.operator.comparison.nova}
        14: {name: keyword.operator.nonnull.nova}
        15: {name: keyword.operator.nullcoalesce.nova}
        16: {name: keyword.operator.ternary.nova}
        17: {name: keyword.operator.quasiternary.nova}
        18: {name: keyword.operator.spread.nova}
        19: {name: keyword.operator.existential.nova}
        20: {name: keyword.operator.assertion.nova}
        21: {name: keyword.operator.cascade.nova}
        22: {name: keyword.operator.accessor.nova}
        23: {name: keyword.operator.assignment.nova}
        24: {name: keyword.operator.regexp.nova}
    - include: '#operators'
    - match: |-
        (?x)
        ([&|^~][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+)| #1
        ([-+*%/\#][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+(?<![</>]))| #2
        ([:.][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+)| #3
        ([<>][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+(?<![</>]))| #4
        ([!=][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+)| #5
        (\?[\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+)| #6
        (\s+[\p{Sm}&&[\x{80}-\x{10FFFF}]][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]*\s+)| #7
        ([\p{Sc}&&[^$]][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]*)| #8
        ([\p{S}\p{Po}\p{Pd}&&[\x{80}-\x{FF}]][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]*)| #9
        ([\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+(?<![</>])) #10
      name: keyword.operator.infix.nova
      captures:
        1: {name: keyword.operator.logical.nova}
        2: {name: keyword.operator.arithmetic.nova}
        3: {name: keyword.operator.accessor.nova}
        4: {name: keyword.operator.relational.nova}
        5: {name: keyword.operator.comparison.nova}
        6: {name: keyword.operator.existential.nova}
        7: {name: keyword.operator.math.nova}
        8: {name: keyword.operator.currency.nova}
        9: {name: keyword.operator.ascii.nova}
        10: {name: keyword.operator.infix.nova}
    - begin: \s*+(('))
      end: |-
        \s*+(?:(('))|(
        ))
      beginCaptures:
        1: {name: string.quoted.single.nova}
        2: {name: punctuation.definition.string.begin.nova}
      endCaptures:
        1: {name: string.quoted.single.nova}
        2: {name: punctuation.definition.string.end.nova}
        3: {name: invalid.illegal.newline.nova}
      patterns:
      - include: '#string-content'
      - include: '#function-name'
    - begin: \s*+(("))
      end: |-
        \s*+(?:(("))|(
        ))
      beginCaptures:
        1: {name: string.quoted.double.nova}
        2: {name: punctuation.definition.string.begin.nova}
      endCaptures:
        1: {name: string.quoted.double.nova}
        2: {name: punctuation.definition.string.end.nova}
        3: {name: invalid.illegal.newline.nova}
      patterns:
      - include: '#string-content'
      - include: '#function-name'
    - begin: \s*+(?!\b(?:return|void)\b)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)?\s*((`))
      contentName: string.quoted.template.nova
      end: \s*((`)(?!`))
      beginCaptures:
        1: {name: entity.name.tag.nova}
        2: {name: string.quoted.template.nova}
        3: {name: punctuation.definition.quasi.begin.nova}
      endCaptures:
        1: {name: string.quoted.template.nova}
        2: {name: punctuation.definition.quasi.end.nova}
      patterns:
      - include: '#function-name'
      - include: '#quasi-embedded-raw'
  heregexp:
    patterns:
    - include: '#comments'
    - include: '#regexp-patterns'
  html-template:
    begin: (?:(?:^|(?<=,|{))\s*\b((template))\b\s*(:)\s*(`))
    end: \s*(`)
    beginCaptures:
      1: {name: constant.other.object.key.nova}
      2: {name: string.unquoted.nova}
      3: {name: punctuation.separator.key-value.nova}
      4: {name: punctuation.definition.quasi.begin.nova}
    endCaptures:
      1: {name: punctuation.definition.quasi.end.nova}
    patterns:
    - begin: (?<!\\)\${
      end: \s*}
      name: entity.quasi.element.nova
      beginCaptures:
        0: {name: punctuation.quasi.element.begin.nova}
      endCaptures:
        0: {name: punctuation.quasi.element.end.nova}
      patterns:
      - include: '#core'
    - include: text.html.mustache
  ignore-long-lines:
    patterns:
    - match: ^.{1000,}
  implicit-call:
    patterns:
    - match: (?x)(?<=\.)\s*([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*(?=['"`(]|::|<[-+|])
      captures:
        1: {patterns: [{include: '#method-name'}]}
    - match: (?x)\s*([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*(?=['"`(]|::|<[-+|])
      captures:
        1: {patterns: [{include: '#function-name'}]}
  js-label:
    match: (?:^|(?<=;))\s*([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*+)(:)\s*(?=(/\*.*?\*/\s*$|//|$|;|\b(for|each|while|do|if|switch|match|repeat)\b))
    captures:
      1: {name: constant.other.label.nova}
      2: {name: punctuation.separator.label.nova}
  jsdoc:
    patterns:
    - include: '#jsdoc-inline-tags'
    - include: '#jsdoc-access'
    - include: '#jsdoc-as-namepath'
    - include: '#jsdoc-simple'
    - include: '#jsdoc-simple-namepath'
    - include: '#jsdoc-module'
    - include: '#jsdoc-type-name'
    - include: '#jsdoc-type-noname'
    - match: (?<!\w)@(add|api|body|codeend|codestart|demo|download|group|select|hide|iframe|image|inherits|option|outline|page|parent|signature|tag)\b
      name: storage.type.class.jsdoc
    - match: (?<!\w)@(accessor|alternateClassName|aside|cfg|chainable|docauthor|evented|experimental|ftype|hide|inheritable|localdoc|markdown|mixins|new|override|preventable|ptype|removed|scss mixin|singleton|template|uses|xtype)\b
      name: storage.type.class.jsdoc
    repository:
      jsdoc-access:
        match: (?:^[\s*]*|(?<=/\*\*)\s*)(@(access))\s*(private|protected|public)?(?=\s|$)
        captures:
          1: {name: storage.type.class.jsdoc}
          3: {name: storage.modifier.jsdoc}
      jsdoc-as-namepath:
        begin: (?:^[\s*]*|(?<=/\*\*)\s*)(@(borrows|lends)\b)\s*(?=(?!\*/)\S+(?:(?:\s*\bas\b\s*(?!\*/)\S+)?)?([\S\s]*))
        end: ^|(?=\*/)|(?=\3$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
        - include: '#jsdoc-namepath-scopes'
      jsdoc-inline-tags:
        begin: (\[(?:(?>[^\[\]]+)|\g<-1>)*\])?({)(?=@)
        end: (})
        name: meta.tag.inline.jsdoc
        beginCaptures:
          1: {name: string.linktext.jsdoc}
          2: {name: meta.brace.curly.jsdoc}
        endCaptures:
          1: {name: meta.brace.curly.jsdoc}
        patterns:
        - match: (@(link|tutorial))\b([^}]*)
          captures:
            1: {name: storage.type.class.jsdoc}
            3: {name: string.jsdoc}
      jsdoc-module:
        begin: (?:^[\s*]*|(?<=/\*\*)\s*)(@(exports|module|listens|requires)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(\S*)([\S\s]*))
        end: ^|(?=\*/)|(?=\5$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
        - include: '#jsdoc-typedef-scopes'
        - match: (?:(module)(:))?(((?!\*/)\S)+)
          captures:
            1: {name: keyword.module.jsdoc}
            2: {name: punctuation.jsdoc}
            3: {name: string.modulename.jsdoc}
      jsdoc-name-scopes:
        patterns:
        - match: ((?!\*/)[\S&&[^\[\]"']])+
          captures:
            0: {name: variable.other.jsdoc}
        - begin: \[
          end: \]|^
          name: variable.other.jsdoc
          patterns:
          - include: '#jsdoc-string'
          - include: '#jsdoc-name-scopes'
      jsdoc-namepath-scopes:
        patterns:
        - match: \s*\b(as)\b\s*(?=[_\\\p{L}\p{Nl}])
          captures:
            1: {name: keyword.as.jsdoc}
        - match: \s*(?:([\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)|([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))(?=[\s\-~.#]|$)
          captures:
            1: {name: entity.name.class.jsdoc}
            2: {name: entity.name.function.jsdoc}
        - match: (\.)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(?=\s|$|\")
          captures:
            1: {name: keyword.operator.accessor.jsdoc}
            2: {name: entity.name.function.method.static.jsdoc}
        - match: (\#)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(?=\s|$|\")
          captures:
            1: {name: keyword.operator.accessor.jsdoc}
            2: {name: entity.name.function.method.instance.jsdoc}
        - match: (~|-)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(?=\s|$|\")
          captures:
            1: {name: keyword.operator.accessor.jsdoc}
            2: {name: entity.name.function.method.inner.jsdoc}
        - match: (\#)(event)(:)
          captures:
            1: {name: keyword.operator.accessor.jsdoc}
            2: {name: keyword.event.jsdoc}
            3: {name: keyword.operator.jsdoc}
        - applyEndPatternLast: 1
          begin: \.(?="|')
          end: (?=.)
          name: string.method.jsdoc
          patterns:
          - include: '#jsdoc-string'
      jsdoc-simple:
        match: (?:^[\s*]*|(?<=/\*\*)\s*)(@(abstract|author|classdesc|copyright|default|defaultvalue|deprecated|description|desc|example|external|fileoverview|file|global|host|ignore|inheritdoc|inner|instance|license|override|overview|readonly|see|since|static|summary|todo|tutorial|virtual|variation|version)\b)(?=$|\s)
        captures:
          1: {name: storage.type.class.jsdoc}
      jsdoc-simple-namepath:
        begin: (?:^[\s*]*|(?<=/\*\*)\s*)(@(alias|augments|callback|extends|emits|event|fires|interface|memberof|mixes|name|property|prop|this|typedef)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*\S*([\S*\s]*))
        end: ^|(?=\*/)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
        - include: '#jsdoc-typedef-scopes'
        - include: '#jsdoc-namepath-scopes'
      jsdoc-string:
        match: '"(\\"|[^"])*"|''(\\''|[^''])*'''
        name: string.jsdoc
      jsdoc-type-name:
        begin: (?:^[\s*]*|(?<=/\*\*)\s*)(@(arg|argument|class|constant|constructor|constructs|const|con|function|func|kind|member|method|mixin|namespace|param|var)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*(((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\S)+)?([\S\s]*))
        end: ^|(?=\*/)|(?=\7$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
        - include: '#jsdoc-typedef-scopes'
        - include: '#jsdoc-name-scopes'
      jsdoc-type-noname:
        begin: (?:^[\s*]*|(?<=/\*\*)\s*)(@(enum|exception|implements|private|protected|public|returns|return|throws|type)\b)\s*(?=({(?:(?>[^{}]+)|\g<-1>)*\})?\s*([\S\s]*))
        end: ^|(?=\*/)|(?=\4$)
        beginCaptures:
          1: {name: storage.type.class.jsdoc}
        patterns:
        - include: '#jsdoc-typedef-scopes'
      jsdoc-typedef-obj:
        begin: '{'
        end: '}|^'
        captures:
          0: {name: meta.brace.curly.jsdoc}
        patterns:
        - include: '#jsdoc-typedef-primitives'
        - match: \b([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*(:)
          captures:
            1: {name: variable.other.readwrite.jsdoc}
        - include: '#jsdoc-namepath-scopes'
        - include: '#jsdoc-typedef-obj'
      jsdoc-typedef-primitives:
        match: \b(null|undefined|boolean|string|number)\b
        captures:
          1: {name: support.type.builtin.primitive.jsdoc}
      jsdoc-typedef-scopes:
        begin: '{'
        end: '}|^'
        name: entity.name.type.instance.jsdoc
        captures:
          0: {name: meta.brace.curly.jsdoc}
        patterns:
        - include: '#jsdoc-typedef-primitives'
        - include: '#jsdoc-namepath-scopes'
        - include: '#jsdoc-typedef-obj'
  jsx:
    patterns:
    - applyEndPatternLast: 1
      begin: (?<=^|[\p{S}\p{Po}\p{Pd}\p{Ps}&&[^'"`]]|\b(?:in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)\s*+(?=<[_\\\p{L}\p{Nl}]|<\s*>)
      end: (?=.)
      patterns:
      - include: '#jsx-tag-element-name'
    repository:
      jsx-assignment:
        patterns:
        - match: '=(?=\s*(?:''|"|{|/\*|<|//|\n))'
          name: keyword.operator.assignment.jsx
      jsx-attribute-name:
        patterns:
        - match: (?<!\S)([_\\\p{L}](?:[_\\\p{L}\p{M}\p{N}](?<!\.\.))*+)(?<!\.)(?=//|/\*|=|\s|>|/>)
          captures:
            0: {name: entity.other.attribute-name.jsx}
      jsx-entities:
        patterns:
        - match: (&)([a-zA-Z\d]+|#[\d]+|#x\h+)(;)
          captures:
            0: {name: constant.character.entity.jsx}
            1: {name: punctuation.definition.entity.jsx}
            2: {name: entity.name.tag.html.jsx}
            3: {name: punctuation.definition.entity.jsx}
        - match: '&\s*+;'
          name: invalid.illegal.bad-ampersand.jsx
      jsx-evaluated-code:
        patterns:
        - begin: '{'
          contentName: source.nova
          end: '}'
          name: meta.embedded.expression.nova
          beginCaptures:
            0: {name: punctuation.section.embedded.begin.jsx}
          endCaptures:
            0: {name: punctuation.section.embedded.end.jsx}
          patterns:
          - include: '#string'
          - include: '#jsx-spread-attribute'
          - include: '#core'
      jsx-spread-attribute:
        patterns:
        - match: (?<![\#\.])\.\.\.
          name: keyword.operator.spread.jsx
      jsx-string-double-quoted:
        begin: '"'
        end: '"(?<!\\")'
        name: string.quoted.double.nova
        beginCaptures:
          0: {name: punctuation.definition.string.begin.jsx}
        endCaptures:
          0: {name: punctuation.definition.string.end.jsx}
        patterns:
        - include: '#jsx-entities'
      jsx-string-single-quoted:
        begin: ''''
        end: '''(?<!\\'')'
        name: string.quoted.single.nova
        beginCaptures:
          0: {name: punctuation.definition.string.begin.jsx}
        endCaptures:
          0: {name: punctuation.definition.string.end.jsx}
        patterns:
        - include: '#jsx-entities'
      jsx-tag-attributes:
        patterns:
        - include: '#jsx-attribute-name'
        - include: '#jsx-assignment'
        - include: '#jsx-string-double-quoted'
        - include: '#jsx-string-single-quoted'
        - include: '#jsx-evaluated-code'
        - include: '#jsx-tag-element-name'
        - include: '#comments'
      jsx-tag-element-name:
        patterns:
        - begin: \s*+(<)\s*(?=>)
          contentName: JSXAttrs
          end: (?<=</)(>)
          name: meta.tag.jsx
          beginCaptures:
            1: {name: punctuation.definition.tag.jsx}
          endCaptures:
            1: {name: punctuation.definition.tag.jsx}
          patterns:
          - include: '#jsx-tag-termination'
        - begin: \s*+(<)((\p{Ll}[-_\\\p{Ll}\p{N}]*)|((?:[_\\\p{L}\p{Nl}][-_\\\p{L}\p{M}\p{N}]*?:)?+(?:[_\\\p{L}\p{Nl}](?:[-_\\\p{L}\p{M}\p{N}.:](?<!\.\.))*+)+))(?=[/>\s])(?![:])(?<!\.|:)
          contentName: JSXAttrs
          end: \s*(?<=</)((\4)|\2)(>)|(/>)|((?<=</)[\S ]*?)>
          name: meta.tag.jsx
          beginCaptures:
            1: {name: punctuation.definition.tag.jsx}
            2: {name: entity.name.tag.open.jsx}
            4: {name: support.class.component.open.jsx}
          endCaptures:
            1: {name: entity.name.tag.close.jsx}
            2: {name: support.class.component.close.jsx}
            3: {name: punctuation.definition.tag.jsx}
            4: {name: punctuation.definition.tag.jsx}
            5: {name: invalid.illegal.termination.jsx}
          patterns:
          - include: '#jsx-tag-termination'
          - include: '#jsx-tag-attributes'
      jsx-tag-termination:
        patterns:
        - begin: (>)
          contentName: JSXNested
          end: (</)
          beginCaptures:
            0: {name: punctuation.definition.tag.jsx}
            1: {name: JSXStartTagEnd}
          endCaptures:
            0: {name: punctuation.definition.tag.jsx}
            1: {name: JSXEndTagStart}
          patterns:
          - include: text.html.markdown#inline
          - include: '#jsx-evaluated-code'
          - include: '#jsx-entities'
          - include: '#jsx-tag-element-name'
  keyword-storage:
    patterns:
    - begin: (?<![\#\.])\s*+\b(const|con|let|var|val)\b
      end: (?=\s*[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*:\s*($|\b(do|for|each|while)\b))|\s*(?=;|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
      beginCaptures:
        1: {name: storage.type.nova}
      patterns:
      - include: '#typed-variable'
  keywords:
    patterns:
    - include: '#new'
    - include: '#query'
    - begin: (?<![\#\.])\s*+\b(halt|skip|break|continue|goto|label)\b
      end: ^\s*|\s*(?=,|;|:|//|$|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\p{Pe})
      beginCaptures:
        1: {name: keyword.control.flow.nova}
      patterns:
      - include: '#comments'
      - include: '#keywords'
      - include: '#modifiers'
      - match: \s*([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*
        captures:
          1: {name: constant.other.label.nova}
    - match: |-
        (?x)(?<![\#\.])\s*+\b(?:
          (in|of|as|void|new|(?:type|name|key|size)of|infer) #1
          |(size)|(len)|(del)|(is)|(to|til|by)|(then) #2-7
          # |(n?and|x?n?or|[gl][te]|eq|ne|(?:as|sh)[lr]|div|rem|mod|pow|
          # not(of|in)?|(is)no?t)#8-11
        )\b
      captures:
        1: {name: keyword.operator.expression.$1.nova}
        2: {name: keyword.operator.expression.sizeof.nova}
        3: {name: keyword.operator.expression.length.nova}
        4: {name: keyword.operator.expression.delete.nova}
        5: {name: keyword.operator.expression.instanceof.nova}
        6: {name: keyword.operator.expression.range.nova}
        7: {name: keyword.control.then.nova}
        8: {name: keyword.other.logical.nova}
        9: {name: keyword.operator.$9.nova}
        10: {name: keyword.operator.instanceof.nova}
    - match: |-
        (?x)(?<![\#\.])\s*+\b(?:
          (if|else|els?if|ell?ess?|unless?|guard)|(for|each|while|until|repeat)| #1,2
          (switch|case|def)|(match|when|pass)| #3,4
          (try|throw|raise|catch|rescue|finally)|(with|as)| #5,6
          (defn?|func?|fn|macro|proc)|(let|va[rl]|con|const)| #7,8
          (ref|[dr]efer|out|begin|end|show|hide)| #9
          (do|goto|label|await|return|fallthru|yield|halt|skip)| #10
          (from|where|join|equals|[io]nto|order|take|drop|fold|scan|group)| #11
          ((?:im|ex)port|use|using|open|close|show|hide)| #12
          (debug|check|assert) #13
        )\b
      captures:
        1: {name: keyword.control.conditional.nova}
        2: {name: keyword.control.loop.nova}
        3: {name: keyword.control.switch.nova}
        4: {name: keyword.control.match.nova}
        5: {name: keyword.control.trycatch.nova}
        6: {name: keyword.control.with.nova}
        7: {name: storage.type.function.nova}
        8: {name: storage.type.nova}
        9: {name: keyword.control.nova}
        10: {name: keyword.control.flow.nova}
        11: {name: keyword.query.nova}
        12: {name: keyword.control.module.nova}
        13: {name: keyword.other.$13.nova}
  labels:
    patterns:
    - match: (?<!\.|\?)\s*+(((")(\\.|[^\\"])*("))|((')(\\.|[^\\'])*(')))\s*+(:)((?=::)|(?![:<=>]))
      name: meta.object.member.nova meta.object-literal.key.nova
      captures:
        1: {name: constant.other.object.key.nova}
        2: {name: string.quoted.double.nova, patterns: [{include: '#string-content'}]}
        3: {name: punctuation.definition.string.begin.nova}
        5: {name: punctuation.definition.string.end.nova}
        6: {name: string.quoted.single.nova, patterns: [{include: '#string-content'}]}
        7: {name: punctuation.definition.string.begin.nova}
        9: {name: punctuation.definition.string.end.nova}
        10: {name: punctuation.separator.key-value.nova}
    - begin: (?<!\.|\?)\s*+(?=(\[(?:(?>[^\[\]]+)|\g<-1>)*\])\s*+:\s*+[\S&&[^:]])
      end: \s*(:)((?=::)|(?![:<=>]))
      name: meta.object.member.nova meta.object-literal.key.nova
      endCaptures:
        1: {name: punctuation.separator.key-value.nova}
      patterns:
      - include: '#core'
    - include: '#js-label'
    - match: (?<!\.|\?)\s*+(([_\\\p{L}\p{M}\p{N}]*))\s*+(:)((?=::)|(?![:<=>]))
      name: meta.object.member.nova meta.object-literal.key.nova
      captures:
        1: {name: constant.other.object.key.nova, patterns: [{include: '#number'}]}
        2: {name: string.unquoted.nova}
        3: {name: punctuation.separator.key-value.nova}
  language-constant:
    patterns:
    - match: (?i)(?<![\#\.])\s*+\b((true|yes|on)|(false|no|off)|(null|nil|none)|(undef)|(nan)|(inf|infin))\b
      captures:
        2: {name: constant.language.boolean.true.nova}
        3: {name: constant.language.boolean.false.nova}
        4: {name: constant.language.null.nova}
        5: {name: constant.language.undefined.nova}
        6: {name: constant.language.nan.nova}
        7: {name: constant.language.infinity.nova}
  language-variable:
    patterns:
    - match: (?<![\#\.])\s*+\b(params|args)\b
      captures:
        1: {name: variable.language.arguments.nova}
    - match: (?<![\#\.])\s*+\b(super)\b\s*+(?!\()
      captures:
        1: {name: variable.language.super.nova}
    - match: (?<![\#\.])\s*+\b(this)\b
      captures:
        1: {name: variable.language.this.nova}
    - match: (?<![\#\.])\s*+\b(self)\b\s*+(?!\()
      captures:
        1: {name: variable.language.self.nova}
    - match: (?<=\.)\s*+\b(\\proto)\b
      captures:
        1: {name: variable.language.proto.nova}
    - match: (?<=\.)\s*+\b(ctor)\b\s*+(?!\()
      captures:
        1: {name: variable.language.constructor.nova}
    - match: (?<=\.)\s*+\b(proto)\b
      captures:
        1: {name: variable.language.prototype.nova}
    - match: |-
        (?x)(?<![\#\.])\s*+\b(?:
          (params|args)|(super|this|self|proto)|(\\proto|main)|(ctor)|(targ)|(len|size)
        )\b
      captures:
        1: {name: variable.language.arguments.nova}
        2: {name: variable.language.$2.nova}
        3: {name: variable.language.prototype.nova}
        4: {name: variable.language.constructor.nova}
        5: {name: variable.language.target.nova}
        6: {name: variable.language.length.nova}
  method:
    patterns:
    - begin: (?<!:)(?<=^|;|,|@@|}|{)\s*+(\bstatic\b)?\s*+(\basync\b)?\s*+(\*?)\s*+(?<![\#\.])(\#?)(?!\bstatic\b)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(?=\s*+(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*(\())
      end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|,|;)|\s*(?=,|;|=|{|\*/|\)|})
      beginCaptures:
        1: {name: storage.modifier.nova}
        2: {name: storage.type.nova}
        3: {name: keyword.generator.asterisk.nova}
        4: {name: keyword.operator.private.nova}
        5: {patterns: [{include: '#method-name'}]}
      endCaptures:
        1: {name: keyword.operator.assignment.nova}
      patterns:
      - include: '#types'
      - include: '#curly-brackets'
      - include: '#core'
      - include: $self
    - begin: (?<!:)(?<=^|;|,|@@|}|{)\s*+(\bstatic\b)?\s*+(\basync\b)?\s*+(\*?)\s*+(?<![\#\.])(('|")([^"']*)(\k<-3>))(?=\s*+(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?(\())
      end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|,|;)|\s*(?=,|;|=|{|\*/|\)|})
      beginCaptures:
        1: {name: storage.modifier.nova}
        2: {name: storage.type.nova}
        3: {name: keyword.generator.asterisk.nova}
        4: {patterns: [{include: '#method-name'}]}
      endCaptures:
        1: {name: keyword.operator.assignment.nova}
      patterns:
      - include: '#types'
      - include: '#curly-brackets'
      - include: '#core'
      - include: $self
    - begin: (?<!:)(?<=^|;|,|@@|}|{)\s*+(\bstatic\b)?\s*+(\basync\b)?\s*+(\*?)\s*+(?=((\[(?:(?>[^\[\]]+)|\g<-1>)*\]))\s*+(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*+(\())
      end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|,|;)|\s*(?=,|;|=|{|\*/|\)|})
      beginCaptures:
        1: {name: storage.modifier.nova}
        2: {name: storage.type.nova}
        3: {name: keyword.generator.asterisk.nova}
        4: {patterns: [{include: '#method-name'}]}
      endCaptures:
        1: {name: keyword.operator.assignment.nova}
      patterns:
      - include: '#types'
      - include: '#square-brackets'
      - include: '#curly-brackets'
      - include: '#core'
      - include: $self
    - begin: (?<=^|;|,|@@|}|{)\s*+\b(?:(static)\s+)?(get|set)\s++(\#?)(?!\bstatic\b)(#?(?:[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*|[\p{S}\p{Po}\p{Pd}&&[^,;'"`<\/>\\$]]+|'(?:\\'|[^'])*'|"(?:\\"|[^"])*"|`(?:``|[^`])*`))(?=\s*+\()
      end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|,|;)|\s*(?=,|;|=|{|\*/|\)|})
      beginCaptures:
        1: {name: storage.modifier.nova}
        2: {name: storage.type.accessor.nova}
        3: {name: keyword.operator.private.nova}
        4: {name: entity.name.function.accessor.nova}
      endCaptures:
        1: {name: keyword.operator.assignment.nova}
      patterns:
      - include: '#types'
      - include: '#curly-brackets'
      - include: '#core'
      - include: $self
    - begin: (?<=^|;|,|@@|}|{)\s*+\b(?:(static)\s+)?(get|set)\s+(?=((\[(?:(?>[^\[\]]+)|\g<-1>)*\])|\s*+(((')((?:[^']|\\')*)('))|\s*+((")((?:[^"]|\\")*)("))))\s*+(\())
      end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|,|;)|\s*(?=,|;|=|{|\*/|\)|})
      beginCaptures:
        1: {name: storage.modifier.nova}
        2: {name: storage.type.accessor.nova}
        3: {name: entity.name.function.accessor.nova}
      endCaptures:
        1: {name: keyword.operator.assignment.nova}
      patterns:
      - include: '#typed-parse-array'
      - include: '#string'
      - include: '#types'
      - include: '#square-brackets'
      - include: '#core'
      - include: $self
  method-call:
    patterns:
    - applyEndPatternLast: 1
      begin: \s*+(\#?)((?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}])(?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}])*+)\s*+(?:(\?\.)|(!\.)|(~\.)|(\.))\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+(\(\s*+\)))
      end: (?=.)
      name: meta.method-call.without-arguments.nova
      beginCaptures:
        1: {name: keyword.operator.private.nova}
        2: {name: variable.other.constant.nova}
        3: {name: keyword.operator.existential.nova}
        4: {name: keyword.operator.accessor.nova}
        5: {name: keyword.operator.assertion.nova}
        6: {name: keyword.operator.accessor.nova}
        7: {name: keyword.operator.private.nova}
        8: {patterns: [{include: '#method-name'}]}
      patterns:
      - include: '#square-brackets'
      - include: '#type-argument-brackets'
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(\#?)((?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}])(?:[_\\\p{L}\p{M}\p{N}])+)\s*+(?:(\?\.)|(!\.)|(~\.)|(\.))\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+(\(\s*+\)))
      end: (?=.)
      name: meta.method-call.without-arguments.nova
      beginCaptures:
        1: {name: keyword.operator.private.nova}
        2: {name: variable.other.class.nova}
        3: {name: keyword.operator.existential.nova}
        4: {name: keyword.operator.assertion.nova}
        5: {name: keyword.operator.cascade.nova}
        6: {name: keyword.operator.accessor.nova}
        7: {name: keyword.operator.private.nova}
        8: {patterns: [{include: '#method-name'}]}
      patterns:
      - include: '#square-brackets'
      - include: '#type-argument-brackets'
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(\#?)((?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}])(?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}])*+)\s*+(?:(\?\.)|(!\.)|(~\.)|(\.))\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\()
      end: (?=.)
      name: meta.method-call.with-arguments.nova
      beginCaptures:
        1: {name: keyword.operator.private.nova}
        2: {name: variable.other.constant.nova}
        3: {name: keyword.operator.existential.nova}
        4: {name: keyword.operator.assertion.nova}
        5: {name: keyword.operator.cascade.nova}
        6: {name: keyword.operator.accessor.nova}
        7: {name: keyword.operator.private.nova}
        8: {patterns: [{include: '#method-name'}]}
      patterns:
      - include: '#square-brackets'
      - include: '#type-argument-brackets'
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(\#?)((?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}])(?:[_\\\p{L}\p{M}\p{N}])+)\s*+(?:(\?\.)|(!\.)|(~\.)|(\.))\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\()
      end: (?=.)
      name: meta.method-call.with-arguments.nova
      beginCaptures:
        1: {name: keyword.operator.private.nova}
        2: {name: variable.other.class.nova}
        3: {name: keyword.operator.existential.nova}
        4: {name: keyword.operator.assertion.nova}
        5: {name: keyword.operator.cascade.nova}
        6: {name: keyword.operator.accessor.nova}
        7: {name: keyword.operator.private.nova}
        8: {patterns: [{include: '#method-name'}]}
      patterns:
      - include: '#round-brackets'
      - include: '#type-argument-brackets'
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: (?<=\.)\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+(\(\s*+\)))
      end: (?=.)
      name: meta.method-call.without-arguments.nova
      beginCaptures:
        1: {name: keyword.operator.private.nova}
        2: {patterns: [{include: '#method-name'}]}
        3: {name: meta.group.braces.round.function.arguments.nova}
      patterns:
      - include: '#square-brackets'
      - include: '#type-argument-brackets'
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: (?<=\.)\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(?=(\[(?:(?>[^\[\]]+)|\\g<-1>)*\])?+\s*+(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\()
      end: (?=.)
      name: meta.method-call.with-arguments.nova
      beginCaptures:
        1: {name: keyword.operator.private.nova}
        2: {patterns: [{include: '#method-name'}]}
      patterns:
      - include: '#square-brackets'
      - include: '#type-argument-brackets'
      - include: '#round-brackets'
  method-name:
    patterns:
    - include: '#support-methods'
    - match: (([a-zA-Z])[_\\\p{L}\p{M}\p{N}]*)
      name: entity.name.function.method.$2.nova
    - match: ([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
      name: entity.name.function.method.nova
  modifiers:
    patterns:
    - match: |-
        (?x)(?<![\#\.])\s*+\b(?:
          (pub|prot|pvt|priv|ronly|(?:in|ex)tl)| #1
          (over|abs|stat|dyn|vol|a?sync|(?:im)?mut|part|seal|final|dele|[dr]ef|
          trans|(?:im|ex)pl|ext|(?:un)?(?:sign|safe|check|size))| #2
          (rec|gen|inline|(?:pre|in|suf|)fix|(?:u|bi|ter|)nary|[gs]et|
          prev|next|lock|fixed|lazy|eager|greedy|unique|handle)| #3
          (n?and|x?n?or|[gl][te]|eq|ne|(?:as|sh)[lr]|div|rem|mod|pow|
          not(of|in)?|(is)no?t) #4
        )\s*+(?=\b
          (\s*\b(pub|prot|pvt|priv|ronly|(?:in|ex)tl|over|abs|stat|dyn|vol|a?sync|
          (?:im)?mut|part|seal|final|dele|[dr]ef|trans|(?:im|ex)pl|ext|(?:un)?
          (?:sign|safe|check|size)|rec|gen|inline|opaque|(?:pre|in|suf|)fix|(?:u|bi|ter|)
          nary|[gs]et|prev|next|lock|fixed|lazy|eager|greedy|unique|handle|n?and|
          x?n?or|[gl][te]|eq|ne|(?:as|sh)[lr]|div|rem|mod|pow|not(of|in)?|(is)no?t)
          \b\s*)*\s*\b
          (ext|impl|only|class|given|constr|enum|extn|extend|frag|inter|
          struct|data|schema|module|nspace|object|record|raw|style|trait|
          defn?|func?|fn|proc|macro|con|va[rl]|let|const|type|alias)\b
        )
      captures:
        1: {name: storage.modifier.nova}
        2: {name: keyword.modifier.nova}
        3: {name: storage.type.accessor.nova}
        4: {name: keyword.other.logical.nova}
        5: {name: keyword.operator.$5.nova}
        6: {name: keyword.operator.instanceof.nova}
    - match: |-
        (?x)(?<![\#\.])\s*+\b(?:
          (class|enum|module|object|raw|style)
          |(given|constr)
          |(enum)
          |(extend|extn)
          |(frag)
          |(inter|struct)
          |(module)
          |(nspace)
          |(object|record)
          |(raw)
          |(data|schema)
          |(style)
          |(trait)
          #|(opaque|type)
        )\b
      captures:
        1: {name: storage.type.$1.nova}
        2: {name: storage.type.constraint.nova}
        3: {name: storage.type.enum.nova}
        4: {name: storage.type.extension.nova}
        5: {name: storage.type.fragment.nova}
        6: {name: storage.type.interface.nova}
        7: {name: storage.type.module.nova}
        8: {name: storage.type.namespace.nova}
        9: {name: storage.type.object.nova}
        10: {name: storage.type.raw.nova}
        11: {name: storage.type.schema.nova}
        12: {name: storage.type.style.nova}
        13: {name: storage.type.trait.nova}
        14: {name: keyword.other.typedef.nova}
  module:
    begin: (?<![\#\.])\s*+\b(from|import|export|open|close)\b\s*
    end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=$|}|;)|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
    beginCaptures:
      1: {name: keyword.control.module.nova}
    patterns:
    - match: (?<![\#\.])\s*+\b(from|import|export|open|close|as|def|show|hide)\b\s*
      name: keyword.control.module.nova
    - match: \s*\*
      name: keyword.operator.module.all.nova
    - begin: \s*+(('))
      contentName: string.quoted.module.nova
      end: |-
        \s*+(?:(('))|(
        ))
      beginCaptures:
        1: {name: string.quoted.module.nova}
        2: {name: punctuation.definition.string.begin.nova}
      endCaptures:
        1: {name: string.quoted.module.nova}
        2: {name: punctuation.definition.string.end.nova}
        3: {name: invalid.illegal.newline.nova}
      patterns:
      - include: '#string-content'
    - begin: \s*+(("))
      contentName: string.quoted.module.nova
      end: |-
        \s*+(?:(("))|(
        ))
      beginCaptures:
        1: {name: string.quoted.module.nova}
        2: {name: punctuation.definition.string.begin.nova}
      endCaptures:
        1: {name: string.quoted.module.nova}
        2: {name: punctuation.definition.string.end.nova}
        3: {name: invalid.illegal.newline.nova}
      patterns:
      - include: '#string-content'
    - include: '#blocks'
    - include: '#function'
    - include: '#keyword-storage'
    - include: '#typed-keywords'
    - include: '#typed-parse-types'
    - include: '#operator'
    - include: '#operators'
    - include: '#punctuation'
  multiline-arrow-function-generics:
    patterns:
    - begin: \s*+(?:(\basync)\s+)(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?+\s*+\(\s*$)
      end: ((?<=})|(?:\s*(=>)(?!\s*{)))
      name: meta.function.arrow.nova
      beginCaptures:
        1: {name: storage.type.nova}
      endCaptures:
        2: {name: storage.type.function.arrow.nova}
      patterns:
      - include: '#types'
      - include: '#fat-arrow-braced-body'
    - begin: \s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*+>)\()
      end: ((?<=})|(?:\s*(=>)(?!\s*{)))
      name: meta.function.arrow.nova
      endCaptures:
        2: {name: storage.type.function.arrow.nova}
      patterns:
      - include: '#types'
      - include: '#fat-arrow-braced-body'
  new:
  - match: (?<![\#\.])\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(\?\.)?(\()\s*+(\)))
    name: meta.new-class.without-arguments.nova
    captures:
      1: {name: keyword.operator.new.nova}
      2: {name: meta.function-call.without-arguments.nova}
      3: {name: keyword.operator.private.nova}
      4: {name: entity.name.type.instance.nova}
      5: {name: keyword.operator.existential.nova}
      6: {name: meta.brace.round.nova}
      7: {name: meta.brace.round.nova}
  - applyEndPatternLast: 1
    begin: (?<![\#\.])\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(\?\.)?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)\s*+(\()\s*+(\))))
    end: (?=.)
    name: meta.new-class.without-arguments.nova
    beginCaptures:
      1: {name: keyword.operator.new.nova}
      2: {name: meta.function-call.without-arguments.nova}
      3: {name: keyword.operator.private.nova}
      4: {name: entity.name.type.instance.nova}
      5: {name: keyword.operator.existential.nova}
    patterns:
    - include: '#type-argument-brackets'
    - include: '#round-brackets'
  - applyEndPatternLast: 1
    begin: (?<![\#\.])\s*+(\bnew\b)\s*+((\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(\?\.)?\s*+(?=(<(?:(?>[^<>]+)|\g<-1>)*>)?\s*+\())
    end: (?=.)
    name: meta.new-class.with-arguments.nova
    beginCaptures:
      1: {name: keyword.operator.new.nova}
      2: {name: meta.function-call.with-arguments.nova}
      3: {name: keyword.operator.private.nova}
      4: {name: entity.name.type.instance.nova}
      5: {name: keyword.operator.existential.nova}
    patterns:
    - include: '#type-argument-brackets'
    - include: '#round-brackets'
  number:
    comments: Generated numeric literals
    patterns:
    - match: (?<=[\htx])\.
      name: meta.delimiter.decimal.period
    - match: \.(?=\d)
      name: meta.delimiter.decimal.period
    - match: |-
        (?xi)\s*\b
        0b
        (?:[01] [01_]* [01]?)?
        (?:(\.) [01] [01_]* [01]?)
        (?:(r) [01] [01_]* [01]?)?
        (?:(p[+-]?) \d+)?
        (?:(s) \d+)?
        (?:(k) \w+)?
        \b
      captures:
        0: {name: constant.numeric.binary.nova}
        1: {name: meta.delimiter.decimal.period.nova}
        2: {name: storage.type.numeric.bigint.nova}
        3: {name: storage.type.numeric.bigint.nova}
        4: {name: storage.type.numeric.bigint.nova}
        5: {name: storage.type.numeric.bigint.nova}
    - match: |-
        (?xi)\s*\b
        0b
        [01] [01_]* [01]?
        (?:(\.) [01] [01_]* [01]?)?
        (?:(r) [01] [01_]* [01]?)?
        (?:(p[+-]?) \d+)?
        (?:(s) \d+)?
        (?:(k) \w+)?
        \b
      captures:
        0: {name: constant.numeric.binary.nova}
        1: {name: meta.delimiter.decimal.period.nova}
        2: {name: storage.type.numeric.bigint.nova}
        3: {name: storage.type.numeric.bigint.nova}
        4: {name: storage.type.numeric.bigint.nova}
        5: {name: storage.type.numeric.bigint.nova}
    - match: |-
        (?xi)\s*\b
        0q
        (?:[0-3] [0-3_]* [0-3]?)?
        (?:(\.) [0-3] [0-3_]* [0-3]?)
        (?:(r) [0-3] [0-3_]* [0-3]?)?
        (?:(p[+-]?) \d+)?
        (?:(s) \d+)?
        (?:(k) \w+)?
        \b
      captures:
        0: {name: constant.numeric.quaternary.nova}
        1: {name: meta.delimiter.decimal.period.nova}
        2: {name: storage.type.numeric.bigint.nova}
        3: {name: storage.type.numeric.bigint.nova}
        4: {name: storage.type.numeric.bigint.nova}
        5: {name: storage.type.numeric.bigint.nova}
    - match: |-
        (?xi)\s*\b
        0q
        [0-3] [0-3_]* [0-3]?
        (?:(\.) [0-3] [0-3_]* [0-3]?)?
        (?:(r) [0-3] [0-3_]* [0-3]?)?
        (?:(p[+-]?) \d+)?
        (?:(s) \d+)?
        (?:(k) \w+)?
        \b
      captures:
        0: {name: constant.numeric.quaternary.nova}
        1: {name: meta.delimiter.decimal.period.nova}
        2: {name: storage.type.numeric.bigint.nova}
        3: {name: storage.type.numeric.bigint.nova}
        4: {name: storage.type.numeric.bigint.nova}
        5: {name: storage.type.numeric.bigint.nova}
    - match: |-
        (?xi)\s*\b
        0s
        (?:[0-5] [0-5_]* [0-5]?)?
        (?:(\.) [0-5] [0-5_]* [0-5]?)
        (?:(r) [0-5] [0-5_]* [0-5]?)?
        (?:(p[+-]?) \d+)?
        (?:(s) \d+)?
        (?:(k) \w+)?
        \b
      captures:
        0: {name: constant.numeric.senary.nova}
        1: {name: meta.delimiter.decimal.period.nova}
        2: {name: storage.type.numeric.bigint.nova}
        3: {name: storage.type.numeric.bigint.nova}
        4: {name: storage.type.numeric.bigint.nova}
        5: {name: storage.type.numeric.bigint.nova}
    - match: |-
        (?xi)\s*\b
        0s
        [0-5] [0-5_]* [0-5]?
        (?:(\.) [0-5] [0-5_]* [0-5]?)?
        (?:(r) [0-5] [0-5_]* [0-5]?)?
        (?:(p[+-]?) \d+)?
        (?:(s) \d+)?
        (?:(k) \w+)?
        \b
      captures:
        0: {name: constant.numeric.senary.nova}
        1: {name: meta.delimiter.decimal.period.nova}
        2: {name: storage.type.numeric.bigint.nova}
        3: {name: storage.type.numeric.bigint.nova}
        4: {name: storage.type.numeric.bigint.nova}
        5: {name: storage.type.numeric.bigint.nova}
    - match: |-
        (?xi)\s*\b
        0o
        (?:[0-7] [0-7_]* [0-7]?)?
        (?:(\.) [0-7] [0-7_]* [0-7]?)
        (?:(r) [0-7] [0-7_]* [0-7]?)?
        (?:(p[+-]?) \d+)?
        (?:(s) \d+)?
        (?:(k) \w+)?
        \b
      captures:
        0: {name: constant.numeric.octal.nova}
        1: {name: meta.delimiter.decimal.period.nova}
        2: {name: storage.type.numeric.bigint.nova}
        3: {name: storage.type.numeric.bigint.nova}
        4: {name: storage.type.numeric.bigint.nova}
        5: {name: storage.type.numeric.bigint.nova}
    - match: |-
        (?xi)\s*\b
        0o
        [0-7] [0-7_]* [0-7]?
        (?:(\.) [0-7] [0-7_]* [0-7]?)?
        (?:(r) [0-7] [0-7_]* [0-7]?)?
        (?:(p[+-]?) \d+)?
        (?:(s) \d+)?
        (?:(k) \w+)?
        \b
      captures:
        0: {name: constant.numeric.octal.nova}
        1: {name: meta.delimiter.decimal.period.nova}
        2: {name: storage.type.numeric.bigint.nova}
        3: {name: storage.type.numeric.bigint.nova}
        4: {name: storage.type.numeric.bigint.nova}
        5: {name: storage.type.numeric.bigint.nova}
    - match: |-
        (?xi)\s*\b
        0z
        (?:[\dabetxz] [\dabetxz_]* [\dabetxz]?)?
        (?:(\.) [\dabetxz] [\dabetxz_]* [\dabetxz]?)
        (?:(r) [\dabetxz] [\dabetxz_]* [\dabetxz]?)?
        (?:(p[+-]?) \d+)?
        (?:(s) \d+)?
        (?:(k) \w+)?
        \b
      captures:
        0: {name: constant.numeric.duodecimal.nova}
        1: {name: meta.delimiter.decimal.period.nova}
        2: {name: storage.type.numeric.bigint.nova}
        3: {name: storage.type.numeric.bigint.nova}
        4: {name: storage.type.numeric.bigint.nova}
        5: {name: storage.type.numeric.bigint.nova}
    - match: |-
        (?xi)\s*\b
        0z
        [\dabetxz] [\dabetxz_]* [\dabetxz]?
        (?:(\.) [\dabetxz] [\dabetxz_]* [\dabetxz]?)?
        (?:(r) [\dabetxz] [\dabetxz_]* [\dabetxz]?)?
        (?:(p[+-]?) \d+)?
        (?:(s) \d+)?
        (?:(k) \w+)?
        \b
      captures:
        0: {name: constant.numeric.duodecimal.nova}
        1: {name: meta.delimiter.decimal.period.nova}
        2: {name: storage.type.numeric.bigint.nova}
        3: {name: storage.type.numeric.bigint.nova}
        4: {name: storage.type.numeric.bigint.nova}
        5: {name: storage.type.numeric.bigint.nova}
    - match: |-
        (?xi)\s*\b
        0x
        (?:\h [\h_]* \h?)?
        (?:(\.) \h [\h_]* \h?)
        (?:(r) \h [\h_]* \h?)?
        (?:(p[+-]?) \d+)?
        (?:(s) \d+)?
        (?:(k) \w+)?
        \b
      captures:
        0: {name: constant.numeric.hexadecimal.nova}
        1: {name: meta.delimiter.decimal.period.nova}
        2: {name: storage.type.numeric.bigint.nova}
        3: {name: storage.type.numeric.bigint.nova}
        4: {name: storage.type.numeric.bigint.nova}
        5: {name: storage.type.numeric.bigint.nova}
    - match: |-
        (?xi)\s*\b
        0x
        \h [\h_]* \h?
        (?:(\.) \h [\h_]* \h?)?
        (?:(r) \h [\h_]* \h?)?
        (?:(p[+-]?) \d+)?
        (?:(s) \d+)?
        (?:(k) \w+)?
        \b
      captures:
        0: {name: constant.numeric.hexadecimal.nova}
        1: {name: meta.delimiter.decimal.period.nova}
        2: {name: storage.type.numeric.bigint.nova}
        3: {name: storage.type.numeric.bigint.nova}
        4: {name: storage.type.numeric.bigint.nova}
        5: {name: storage.type.numeric.bigint.nova}
    - match: |-
        (?xi)\s*\b
        (?:\d [\d_]* \d?)?
        (?:(\.) \d [\d_]* \d?)
        (?:(r) \d [\d_]* \d?)?
        (?:(p[+-]?) \d+)?
        (?:(s) \d+)?
        (?:(k) \w+)?
        \b
      captures:
        0: {name: constant.numeric.decimal.nova}
        1: {name: meta.delimiter.decimal.period.nova}
        2: {name: storage.type.numeric.bigint.nova}
        3: {name: storage.type.numeric.bigint.nova}
        4: {name: storage.type.numeric.bigint.nova}
        5: {name: storage.type.numeric.bigint.nova}
    - match: |-
        (?xi)\s*\b
        \d [\d_]* \d?
        (?:(\.) \d [\d_]* \d?)?
        (?:(r) \d [\d_]* \d?)?
        (?:(p[+-]?) \d+)?
        (?:(s) \d+)?
        (?:(k) \w+)?
        \b
      captures:
        0: {name: constant.numeric.decimal.nova}
        1: {name: meta.delimiter.decimal.period.nova}
        2: {name: storage.type.numeric.bigint.nova}
        3: {name: storage.type.numeric.bigint.nova}
        4: {name: storage.type.numeric.bigint.nova}
        5: {name: storage.type.numeric.bigint.nova}
    - match: |-
        (?xi)\s*\b
        \d\w
        (?:\w [\w_]* \w?)?
        (?:(\.) \w [\w_]* \w?)
        (?:(r) \w [\w_]* \w?)?
        (?:(p[+-]?) \d+)?
        (?:(s) \d+)?
        (?:(k) \w+)?
        \b
      captures:
        0: {name: constant.numeric.illegal.nova}
        1: {name: meta.delimiter.decimal.period.nova}
        2: {name: storage.type.numeric.bigint.nova}
        3: {name: storage.type.numeric.bigint.nova}
        4: {name: storage.type.numeric.bigint.nova}
        5: {name: storage.type.numeric.bigint.nova}
    - match: |-
        (?xi)\s*\b
        \d\w
        \w [\w_]* \w?
        (?:(\.) \w [\w_]* \w?)?
        (?:(r) \w [\w_]* \w?)?
        (?:(p[+-]?) \d+)?
        (?:(s) \d+)?
        (?:(k) \w+)?
        \b
      captures:
        0: {name: constant.numeric.illegal.nova}
        1: {name: meta.delimiter.decimal.period.nova}
        2: {name: storage.type.numeric.bigint.nova}
        3: {name: storage.type.numeric.bigint.nova}
        4: {name: storage.type.numeric.bigint.nova}
        5: {name: storage.type.numeric.bigint.nova}
  object:
    patterns:
    - begin: (?:(?<=\(|\[|,)|(?:\s*(?:(=)|\b(default)\b|\b(return)\b|(,))))\s*(#?{\|)
      end: \s*+(\|})
      beginCaptures:
        1: {name: keyword.operator.assignment.nova}
        2: {name: keyword.control.module.nova}
        3: {name: keyword.control.flow.nova}
        4: {name: meta.delimiter.comma.nova}
        5: {name: meta.brace.curly.litobj.nova}
      endCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      patterns:
      - include: '#object-body'
    - begin: (?:(?<=\(|\[|,)|(?:\s*(?:(=)|\b(default)\b|\b(return)\b|(,))))\s*(#{)
      end: \s*+(})
      beginCaptures:
        1: {name: keyword.operator.assignment.nova}
        2: {name: keyword.control.module.nova}
        3: {name: keyword.control.flow.nova}
        4: {name: meta.delimiter.comma.nova}
        5: {name: meta.brace.curly.litobj.nova}
      endCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      patterns:
      - include: '#object-body'
    - begin: (?:(?<=\(|\[|,)|(?:\s*(?:(=)|\b(default)\b|\b(return)\b|(,))))\s*({)
      end: \s*+(})
      beginCaptures:
        1: {name: keyword.operator.assignment.nova}
        2: {name: keyword.control.module.nova}
        3: {name: keyword.control.flow.nova}
        4: {name: meta.delimiter.comma.nova}
        5: {name: meta.brace.curly.litobj.nova}
      endCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      patterns:
      - include: '#object-body'
  object-body:
    patterns:
    - include: '#typed-keywords'
    - include: languagebabel.ttlextension
    - include: '#html-template'
    - include: '#object-brace-property'
    - include: '#function-labels'
    - include: '#arrow-function-labels'
    - include: '#arrow-function'
    - include: '#method'
    - include: '#arrow-expression'
    - include: '#object-prop-shorthand'
    - include: '#labels'
    - include: '#keywords'
    - include: '#modifiers'
    - include: '#core'
    - include: '#punctuation'
  object-brace:
    patterns:
    - begin: \s*(#?{\|)
      end: \s*+(\|})
      beginCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      endCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      patterns:
      - include: '#object-body'
    - begin: \s*(#{)
      end: \s*+(})
      beginCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      endCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      patterns:
      - include: '#object-body'
    - begin: \s*({)
      end: \s*+(})
      beginCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      endCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      patterns:
      - include: '#object-body'
  object-brace-property:
    patterns:
    - begin: (?<=:)\s*(#?{\|)
      end: \s*+(\|})
      beginCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      endCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      patterns:
      - include: '#object-body'
    - begin: (?<=:)\s*(#{)
      end: \s*+(})
      beginCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      endCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      patterns:
      - include: '#object-body'
    - begin: (?<=:)\s*({)
      end: \s*+(})
      beginCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      endCaptures:
        1: {name: meta.brace.curly.litobj.nova}
      patterns:
      - include: '#object-body'
  object-prop-shorthand:
    patterns:
    - match: (?<=^|,|{)(?<!:|\.)\s*+(((?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}])(?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}])*+))\s*+(?=$|,|})
      captures:
        1: {name: constant.other.object.key.nova}
        2: {name: variable.other.constant.shorthandpropertyname.nova}
    - match: (?<=^|,|{)(?<!:|\.)\s*+(([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*))\s*+(?=$|,|})
      captures:
        1: {name: variable.other.readwrite.shorthandpropertyname.nova}
  operator:
    patterns:
    - match: \s*(\.\.[.=]?|[.=]\.[.=])\s*
      name: keyword.operator.range.nova
    - match: \s*(/\\)|(\\/)\s*
      name: keyword.operator.logical.nova
    - match: \s*(?:(::+)|([<>][:!]+|[:!]+[<>]|[<>][:!]+[<>]))\s*
      captures:
        1: {name: keyword.operator.accessor.nova}
        2: {name: keyword.operator.class.nova}
        3: {name: keyword.operator.accessor.nova}
    - match: \s*(<-+|-+>)\s*
      name: keyword.operator.then.nova
    repository:
    - begin: \s*(:\?[<=>]?|:(?![:<=>]))\s*
      end: |-
        (?x)(?==(?![=>])|[\p{Pe}\p{Po}\p{Pd}\p{S}&&[^<=>&|^~!?]]|\s*\b
        (in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|
        to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|
        until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|
        rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|
        do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|
        from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|
        select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|
        hide|debug|check|assert)\b|$)
      beginCaptures:
        1: {name: keyword.operator.type.nova}
      patterns:
      - include: '#typed-parse-types'
    - match: \s*(\.?=|::?=)(?![<~>=])\s*
      name: keyword.operator.assignment.nova
  operators:
    patterns:
    - include: '#unary-ops'
    - include: '#binary-ops'
    - include: '#special-operators'
    repository:
      binary-ops:
        patterns:
        - match: |-
            (?x)(?<=^|\p{Ps}|\p{Z}|['"`])(?:
              ([\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+(?<![!~<=>:])=) #1
              |(\+\++|--+) #2
              |(\+|-(?!>)|\*{1,3}|(?<!<)/(?!>)|\#|~/(?!>)|%%?|\*>|<\*) #3
              |(&&|\|\||\^\^|\\/|/\\) #4
              |([&^]|\|(?!>)|~(?![!=<>])) #5
              |(=\.\.|\.\.=|=\.=|\.\.(?!\.)) #6
              |(<[|+]|[|+]>)|(<<+|>>+) #7-8
              |([<>]:|:[<>]|[<>]:[<>]) #9
              |([!=~]+~|~[!=~]+|[<~>]+~|~[<~>]+) #10
              |(->|<-)|(<=>|[<>]=?)|(=[!:]=|[!=]==?) #11-13
              |(!\?|\?!|!!)|(\?\??)|(\?:)|(!:)|(\.\.\.) #14-18
              |(\?\.|(?<=[_\\\p{M}\p{L}\p{N}\p{Pe}?])\?(?![.:])(?=\B)) #19
              |(!\.|(?<=[_\\\p{M}\p{L}\p{N}\p{Pe}!])\!(?![.:])(?=\B)) #20
              |(~\.)|((?<!(?<!\.\.)\.)\.(?!=)|:::?)|((?:\.|::?)?=) #21-23
              |(=<|<[/*+]?>) #24
            )(?=$|\p{Pe}|\p{Z}|['"`])
          name: keyword.operator.builtin.nova
          captures:
            1: {name: keyword.operator.assignment.augmented.nova}
            2: {name: keyword.operator.crement.nova}
            3: {name: keyword.operator.arithmetic.nova}
            4: {name: keyword.operator.logical.nova}
            5: {name: keyword.operator.bitwise.nova}
            6: {name: keyword.operator.range.nova}
            7: {name: keyword.operator.pipeline.nova}
            8: {name: keyword.operator.bitwise.shift.nova}
            9: {name: keyword.operator.class.nova}
            10: {name: keyword.operator.similarity.nova}
            11: {name: keyword.operator.then.nova}
            12: {name: keyword.operator.relational.nova}
            13: {name: keyword.operator.comparison.nova}
            14: {name: keyword.operator.nonnull.nova}
            15: {name: keyword.operator.nullcoalesce.nova}
            16: {name: keyword.operator.ternary.nova}
            17: {name: keyword.operator.quasiternary.nova}
            18: {name: keyword.operator.spread.nova}
            19: {name: keyword.operator.existential.nova}
            20: {name: keyword.operator.assertion.nova}
            21: {name: keyword.operator.cascade.nova}
            22: {name: keyword.operator.accessor.nova}
            23: {name: keyword.operator.assignment.nova}
            24: {name: keyword.operator.regexp.nova}
        - match: |-
            (?x)
            ([&|^~][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+)| #1
            ([-+*%/\#][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+(?<![</>]))| #2
            ([:.][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+)| #3
            ([<>][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+(?<![</>]))| #4
            ([!=][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+)| #5
            (\?[\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+)| #6
            (\s+[\p{Sm}&&[\x{80}-\x{10FFFF}]][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]*\s+)| #7
            ([\p{Sc}&&[^$]][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]*)| #8
            ([\p{S}\p{Po}\p{Pd}&&[\x{80}-\x{FF}]][\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]*)| #9
            ([\p{S}\p{Po}\p{Pd}&&[^,;'"`\\$]]+(?<![</>])) #10
          name: keyword.operator.infix.nova
          captures:
            1: {name: keyword.operator.logical.nova}
            2: {name: keyword.operator.arithmetic.nova}
            3: {name: keyword.operator.accessor.nova}
            4: {name: keyword.operator.relational.nova}
            5: {name: keyword.operator.comparison.nova}
            6: {name: keyword.operator.existential.nova}
            7: {name: keyword.operator.math.nova}
            8: {name: keyword.operator.currency.nova}
            9: {name: keyword.operator.ascii.nova}
            10: {name: keyword.operator.infix.nova}
      special-operators:
        patterns:
        - include: '#esnext-pipeline'
        - begin: \s*((:\?[<=>]?))\s*
          end: (?=[^&|^~<>!?\p{L}\p{N}\p{Sc}\[\]{}_])
          beginCaptures:
            1: {name: keyword.operator.type.nova}
          endCaptures:
            1: {patterns: [{include: '#core'}]}
          patterns:
          - include: '#typed-parse-types'
        - begin: \s*+(\?)(?!\.[^\d]|[?=])(?=\s)
          end: \s*(:)((?=::)|(?!:|=))
          beginCaptures:
            1: {name: keyword.operator.ternary.nova}
          endCaptures:
            1: {name: keyword.operator.ternary.nova}
          patterns:
          - begin: \s*+(?=([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*:)
            end: \s*(?=:)
            patterns:
            - include: '#language-constant'
            - include: '#variable'
          - include: '#core'
        - begin: \s*+(\!)(?!\.[^\d]|[?=])(?=\s)
          end: \s*(:)((?=::)|(?!:|=))
          beginCaptures:
            1: {name: keyword.operator.quasiternary.nova}
          endCaptures:
            1: {name: keyword.operator.quasiternary.nova}
          patterns:
          - begin: \s*+(?=([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*:)
            end: \s*(?=:)
            patterns:
            - include: '#language-constant'
            - include: '#variable'
          - include: '#core'
        - begin: (\$)\s*
          end: \s*(\$)
          name: keyword.operator.function.nova
          beginCaptures:
            1: {name: keyword.operator.function.nova}
          endCaptures:
            1: {name: keyword.operator.function.nova}
          patterns:
          - include: '#function-name'
          - include: '#method-name'
          - include: '#core'
      unary-ops:
        patterns:
        - match: (?:(\?\.)|(~\.)|(!\.)|(\.))
          captures:
            1: {name: keyword.operator.existential.nova}
            2: {name: keyword.operator.cascade.nova}
            3: {name: keyword.operator.assertion.nova}
            4: {name: keyword.operator.accessor.nova}
        - match: |-
            (?x)
            (?:(\*) #1
            |(\+) #2
            |(\-) #3
            |(\&) #4
            |(\|) #5
            |(\^) #6
            |(\!) #7
            |(\#) #8
            |(\@) #9
            |(\~) #10
            |(\?) #11
            |(\=) #12
            |[\p{S}\p{Po}\p{Pd}&&[^,;'"`</>\\$]]) #13
            (?=[\p{S}\p{Po}\p{Pd}&&[^,;'"`</>\\$]]*
            [\p{L}\p{M}\p{N}\p{Ps}\p{Pe}'"`])
          name: keyword.operator.prefix.nova
          captures:
            1: {name: keyword.operator.module.all.nova}
            2: {name: keyword.operator.increment.nova}
            3: {name: keyword.operator.decrement.nova}
            4: {name: keyword.operator.intersection.nova}
            5: {name: keyword.operator.union.nova}
            6: {name: keyword.operator.symdiff.nova}
            7: {name: keyword.operator.logical.nova}
            8: {name: keyword.operator.private.nova}
            9: {name: keyword.operator.decorator.nova}
            10: {name: keyword.operator.bitwise.nova}
            11: {name: keyword.operator.existential.nova}
            12: {name: keyword.operator.assignment.nova}
            13: {name: keyword.operator.prefix.nova}
        - match: |-
            (?x)
            (?<=[\p{S}\p{Po}\p{Pd}&&[^,;'"`</>\\$]]*
            [\p{L}\p{M}\p{N}\p{Ps}\p{Pe}'"`])
            (?:(\*) #1
            |(\+) #2
            |(\-) #3
            |(\&) #4
            |(\|) #5
            |(\^) #6
            |(\!) #7
            |(\#) #8
            |(\@) #9
            |(\~) #10
            |(\?) #11
            |(\=) #12
            |[\p{S}\p{Po}\p{Pd}&&[^,;'"`</>\\$]]) #13
          name: keyword.operator.suffix.nova
          captures:
            1: {name: keyword.operator.module.all.nova}
            2: {name: keyword.operator.increment.nova}
            3: {name: keyword.operator.decrement.nova}
            4: {name: keyword.operator.intersection.nova}
            5: {name: keyword.operator.union.nova}
            6: {name: keyword.operator.symdiff.nova}
            7: {name: keyword.operator.logical.nova}
            8: {name: keyword.operator.private.nova}
            9: {name: keyword.operator.decorator.nova}
            10: {name: keyword.operator.bitwise.nova}
            11: {name: keyword.operator.existential.nova}
            12: {name: keyword.operator.assignment.nova}
            13: {name: keyword.operator.suffix.nova}
  preprocessor:
    begin: ^\s*(\#)\s*
    end: (?<=$)
    name: meta.preprocessor.nova
    beginCaptures:
      1: {name: punctuation.separator.hash.nova}
    patterns:
    - include: '#comment'
    - include: '#preprocessor-define-or-undef'
    - include: '#preprocessor-if-or-elif'
    - include: '#preprocessor-else-or-endif'
    - include: '#preprocessor-warning-or-error'
    - include: '#preprocessor-region'
    - include: '#preprocessor-endregion'
    - include: '#preprocessor-load'
    - include: '#preprocessor-r'
    - include: '#preprocessor-line'
    - include: '#preprocessor-pragma-warning'
    - include: '#preprocessor-pragma-checksum'
  preprocessor-define-or-undef:
    match: \b(?:(define)|(undef))\b\s*\b([_[:alpha:]][_[:alnum:]]*)\b
    captures:
      1: {name: keyword.preprocessor.define.nova}
      2: {name: keyword.preprocessor.undef.nova}
      3: {name: entity.name.variable.preprocessor.symbol.nova}
  preprocessor-else-or-endif:
    match: \b(?:(else)|(endif))\b
    captures:
      1: {name: keyword.preprocessor.else.nova}
      2: {name: keyword.preprocessor.endif.nova}
  preprocessor-endregion:
    match: \b(endregion)\b
    captures:
      1: {name: keyword.preprocessor.endregion.nova}
  preprocessor-expression:
    patterns:
    - include: '#core'
  preprocessor-if-or-elif:
    begin: \b(?:(if)|(elif))\b
    end: (?=$)
    beginCaptures:
      1: {name: keyword.preprocessor.if.nova}
      2: {name: keyword.preprocessor.elif.nova}
    patterns:
    - include: '#comment'
    - include: '#preprocessor-expression'
  preprocessor-line:
    begin: \b(line)\b
    end: (?=$)
    beginCaptures:
      1: {name: keyword.preprocessor.line.nova}
    patterns:
    - match: \b(?:(default|hidden))
      captures:
        1: {name: keyword.preprocessor.default.nova}
        2: {name: keyword.preprocessor.hidden.nova}
    - match: '[0-9]+'
      captures:
        0: {name: constant.numeric.decimal.nova}
    - match: \"[^"]*\"
      captures:
        0: {name: string.quoted.double.nova}
  preprocessor-load:
    begin: \b(load)\b
    end: (?=$)
    beginCaptures:
      1: {name: keyword.preprocessor.load.nova}
    patterns:
    - match: \"[^"]*\"
      captures:
        0: {name: string.quoted.double.nova}
  preprocessor-pragma-checksum:
    match: \b(pragma)\b\s*\b(checksum)\b\s*(\"[^"]*\")\s*(\"[^"]*\")\s*(\"[^"]*\")
    captures:
      1: {name: keyword.preprocessor.pragma.nova}
      2: {name: keyword.preprocessor.checksum.nova}
      3: {name: string.quoted.double.nova}
      4: {name: string.quoted.double.nova}
      5: {name: string.quoted.double.nova}
  preprocessor-pragma-warning:
    match: \b(pragma)\b\s*\b(warning)\b\s*\b(?:(disable)|(restore))\b(\s*[0-9]+(?:\s*,\s*[0-9]+)?)?
    captures:
      1: {name: keyword.preprocessor.pragma.nova}
      2: {name: keyword.preprocessor.warning.nova}
      3: {name: keyword.preprocessor.disable.nova}
      4: {name: keyword.preprocessor.restore.nova}
      5: {patterns: [{match: '[0-9]+', captures: {0: {name: constant.numeric.decimal.nova}}}, {include: '#punctuation-comma'}]}
  preprocessor-r:
    begin: \b(r)\b
    end: (?=$)
    beginCaptures:
      1: {name: keyword.preprocessor.r.nova}
    patterns:
    - match: \"[^"]*\"
      captures:
        0: {name: string.quoted.double.nova}
  preprocessor-region:
    match: \b(region)\b\s*(.*)(?=$)
    captures:
      1: {name: keyword.preprocessor.region.nova}
      2: {name: string.unquoted.preprocessor.message.nova}
  preprocessor-warning-or-error:
    match: \b(?:(warning)|(error))\b\s*(.*)(?=$)
    captures:
      1: {name: keyword.preprocessor.warning.nova}
      2: {name: keyword.preprocessor.error.nova}
      3: {name: string.unquoted.preprocessor.message.nova}
  prototype:
    patterns:
    - match: \s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(?:(\?\.)|(\.))(proto)\b
      name: meta.prototype.access.nova
      captures:
        1: {name: keyword.operator.private.nova}
        2: {name: entity.name.class.nova}
        3: {name: keyword.operator.existential.nova}
        4: {name: keyword.operator.accessor.nova}
        5: {name: variable.language.prototype.nova}
    - match: \s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(?:(\?\.)|(\.))(proto)\s*+=\s*+
      name: meta.prototype.declaration.nova
      captures:
        1: {name: keyword.operator.private.nova}
        2: {name: entity.name.class.nova}
        3: {name: keyword.operator.existential.nova}
        4: {name: keyword.operator.accessor.nova}
        5: {name: variable.language.prototype.nova}
  punctuation:
    patterns:
    - include: '#semi-colon'
    - include: '#comma'
  punctuation-semicolon:
    match: ;
    name: punctuation.terminator.statement.nova
  quasi:
    patterns:
    - include: languagebabel.ttlextension
    - begin: \s*+(raml)?\s*((`))
      contentName: string.quoted.template.nova
      end: \s*((`)(?!`))
      name: string.quasi.nova
      beginCaptures:
        1: {name: entity.name.tag.$1.nova}
        2: {name: string.quoted.template.nova}
        3: {name: punctuation.definition.quasi.begin.nova}
      endCaptures:
        1: {name: string.quoted.template.nova}
        2: {name: punctuation.definition.quasi.end.nova}
      patterns:
      - include: '#quasi-embedded-raw'
      - include: '#embedded-raml'
    - begin: \s*+(styl|stylus)?\s*((`))
      contentName: source.embedded.nova
      end: \s*((`)(?!`))
      name: string.quasi.nova
      beginCaptures:
        1: {name: entity.name.tag.$1.nova}
        2: {name: string.quoted.template.nova}
        3: {name: punctuation.definition.quasi.begin.nova}
      endCaptures:
        1: {name: string.quoted.template.nova}
        2: {name: punctuation.definition.quasi.end.nova}
      patterns:
      - include: '#quasi-embedded-raw'
      - include: '#embedded-stylus'
    - begin: \s*+(haml)?\s*((`))
      contentName: source.embedded.nova
      end: \s*((`)(?!`))
      name: string.quasi.nova
      beginCaptures:
        1: {name: entity.name.tag.$1.nova}
        2: {name: string.quoted.template.nova}
        3: {name: punctuation.definition.quasi.begin.nova}
      endCaptures:
        1: {name: string.quoted.template.nova}
        2: {name: punctuation.definition.quasi.end.nova}
      patterns:
      - include: '#quasi-embedded-raw'
      - include: '#embedded-haml'
    - begin: \s*+(haml)?\s*((`))
      contentName: source.embedded.nova
      end: \s*((`)(?!`))
      name: string.quasi.nova
      beginCaptures:
        1: {name: entity.name.tag.$1.nova}
        2: {name: string.quoted.template.nova}
        3: {name: punctuation.definition.quasi.begin.nova}
      endCaptures:
        1: {name: string.quoted.template.nova}
        2: {name: punctuation.definition.quasi.end.nova}
      patterns:
      - include: '#quasi-embedded-raw'
      - include: '#embedded-haml'
    - begin: \s*+(pug)?\s*((`))
      contentName: source.embedded.nova
      end: \s*((`)(?!`))
      name: string.quasi.nova
      beginCaptures:
        1: {name: entity.name.tag.$1.nova}
        2: {name: string.quoted.template.nova}
        3: {name: punctuation.definition.quasi.begin.nova}
      endCaptures:
        1: {name: string.quoted.template.nova}
        2: {name: punctuation.definition.quasi.end.nova}
      patterns:
      - include: '#quasi-embedded-raw'
      - include: text.pug
    - begin: \s*+(markdown|md)?\s*((`))
      contentName: source.embedded.nova
      end: \s*((`)(?!`))
      name: string.quasi.nova
      beginCaptures:
        1: {name: entity.name.tag.$1.nova}
        2: {name: string.quoted.template.nova}
        3: {name: punctuation.definition.quasi.begin.nova}
      endCaptures:
        1: {name: string.quoted.template.nova}
        2: {name: punctuation.definition.quasi.end.nova}
      patterns:
      - include: '#quasi-embedded-raw'
      - include: text.html.markdown
    - begin: \s*+(coffee)?\s*((`))
      contentName: source.embedded.nova
      end: \s*((`)(?!`))
      name: string.quasi.nova
      beginCaptures:
        1: {name: entity.name.tag.$1.nova}
        2: {name: string.quoted.template.nova}
        3: {name: punctuation.definition.quasi.begin.nova}
      endCaptures:
        1: {name: string.quoted.template.nova}
        2: {name: punctuation.definition.quasi.end.nova}
      patterns:
      - include: '#quasi-embedded-raw'
      - include: source.coffee
    - begin: \s*+(ruby|rb)?\s*((`))
      contentName: source.embedded.nova
      end: \s*((`)(?!`))
      name: string.quasi.nova
      beginCaptures:
        1: {name: entity.name.tag.$1.nova}
        2: {name: string.quoted.template.nova}
        3: {name: punctuation.definition.quasi.begin.nova}
      endCaptures:
        1: {name: string.quoted.template.nova}
        2: {name: punctuation.definition.quasi.end.nova}
      patterns:
      - include: '#quasi-embedded-raw'
      - include: source.ruby
    - begin: \s*+(python|py)?\s*((`))
      contentName: source.embedded.nova
      end: \s*((`)(?!`))
      name: string.quasi.nova
      beginCaptures:
        1: {name: entity.name.tag.$1.nova}
        2: {name: string.quoted.template.nova}
        3: {name: punctuation.definition.quasi.begin.nova}
      endCaptures:
        1: {name: string.quoted.template.nova}
        2: {name: punctuation.definition.quasi.end.nova}
      patterns:
      - include: '#quasi-embedded-raw'
      - include: source.python
    - begin: \s*+(ya?ml)?\s*((`))
      contentName: source.embedded.nova
      end: \s*((`)(?!`))
      name: string.quasi.nova
      beginCaptures:
        1: {name: entity.name.tag.$1.nova}
        2: {name: string.quoted.template.nova}
        3: {name: punctuation.definition.quasi.begin.nova}
      endCaptures:
        1: {name: string.quoted.template.nova}
        2: {name: punctuation.definition.quasi.end.nova}
      patterns:
      - include: '#quasi-embedded-raw'
      - include: source.yaml
    - begin: \s*+(?!\b(?:return|void)\b)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)?\s*((`))
      contentName: string.quoted.template.nova
      end: \s*((`)(?!`))
      name: string.quasi.nova
      beginCaptures:
        1: {name: entity.name.tag.nova}
        2: {name: string.quoted.template.nova}
        3: {name: punctuation.definition.quasi.begin.nova}
      endCaptures:
        1: {name: string.quoted.template.nova}
        2: {name: punctuation.definition.quasi.end.nova}
      patterns:
      - include: '#quasi-embedded-raw'
  quasi-embedded:
    patterns:
    - match: |-
        (?xi)
        (?<!\\) # no backslash
        (\$) # prefix
        ([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*) # variable
        (?:(%)(
          \(.+?\)|
          \\?.[<=>^]?[+-]?\#?0?
          (?:\d*[-.,/_]?\.?\d*\w*%?)*
        ))? # printf modifier
      captures:
        1: {name: punctuation.quasi.element.nova}
        2: {patterns: [{include: '#variable'}]}
        3: {name: punctuation.separator.label.nova}
        4: {name: storage.type.format.nova}
    - begin: (?<!\\)(\$\{)\s*
      end: |-
        (?xi)\s*
        (\}) # closing brace
        (?:(%)(
          \(.+?\)|
          \\?.[<=>^]?[+-]?\#?0?
          (?:\d*[-.,/_]?\.?\d*\w*%?)*
        ))? # printf modifier
      name: entity.quasi.element.nova
      beginCaptures:
        1: {name: punctuation.quasi.element.begin.nova}
      endCaptures:
        1: {name: punctuation.quasi.element.end.nova}
        2: {name: punctuation.separator.label.nova}
        3: {name: storage.type.format.nova}
      patterns:
      - include: '#core'
  quasi-embedded-raw:
    patterns:
    - match: \$\$|``
      name: constant.character.escape.nova
    - match: |-
        (?xi)
        (?<!\$) # no dollar sign
        (\$) # prefix
        ([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*) # variable
        (?:(%)(
          \(.+?\)|
          \\?.[<=>^]?[+-]?\#?0?
          (?:\d*[-.,/_]?\.?\d*\w*%?)*
        ))? # printf modifier
      captures:
        1: {name: punctuation.quasi.element.nova}
        2: {patterns: [{include: '#variable'}]}
        3: {name: punctuation.separator.label.nova}
        4: {name: storage.type.format.nova}
    - begin: (?<!\$)(\$\{)\s*
      end: |-
        (?xi)\s*
        (\}) # closing brace
        (?:(%)(
          \(.+?\)|
          \\?.[<=>^]?[+-]?\#?0?
          (?:\d*[-.,/_]?\.?\d*\w*%?)*
        ))? # printf modifier
      name: entity.quasi.element.nova
      beginCaptures:
        1: {name: punctuation.quasi.element.begin.nova}
      endCaptures:
        1: {name: punctuation.quasi.element.end.nova}
        2: {name: punctuation.separator.label.nova}
        3: {name: storage.type.format.nova}
      patterns:
      - include: '#core'
  query:
    patterns:
    - begin: (?<![\#\.])\s*+\b(query)\b\s*
      end: \s*(in|of)\b
      beginCaptures:
        1: {name: keyword.query.nova}
      endCaptures:
        1: {name: keyword.query.nova}
      patterns:
      - include: '#let-clause'
      - include: '#core'
    - include: '#where-clause'
    - include: '#join-clause'
    - include: '#join-keywords'
    - include: '#order-direction'
    - include: '#order-clause'
    - include: '#group-clause'
    - include: '#select-clause'
    - include: '#order-clause'
    - include: '#fold-clause'
    - include: '#take-clause'
    repository:
      fold-clause:
        match: (?<![\#\.])\s*+\b((\b(fold|scan)\b)\s*(\b(left|right)\b)?\s*(\b(by|while|until|with)\b)?)\b\s*
        name: keyword.query.nova
      group-clause:
        begin: (?<![\#\.])\s*+\b(group)\b\s*
        end: \s*(by)\b
        beginCaptures:
          1: {name: keyword.query.nova}
        endCaptures:
          1: {name: keyword.query.nova}
        patterns:
        - include: '#let-clause'
        - include: '#core'
      join-clause:
        begin: (?<![\#\.])\s*+\b(join)\b\s*
        end: \s*(in|of)\b
        beginCaptures:
          1: {name: keyword.query.nova}
        endCaptures:
          1: {name: keyword.query.nova}
        patterns:
        - include: '#let-clause'
        - include: '#core'
      join-keywords:
        match: (?<![\#\.])\s*+\b(equals?|[io]nto)\b\s*
        name: keyword.query.nova
      let-clause:
        match: (?<![\#\.])\s*+\b(const|con|let|var|val)\b\s*
        name: storage.type.nova
      order-clause:
        match: (?<![\#\.])\s*+\b((\b(order)\b)\s*(\b(by)\b)?\s*(\b((a|de)sc)\b)?)\b\s*
        name: keyword.query.nova
      order-direction:
        match: (?<![\#\.])\s*+\b((a|de)sc)\b\s*
        name: keyword.query.nova
      select-clause:
        match: (?<![\#\.])\s*+\b(select)\b\s*
        name: keyword.query.nova
      take-clause:
        match: (?<![\#\.])\s*+\b((\b(take|drop)\b)\s*(\b(left|right|init|head|tail|last)\b)?\s*(\b(by|while|until|with)\b)?)\b\s*
        name: keyword.query.nova
      where-clause:
        match: (?<![\#\.])\s*+\b(where)\b\s*
        name: keyword.query.nova
  regex-group-name:
    patterns:
    - include: '#jsx-tag-attributes'
    - include: '#support'
    - include: '#keywords'
    - include: '#modifiers'
    - include: '#method-name'
    - include: '#function-name'
    - include: '#operator'
    - include: '#operators'
  regexp:
    begin: (?<=^|[\p{S}\p{Po}\p{Pd}\p{Ps}&&[^'"`]]|\b(?:in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)\s*+(\p{Alnum}*)(/)(?![*/])(?=.*/\p{Alnum}*\s*($|[,;\p{Pe}]|\.[_\\\p{L}\p{M}\p{N}]))
    end: (/)(?:((?:\\.|[^/])*)(/))?(\p{Alnum}*)
    name: string.regexp.nova
    beginCaptures:
      1: {name: keyword.modifier.nova}
      2: {name: punctuation.definition.string.begin.nova}
    endCaptures:
      1: {name: punctuation.definition.string.end.nova}
      2: {name: string.quoted.nova, patterns: [{include: '#backreferences'}]}
      3: {name: punctuation.definition.string.end.nova}
      4: {name: keyword.other.flag.nova}
    patterns:
    - include: '#regexp-patterns'
  regexp-multiline:
    patterns:
    - begin: ([[:alpha:]]*)(/>)\s*\n?
      end: \s*(\n?</)(\p{Alnum}*)
      name: string.regexp.multiline.nova
      beginCaptures:
        1: {name: keyword.modifier.nova}
        2: {name: punctuation.definition.string.begin.nova}
      endCaptures:
        1: {name: punctuation.definition.string.end.nova}
        2: {name: keyword.other.flag.nova}
      patterns:
      - include: '#heregexp'
    - begin: (?!\\)(?<=</)(>)\s*\n?
      contentName: string.quoted.nova
      end: \s*\n?(</)(\p{Alnum}*)
      name: string.regexp.nova
      beginCaptures:
        1: {name: punctuation.definition.string.begin.nova}
      endCaptures:
        1: {name: punctuation.definition.string.end.nova}
        2: {name: keyword.other.flag.nova}
      patterns:
      - include: '#backreferences'
  regexp-patterns:
    patterns:
    - include: '#quasi-embedded'
    - include: '#comments'
    - match: (?<!\\)(\//).*$\n?
      name: comment.line.shebang.nova
      captures:
        1: {name: punctuation.definition.comment.nova}
    - match: \|
      name: keyword.operator.or.nova
    - match: (?i)\\[abyz]({.*?})?
      name: keyword.control.anchor.nova
    - match: \^
      name: keyword.control.begin.nova
    - match: \$
      name: keyword.control.end.nova
    - match: \.
      name: constant.character.all.nova
    - match: (\\\()(?:(\?)|(\+)|(\*))
      captures:
        1: {name: constant.character.escape.other.nova}
        2: {name: keyword.operator.quantifier.lazy.nova}
        3: {name: keyword.operator.quantifier.eager.nova}
        4: {name: keyword.operator.quantifier.greedy.nova}
    - begin: (?<=\()(\?\{)
      end: \s*(\})([<*>])?(?:(\[)(.*)(\]))?
      name: keyword.operator.callout.nova
      beginCaptures:
        1: {name: keyword.operator.callout.nova}
        2: {name: keyword.operator.callout.nova}
      endCaptures:
        1: {name: keyword.operator.callout.nova}
        2: {name: keyword.operator.range.nova}
        3: {name: punctuation.definition.tag.nova}
        4: {patterns: [{include: $self}]}
        5: {name: punctuation.definition.tag.nova}
      patterns:
      - include: $self
    - begin: (?<=\()(\?<)
      end: \s*(>)
      name: punctuation.definition.group.named.nova
      beginCaptures:
        1: {name: punctuation.definition.group.named.nova}
      endCaptures:
        1: {name: punctuation.definition.group.named.nova}
      patterns:
      - include: '#regex-group-name'
    - match: (?<=\()(\?(?:([+-]?\d+?)|([A-Z\d]+(?:-[A-Z\d]+)?)|([a-z\d]+(?:-[a-z\d]+)?)))\s*(:)?
      name: keyword.control.back-reference.nova
      captures:
        1: {name: keyword.other.back-reference.nova}
        2: {name: entity.name.function.method.nova}
        3: {name: keyword.control.recursion.nova}
        4: {name: storage.type.nova}
        5: {name: punctuation.separator.label.nova}
    - match: (?<=\?\()(?:([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)|([+-]?\d*))(?=\))
      name: keyword.control.conditional.group.nova
      captures:
        1: {name: variable.other.nova}
        2: {name: keyword.other.back-reference.nova}
    - match: \\[1-9]\d*
      name: keyword.other.back-reference.nova
    - match: \{(\s*\d*\s*(?:,?\s*\d*\s*)*)\}\??
      name: keyword.operator.quantifier.nova
    - begin: (\\Q)
      contentName: string.quoted.double.nova
      end: (\\E)
      name: string.quoted.raw.nova
      beginCaptures:
        1: {name: punctuation.definition.string.begin.nova}
      endCaptures:
        1: {name: punctuation.definition.string.end.nova}
    - begin: (\\q)
      contentName: string.quoted.single.nova
      end: (\\e)
      name: string.quoted.nova
      beginCaptures:
        1: {name: punctuation.definition.string.begin.nova}
      endCaptures:
        1: {name: punctuation.definition.string.end.nova}
      patterns:
      - include: '#string-content'
    - begin: \((\?(?:&|P(=))(?:([+-]?\d+)|([_\\\p{L}\p{Nl}][_\\d\p{L}\p{M}\p{N}]*)|([+-]?\d*)))(:)?
      end: \s*(\))
      name: meta.group.nova
      beginCaptures:
        0: {name: punctuation.definition.group.nova}
        1: {name: keyword.other.back-reference.nova}
        2: {name: keyword.operator.assignment.nova}
        3: {name: entity.name.function.method.nova}
        4: {name: variable.other.nova}
        5: {name: punctuation.separator.label.nova}
      endCaptures:
        1: {name: punctuation.definition.group.nova}
      patterns:
      - include: '#regexp-patterns'
    - begin: \(([*+])
      end: \s*(\))
      name: constant.other.pcre.nova
      beginCaptures:
        0: {name: punctuation.definition.group.nova}
        1: {name: keyword.generator.nova}
      endCaptures:
        1: {name: punctuation.definition.group.nova}
      patterns:
      - include: '#mini-expression'
    - begin: (\()(\?#)
      contentName: comment.line.number-sign.nova
      end: \s*(\))
      name: comment.line.number-sign.nova
      beginCaptures:
        1: {name: punctuation.definition.group.nova}
        2: {name: punctuation.definition.comment.nova}
      endCaptures:
        1: {name: punctuation.definition.group.nova}
      patterns:
      - match: \\.
        name: comment.line.number-sign.nova
    - begin: (\()((\?=)|(\?!)|(\?<=)|(\?<!)|(\?>)|(?:(\?))(?=[(|])|(\?~))
      end: \s*(\))
      name: meta.group.nova
      beginCaptures:
        1: {name: punctuation.definition.group.nova}
        2: {name: punctuation.definition.group.assertion.nova}
        3: {name: meta.assertion.look-ahead.nova}
        4: {name: meta.assertion.negative-look-ahead.nova}
        5: {name: meta.assertion.look-behind.nova}
        6: {name: meta.assertion.negative-look-behind.nova}
        7: {name: meta.group.atomic.nova}
        8: {name: meta.group.branch.nova}
        9: {name: meta.group.absent.nova}
      endCaptures:
        1: {name: punctuation.definition.group.nova}
      patterns:
      - include: '#regexp-patterns'
    - begin: \((?:(\?:)|(?:\?<(.*?)>))?
      end: \s*(\))
      name: meta.group.nova
      beginCaptures:
        0: {name: punctuation.definition.group.nova}
        1: {name: punctuation.definition.group.no-capture.nova}
        2: {patterns: [{include: '#regex-group-name'}]}
      endCaptures:
        0: {name: punctuation.definition.group.nova}
      patterns:
      - include: '#regexp-patterns'
    - begin: (\\k<)
      end: \s*(>)
      name: keyword.other.back-reference.nova
      beginCaptures:
        1: {name: keyword.other.back-reference.nova}
      endCaptures:
        1: {name: keyword.other.back-reference.nova}
      patterns:
      - include: '#jsx-tag-attributes'
      - include: '#support'
      - include: '#keywords'
      - include: '#modifiers'
      - include: '#method-name'
      - include: '#function-name'
      - include: '#operators'
    - begin: (\\g<)
      end: \s*(>)
      name: keyword.other.subroutine.nova
      beginCaptures:
        1: {name: keyword.other.subroutine.nova}
      endCaptures:
        1: {name: keyword.other.subroutine.nova}
      patterns:
      - include: '#jsx-tag-attributes'
      - include: '#support'
      - include: '#keywords'
      - include: '#modifiers'
      - include: '#method-name'
      - include: '#function-name'
      - include: '#operators'
    - begin: (\[)(\^)?
      end: \s*(\])
      name: constant.other.character-class.set.nova
      beginCaptures:
        1: {name: punctuation.definition.character-class.nova}
        2: {name: keyword.operator.negation.nova}
      endCaptures:
        1: {name: punctuation.definition.character-class.nova}
      patterns:
      - include: '#comments'
      - match: '--'
        name: keyword.operator.optional.nova
      - include: '#regex-character-class'
      - include: '#regex-character-range'
      - include: '#regex-character-set'
    - begin: (\{)
      end: \s*(\})
      name: meta.brace.curly.litobj.nova
      patterns:
      - include: '#regexp-patterns'
    - include: '#regex-character-class'
    - match: (?i)\\(?:(M)|(K)|(G)|(X))
      captures:
        1: {name: keyword.control.anchor.nova}
        2: {name: keyword.control.keepout.nova}
        3: {name: keyword.control.search.nova}
        4: {name: constant.character.unicode.nova}
    - match: \\.
      name: constant.character.escape.other.nova
    - match: (?<=[*+?}])(?:(\?)|(\+)|(\*))
      captures:
        1: {name: keyword.operator.modifier.lazy.nova}
        2: {name: keyword.operator.modifier.eager.nova}
        3: {name: keyword.operator.modifier.greedy.nova}
    - match: (\?)|(\+)|(\*)
      captures:
        1: {name: keyword.operator.quantifier.lazy.nova}
        2: {name: keyword.operator.quantifier.eager.nova}
        3: {name: keyword.operator.quantifier.greedy.nova}
    repository:
      regex-character-class:
        patterns:
        - match: (\\)(?=\s*$)
          name: constant.character.escape.newline.nova
        - begin: (?i)(\\p{)
          end: \s*(})
          name: constant.other.character-class.unicode.nova
          beginCaptures:
            1: {name: constant.other.character-class.unicode.nova}
          endCaptures:
            1: {name: constant.other.character-class.unicode.nova}
          patterns:
          - include: '#keywords'
          - include: '#implicit-call'
          - include: '#operators'
        - match: \\x\h{2}|\\U\h{8}
          name: constant.character.escape.hex.nova
        - match: \\[cCmM]\p{L}|\R
          name: constant.character.control.nova
        - match: \\[pP]\p{L}{1,2}|\\O
          name: constant.other.character-class.unicode.nova
        - match: (?i)\\[ci]
          name: constant.other.character-class.xml.nova
        - match: \\[ux](({[\h\s]+\})|\h{4})
          name: constant.character.escape.unicode.nova
        - begin: (?i)\\j{
          end: \s*}
          name: constant.character.entity.named.nova
          beginCaptures:
            1: {name: constant.character.entity.named.nova}
          endCaptures:
            1: {name: constant.character.entity.named.nova}
          patterns:
          - include: '#implicit-call'
          - include: '#regexp-patterns'
        - match: \.|\\[wsdvntluh]
          name: constant.other.character-class.nova
        - match: \\[WSDVNTLUH]
          name: constant.other.character-class.negated.nova
        - match: \\N{[\w\s]+}
          name: constant.character.escape.unicode.name.nova
        - match: \\o{[0-7]+}
          name: constant.character.escape.octal.nova
        - match: \\['"\\nrtfve0`]
          name: constant.character.escape.nova
      regex-character-range:
        patterns:
        - match: (?:.|(\\(?:[0-7]{3}|x\h{2}|u\h{4}))|(\\c[a-zA-Z])|(\\.))\-(?:[^\]\\]|(\\(?:[0-7]{3}|x\h{2}|u\h{4}))|(\\c[a-zA-Z])|(\\.))
          name: constant.other.character-class.range.nova
          captures:
            1: {name: constant.character.numeric.nova}
            2: {name: constant.character.control.nova}
            3: {name: constant.character.escape.backslash.nova}
            4: {name: constant.character.numeric.nova}
            5: {name: constant.character.control.nova}
            6: {name: constant.character.escape.backslash.nova}
      regex-character-set:
        patterns:
        - match: \|{2}
          name: keyword.operator.union.nova
        - match: '&{2}'
          name: keyword.operator.intersection.nova
        - match: \^{2}
          name: keyword.operator.only.nova
        - match: ~{2}
          name: keyword.operator.maybe.nova
        - match: \.
          name: constant.other.character-class.set.nova
        - begin: (\[=)
          end: \s*(=\])
          name: constant.other.character-class.posix.nova
          beginCaptures:
            1: {name: punctuation.definition.character-class.posix.nova}
          endCaptures:
            1: {name: punctuation.definition.character-class.posix.nova}
          patterns:
          - include: '#comments'
          - include: '#variables'
          - include: '#operators'
        - begin: (\[\.)
          end: \s*(\.\])
          name: constant.other.character-class.posix.nova
          beginCaptures:
            1: {name: punctuation.definition.character-class.posix.nova}
          endCaptures:
            1: {name: punctuation.definition.character-class.posix.nova}
          patterns:
          - include: '#comments'
          - include: '#variables'
          - include: '#operators'
        - begin: (\[:)
          end: \s*(:\])
          name: constant.other.character-class.posix.nova
          beginCaptures:
            1: {name: punctuation.definition.character-class.posix.nova}
          endCaptures:
            1: {name: punctuation.definition.character-class.posix.nova}
          patterns:
          - include: '#comments'
          - include: '#variables'
          - include: '#operators'
        - begin: (\[)(\^)?
          end: \s*(\])
          name: constant.other.character-class.set.nova
          beginCaptures:
            1: {name: punctuation.definition.character-class.nova}
            2: {name: keyword.operator.negation.nova}
          endCaptures:
            1: {name: punctuation.definition.character-class.nova}
          patterns:
          - include: '#comments'
          - match: '--'
            name: keyword.operator.optional.nova
          - include: '#regex-character-range'
          - include: '#regex-character-class'
          - include: '#regex-character-set'
          - match: \\.
            name: constant.character.escape.other.nova
        - match: \\.
          name: constant.character.escape.other.nova
  round-brackets:
    patterns:
    - begin: \s*+(#?\(\|)
      end: \s*(\|\))
      beginCaptures:
        1: {name: meta.brace.round.nova}
      endCaptures:
        1: {name: meta.brace.round.nova}
      patterns:
      - include: '#core'
    - begin: \s*+(\#\()
      end: \s*(\))
      beginCaptures:
        1: {name: meta.brace.round.nova}
      endCaptures:
        1: {name: meta.brace.round.nova}
      patterns:
      - include: '#core'
    - begin: \s*+(\()
      end: \s*(\))
      beginCaptures:
        1: {name: meta.brace.round.nova}
      endCaptures:
        1: {name: meta.brace.round.nova}
      patterns:
      - include: '#core'
  semi-colon:
    patterns:
    - match: \s*+(;)
      captures:
        1: {name: punctuation.terminator.statement.nova}
  sigils:
    patterns:
    - match: (\^)[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*
      captures:
        0: {name: constant.other.symbol.nova}
        1: {name: punctuation.definition.symbol.nova}
    - match: (\&)[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*
      captures:
        0: {name: constant.other.label.nova}
        1: {name: punctuation.definition.variable.nova}
    - match: (\%)[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*
      captures:
        0: {name: constant.other.global.nova}
        1: {name: punctuation.definition.tag.nova}
    - match: (\*)[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*
      captures:
        0: {name: constant.other.rest.nova}
        1: {name: punctuation.definition.rest.nova}
    - match: (\|)[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*
      captures:
        0: {name: constant.language.nova}
        1: {name: punctuation.definition.constant.nova}
  special-comments-conditional-compilation:
    patterns:
    - begin: \s*+((/\*))(?=@)
      contentName: comment.block.conditional.nova
      end: \s*\*/
      captures:
        1: {name: comment.block.conditional.nova}
        2: {name: punctuation.definition.comment.nova}
      endCaptures:
        1: {name: keyword.control.conditional.nova}
        2: {name: punctuation.definition.keyword.nova}
      patterns:
      - match: \s*+/\*
        name: punctuation.definition.comment.nova
      - include: $self
    - match: \s*+(?!@)(@)(if|elif|else|end|ifdef|endif|cc_on|set)\b
      name: keyword.control.conditional.nova
      captures:
        1: {name: punctuation.definition.keyword.nova}
    - match: \s*+(?!@)(@)(_win32|_win16|_mac|_alpha|_x86|_mc680x0|_PowerPC|_jscript|_jscript_build|_jscript_version|_debug|_fast|[a-zA-Z]\w+)
      name: variable.other.conditional.nova
      captures:
        1: {name: punctuation.definition.variable.nova}
  square-brackets:
    patterns:
    - begin: \s*+(#?\[\|)
      end: \s*(\|\])
      beginCaptures:
        1: {name: meta.brace.square.nova}
      endCaptures:
        1: {name: meta.brace.square.nova}
      patterns:
      - match: \s*:(?![:<=>])\s*
        name: keyword.operator.slice.nova
      - include: '#object'
      - include: '#core'
    - begin: \s*+(\#\[)
      end: \s*(\])
      beginCaptures:
        1: {name: meta.brace.square.nova}
      endCaptures:
        1: {name: meta.brace.square.nova}
      patterns:
      - match: \s*:(?![:<=>])\s*
        name: keyword.operator.slice.nova
      - include: '#object'
      - include: '#core'
    - begin: \s*+(\[)
      end: \s*(\])
      beginCaptures:
        1: {name: meta.brace.square.nova}
      endCaptures:
        1: {name: meta.brace.square.nova}
      patterns:
      - match: \s*:(?![:<=>])\s*
        name: keyword.operator.slice.nova
      - include: '#object'
      - include: '#core'
  string:
    patterns:
    - begin: \s*+(('))
      contentName: string.quoted.single.nova
      end: |-
        \s*+(?:(('))|(
        ))
      beginCaptures:
        1: {name: string.quoted.single.nova}
        2: {name: punctuation.definition.string.begin.nova}
      endCaptures:
        1: {name: string.quoted.single.nova}
        2: {name: punctuation.definition.string.end.nova}
        3: {name: invalid.illegal.newline.nova}
      patterns:
      - include: '#string-content'
    - begin: \s*+(("))
      contentName: string.quoted.double.nova
      end: |-
        \s*+(?:(("))|(
        ))
      beginCaptures:
        1: {name: string.quoted.double.nova}
        2: {name: punctuation.definition.string.begin.nova}
      endCaptures:
        1: {name: string.quoted.double.nova}
        2: {name: punctuation.definition.string.end.nova}
        3: {name: invalid.illegal.newline.nova}
      patterns:
      - include: '#string-content'
  string-content:
    patterns:
    - match: (\\)(?=\s*$)
      name: constant.character.escape.newline.nova
    - match: |-
        (?xi)
        (\\b(?:[01]{1,21}|{[01\s]+?})) # base 2
        |(\\q(?:[0-3]{1,11}|{[0-3\s]+?})) # base 4
        |(\\s(?:[0-5]{1,8}|{[0-5\s]+?})) # base 6
        |(\\o(?:[0-7]{1,7}|{[0-7\s]+?})) # base 8 
        |(\\d?\d{1,7}|\\d{[\d\s]+?}) # base 10
        |(\\z(?:[\dabetxz]{1,6}|{[\s\dabetxz]+?})) # base 12
        |(\\x(?:\h{1,6}|{[\h\s]+?})) # base 14 
        |(\\u(?:\h{1,6}|{[\h\s]+?})) # base 16
      captures:
        1: {name: constant.character.escape.binary.nova}
        2: {name: constant.character.escape.quaternary.nova}
        3: {name: constant.character.escape.senary.nova}
        4: {name: constant.character.escape.octal.nova}
        5: {name: constant.character.escape.decimal.nova}
        6: {name: constant.character.escape.duodecimal.nova}
        7: {name: constant.character.escape.hexadecimal.nova}
        8: {name: constant.character.escape.unicode.nova}
    - begin: (?i)\\j{
      end: \s*}
      name: constant.character.entity.named.nova
      beginCaptures:
        1: {name: constant.character.entity.named.nova}
      endCaptures:
        1: {name: constant.character.entity.named.nova}
      patterns:
      - include: '#implicit-call'
      - include: '#regexp-patterns'
    - match: (?i)\\[anrtbfveclzp]
      name: constant.character.escape.nova
    - match: \\[\P{L}&&[\P{N}]]
      name: constant.character.escape.symbol.nova
    - match: \\[\p{L}\p{N}]
      name: constant.character.escape.illegal.nova
    - include: '#quasi-embedded'
  support:
    patterns:
    - match: |-
        (?x) (?<![\#\.]) \s*+ \b(
          (
            Arithmetic | Assertion | Attribute | Buffer | BlockingIO
            | BrokenPipe | ChildProcess
            | (Connection (Aborted | Refused | Reset)?)
            | EOF | Environment | FileExists | FileNotFound
            | FloatingPoint | IO | Import | Indentation | Index | Interrupted
            | IsADirectory | NotADirectory | Permission | ProcessLookup
            | Timeout
            | Key | Lookup | Memory | Name | NotImplemented | OS | Overflow
            | Reference | Runtime | Recursion | Syntax | System
            | Tab | Type | UnboundLocal | Unicode(Encode|Decode|Translate)?
            | Value | Windows | ZeroDivision | ModuleNotFound
          ) Error
        |
          ((Pending)?Deprecation | Runtime | Syntax | User | Future | Import
            | Unicode | Bytes | Resource
          )? Warning
        |
          SystemExit | Stop(Async)?Iteration
          | KeyboardInterrupt
          | GeneratorExit | (Base)?Error
        )\b
      name: support.class.error.nova
    - applyEndPatternLast: 1
      begin: \s*+\b(WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|String|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|Number|Math|Map|JSON|InternalError|Int8Array|Int32Array|Int16Array|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.class.builtin.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+\b((SIMD)((\.)(Uint8x16|Uint32x4|Uint16x8|Int8x16|Int32x4|Int16x8|Float64x2|Float32x4|Bool8x16|Bool64x2|Bool32x4|Bool16x8))?)\b
      end: (?=.)
      beginCaptures:
        2: {name: support.class.builtin.nova}
        4: {name: keyword.operator.accessor.nova}
        5: {name: support.class.builtin.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+\b((Intl)((\.)(NumberFormat|DateTimeFormat|Collator))?)\b
      end: (?=.)
      beginCaptures:
        2: {name: support.class.builtin.nova}
        4: {name: keyword.operator.accessor.nova}
        5: {name: support.class.builtin.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: (?<![\#\.])\s*+\b((Eval|Range|Reference|Syntax|Type|URI)?Error)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.class.error.nova}
      patterns:
      - include: '#round-brackets'
    - match: (?<![\#\.])\s*+\b(debug|assert|check)\b
      captures:
        1: {name: keyword.other.nova}
    - match: (?<![\#\.])\s*+\b(doc|event|navi|perf|scrn|win)\b
      captures:
        1: {name: support.type.object.dom.nova}
    - match: \s*+\b(ELEMENT_NODE|ATTRIBUTE_NODE|TEXT_NODE|CDATA_SECTION_NODE|ENTITY_REFERENCE_NODE|ENTITY_NODE|PROCESSING_INSTRUCTION_NODE|COMMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE|DOCUMENT_FRAGMENT_NODE|NOTATION_NODE|INDEX_SIZE_ERR|DOMSTRING_SIZE_ERR|HIERARCHY_REQUEST_ERR|WRONG_DOCUMENT_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR|NOT_SUPPORTED_ERR|INUSE_ATTRIBUTE_ERR)\b
      captures:
        1: {name: support.constant.dom.nova}
    - applyEndPatternLast: 1
      begin: (?<![\#\.])\s*+\b(console)(?:(\.)(warn|info|log|error|time|timeEnd|assert))?\b
      end: (?=.)
      beginCaptures:
        1: {name: support.type.object.console.nova}
        2: {name: keyword.operator.accessor.nova}
        3: {name: support.function.console.nova}
      patterns:
      - include: '#round-brackets'
    - match: (?<![\#\.])\s*+\b(process)(?:(\.)(stdout|stderr|stdin|argv|execPath|execArgv|env|exitCode|version|versions|config|pid|title|arch|platform|mainModule))?\b
      captures:
        1: {name: support.type.object.process.nova}
        2: {name: keyword.operator.accessor.nova}
        3: {name: support.type.object.process.nova}
    - applyEndPatternLast: 1
      begin: (?<![\#\.])\s*+\b(process)(?:(\.)(abort|chdir|cwd|exit|getgid|setgid|getuid|setuid|setgroups|getgroups|initgroups|kill|memoryUsage|nextTick|umask|uptime|hrtime))?\b
      end: (?=.)
      beginCaptures:
        1: {name: support.type.object.process.nova}
        2: {name: keyword.operator.accessor.nova}
        3: {name: support.function.process.nova}
      patterns:
      - include: '#round-brackets'
    - match: (((?<![\#\.])\s*+\bmodule\.((?<!\,)exports|id|require|parent|filename|loaded|children)|exports))\b
      captures:
        1: {name: support.type.object.module.nova}
        2: {name: keyword.operator.accessor.nova}
        3: {name: support.type.object.module.nova}
    - match: (?<![\#\.])\s*+\b(global|GLOBAL|root|__dirname|__filename)\b
      captures:
        1: {name: support.type.object.node.nova}
    - applyEndPatternLast: 1
      begin: \s*+\b(Buffer|EventEmitter|Server|Pipe|Socket|REPLServer|ReadStream|WriteStream|Stream|Inflate|Deflate|InflateRaw|DeflateRaw|GZip|GUnzip|Unzip|Zip)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.class.node.nova}
      patterns:
      - include: '#round-brackets'
    - begin: \s*+({{)
      contentName: meta.tag.mustache.nova
      end: (\s*}})
      captures:
        1: {name: meta.tag.mustache.nova}
    - include: '#support-objects'
  support-functions:
    patterns:
    - include: '#support-python'
  support-methods:
    patterns:
    - include: '#support-python'
    - applyEndPatternLast: 1
      begin: (?<![\#\.])\s*+(shift|sort|splice|unshift|pop|push|reverse)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.mutator.nova}
    - applyEndPatternLast: 1
      begin: (?<![\#\.])\s*+(decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|isFinite|isNaN|parseFloat|parseInt|unescape)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(add|append|at|average|chunk|clone|compact|concat|construct|copyWithin|count|create|difference|differenceBy|differenceWith|drop|dropRight|dropRightWhile|dropWhile|entries|every|exclude|fill|filter|find|findIndex|findLastIndex|first|flat|flatMap|flatten|flattenDeep|flattenDepth|fnFromIndex|forEach|from|fromPairs|groupBy|head|includes|indexOf|inGroups|inGroupsOf|initial|insert|intersect|intersection|intersectionBy|intersectionWith|isArray|isEmpty|isEqual|join|keys|last|lastIndexOf|least|map|max|median|min|most|none|nth|object|of|pop|pull|pullAll|pullAllBy|pullAllWith|pullAt|push|range|reduce|reduceRight|remove|removeAt|rest|reverse|sample|shift|shuffle|slice|some|sort|sortBy|sortedIndex|sortedIndexBy|sortedIndexOf|sortedLastIndex|sortedLastIndexBy|sortedLastIndexOf|sortedUniq|sortedUniqBy|splice|subtract|sum|tail|take|takeRight|takeRightWhile|takeWhile|to|toLocaleString|toSource|toString|union|unionBy|unionWith|uniq|uniqBy|unique|uniqWith|unshift|unzip|unzipWith|values|without|xor|xorBy|xorWith|zip|zipObject|zipObjectDeep|zipWith)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.array.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(add|and|clamp|clone|compareExchange|contains|dateUnit|every|exchange|intersect|isLockFree|isValid|load|notify|or|span|store|sub|toArray|toString|union|wait|xor)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.atomics.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(asIntN|asUintN|toLocaleString|toString|valueOf)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.bigint.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(toSource|toString|valueOf)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.boolean.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(contains|countBy|each|eachRight|every|filter|find|findLast|findWhere|flatMap|flatMapDeep|flatMapDepth|forEach|forEachRight|groupBy|includes|indexBy|invoke|invokeMap|keyBy|map|max|min|orderBy|partition|pluck|reduce|reduceRight|reject|sample|sampleSize|shuffle|size|some|sortBy|toArray|where)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.collection.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(getBigInt64|getBigUint64|getFloat32|getFloat64|getInt16|getInt32|getInt8|getUint16|getUint32|getUint8|setBigInt64|setBigUint64|setFloat32|setFloat64|setInt16|setInt32|setInt8|setUint16|setUint32|setUint8)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.dataview.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(addLocale|addUnits|advance|beginningOfISOWeek|beginningOfUnit|clone|create|daysInMonth|endOfISOWeek|endOfUnit|format|full|get|getAllLocaleCodes|getAllLocales|getDate|getDay|getFullYear|getHours|getISOWeek|getLocale|getMilliseconds|getMinutes|getMonth|getOption|getSeconds|getTime|getTimezoneOffset|getUTCDate|getUTCDay|getUTCFullYear|getUTCHours|getUTCMilliseconds|getUTCMinutes|getUTCMonth|getUTCOffset|getUTCSeconds|getUTCWeekday|getWeekday|getYear|is|isAfter|isBefore|isBetween|isDay|isFuture|isLastUnit|isLeapYear|isNextUnit|iso|isPast|isThisUnit|isUTC|isValid|long|medium|now|parse|range|relative|relativeTo|removeLocale|reset|rewind|set|setDate|setFullYear|setHours|setISOWeek|setLocale|setMilliseconds|setMinutes|setMonth|setOption|setSeconds|setTime|setUTC|setUTCDate|setUTCFullYear|setUTCHours|setUTCMilliseconds|setUTCMinutes|setUTCMonth|setUTCSeconds|setWeekday|setYear|short|toDateString|toGMTString|toISOString|toJSON|toLocaleDateString|toLocaleString|toLocaleTimeString|toSource|toString|toTimeString|toUTCString|unitsAgo|unitsFromNow|unitsSince|unitsUntil|UTC|valueOf)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.date.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(__|add|addIndex|adjust|after|all|allpass|fail|always|and|andThen|any|anypass|fail|ap|aperture|append|apply|applySpec|applyTo|ary|ascend|assoc|assocPath|before|binary|bind|bindAll|bindKey|both|call|cancel|chain|clamp|clone|comparator|complement|compose|composeK|composeP|composeWith|concat|cond|construct|constructN|contains|converge|countBy|curry|curryN|curryRight|debounce|dec|defaultTo|defer|delay|descend|difference|differenceWith|dissoc|dissocPath|divide|drop|dropLast|dropLastWhile|dropRepeats|dropRepeatsWith|dropWhile|either|empty|endsWith|eqBy|eqProps|equals|every|evolve|F|filter|find|findIndex|findLast|findLastIndex|flatten|flip|forEach|forEachObjIndexed|fromPairs|groupBy|groupWith|gt|gte|has|hasIn|hasPath|head|identical|identity|ifElse|inc|includes|indexBy|indexOf|init|innerJoin|insert|insertAll|intersection|intersperse|into|invert|invertObj|invoker|is|isEmpty|isNil|join|juxt|keys|keysIn|last|lastIndexOf|lazy|length|lens|lensIndex|lensPath|lensProp|lift|liftN|lock|lt|lte|map|mapAccum|mapAccumRight|mapObjIndexed|match|mathMod|max|maxBy|mean|median|memoize|memoizeWith|merge|mergeAll|mergeDeepLeft|mergeDeepRight|mergeDeepWith|mergeDeepWithKey|mergeLeft|mergeRight|mergeWith|mergeWithKey|min|minBy|modulo|move|multiply|nAry|negate|none|not|nth|nthArg|o|objOf|of|omit|once|or|otherwise|over|overArgs|pair|partial|partialRight|partition|path|pathEq|pathOr|paths|pathSatisfies|pick|pickAll|pickBy|pipe|pipeK|pipeP|pipeWith|pluck|prepend|product|project|prop|propEq|propIs|propOr|props|propSatisfies|range|rearg|reduce|reduceBy|reduced|reduceRight|reduceWhile|reject|remove|repeat|replace|rest|restArguments|reverse|scan|sequence|set|slice|sort|sortBy|sortWith|split|splitAt|splitEvery|splitWhen|spread|startsWith|subtract|sum|symmetricDifference|symmetricDifferenceWith|T|tail|take|takeLast|takeLastWhile|takeWhile|tap|test|throttle|thunkify|times|toLower|toPairs|toPairsIn|toSource|toString|toUpper|transduce|transpose|traverse|trim|tryCatch|type|unapply|unary|uncurryN|unfold|union|unionWith|uniq|uniqBy|uniqWith|unless|unnest|until|update|useWith|values|valuesIn|view|when|where|whereEq|without|wrap|xor|xprod|zip|zipObj|zipWith)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.function.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(next|return|throw)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.generator.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(chain|parse|stringify|value)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.json.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(castArray|clone|cloneDeep|cloneDeepWith|cloneWith|conformsTo|eq|gt|gte|isArguments|isArray|isArrayBuffer|isArrayLike|isArrayLikeObject|isBoolean|isBuffer|isDate|isElement|isEmpty|isError|iSetual|iSetualWith|isFinite|isFunction|isInteger|isLength|isMap|isMatch|isMatchWith|isNaN|isNative|isNil|isNull|isNumber|isObject|isObjectLike|isPlainObject|isProxy|isRegExp|isSafeInteger|isSet|isString|isSymbol|isUndefined|isWeakMap|isWeakSet|lt|lte|toArray|toFinite|toInteger|toLength|toNumber|toPlainObject|toSafeInteger|toString)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.lang.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(clear|delete|entries|forEach|get|has|keys|set|values)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.map.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(abs|acos|acosh|acot|acoth|acsc|acsch|add|and|apply|arg|asec|asech|asin|asinh|atan|atan2|atanh|bellNumbers|bin|bitAnd|bitNot|bitOr|bitXor|catalan|cbrt|ceil|clone|clz32|column|combinations|combinationsWithRep|compare|compareNatural|compareText|compile|composition|concat|conj|cos|cosh|cot|coth|count|cross|csc|csch|ctranspose|cube|deepEqual|derivative|det|diag|diff|distance|divide|dot|dotDivide|dotMultiply|dotPow|eigs|equal|equalText|erf|evaluate|exp|expm|expm1|factorial|filter|fix|flatten|floor|forEach|format|fround|gamma|gcd|getMatrixDataType|hasNumericValue|help|hex|hypot|identity|im|imul|intersect|inv|isInteger|isNaN|isNegative|isNumeric|isPositive|isPrime|isZero|kldivergence|kron|larger|largerEq|lcm|leftShift|log|log10|log1p|log2|lsolve|lup|lusolve|mad|map|max|maxBy|mean|meanBy|median|min|minBy|mod|mode|multinomial|multiply|norm|not|nthRoot|nthRoots|numeric|oct|ones|or|parser|partitionSelect|permutations|pickRandom|pow|print|prod|qr|quantileSeq|random|randomInt|range|rationalize|re|reshape|resize|rightArithShift|rightLogShift|rotate|rotationMatrix|round|row|sec|sech|setCartesian|setDifference|setDistinct|setIntersect|setIsSubset|setMultiplicity|setPowerset|setSize|setSymDifference|setUnion|sign|simplify|sin|sinh|size|slu|smaller|smallerEq|sort|sqrt|sqrtm|square|squeeze|std|stirlingS2|subset|subtract|sum|sumBy|tan|tanh|to|trace|transpose|trunc|typeOf|unaryMinus|unaryPlus|unequal|usolve|variance|xgcd|xor|zeros)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.math.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(abbr|bytes|cap|ceil|chr|clamp|dateUnit|dateUnitAfter|dateUnitAgo|dateUnitBefore|dateUnitFromNow|downto|duration|floor|format|hex|inRange|isEven|isFinite|isInteger|isMultipleOf|isNaN|isOdd|isSafeInteger|log|math|metric|ordinalize|pad|parseFloat|parseInt|random|range|round|times|toExponential|toFixed|toLocaleString|toNumber|toPrecision|toSource|toString|upto|valueOf)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.number.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(__defineGetter__|__defineSetter__|__lookupGetter__|__lookupSetter__|add|addAll|allKeys|assign|assignIn|assignInWith|assignWith|at|average|clone|count|create|defaults|defaultsDeep|defineProperties|defineProperty|entries|entriesIn|every|exclude|extend|extendOwn|extendWith|filter|find|findKey|findLastKey|forEach|forIn|forInRight|forOwn|forOwnRight|freeze|fromEntries|fromQueryString|functions|functionsIn|get|getOwnPropertyDescriptor|getOwnPropertyDescriptors|getOwnPropertyNames|getOwnPropertySymbols|getPrototypeOf|has|hasIn|hasOwnProperty|intersect|invert|invertBy|invoke|is|isArguments|isArray|isArrayBuffer|isBoolean|isDataView|isDate|isElement|isEmpty|isEqual|isError|isExtensible|isFinite|isFrozen|isFunction|isMap|isMatch|isNaN|isNull|isNumber|isObject|isPrototypeOf|isRegExp|isSealed|isSet|isString|isSymbol|isType|isTypedArray|isUndefined|isWeakMap|isWeakSet|keys|keysIn|least|map|mapKeys|mapObject|mapValues|matcher|max|median|merge|mergeAll|mergeWith|min|most|none|omit|omitBy|pairs|pick|pickBy|preventExtensions|property|propertyIsEnumerable|propertyOf|reduce|reject|remove|result|seal|select|set|setPrototypeOf|setWith|size|some|subtract|sum|tap|toLocaleString|toPairs|toPairsIn|toPath|toQueryString|toSource|toString|transform|unset|update|updateWith|valueOf|values|valuesIn)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.object.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(all|allSettled|any|catch|finally|race|reject|resolve|then)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.promise.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(apply|construct|defineProperty|deleteProperty|get|getOwnPropertyDescriptor|getPrototypeOf|has|isExtensible|ownKeys|preventExtensions|register|set|setPrototypeOf|unregister)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.proxy.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(address|age|altitude|ampm|android_id|animal|apple_token|areacode|avatar|bb_pin|birthday|bool|capitalize|cc|cc_type|cf|character|city|coin|color|company|coordinates|country|cpf|currency|currency_pair|date|depth|dice|dollar|domain|email|euro|exp|exp_month|exp_year|falsy|fbid|first|floating|gender|geohash|google_analytics|guid|hammertime|hash|hashtag|hidden|hour|integer|ip|ipv6|klout|last|latitude|letter|locale|longitude|millisecond|minute|mixin|month|n|name|natural|normal|pad|paragraph|phone|pick|pickone|pickset|postal|postcode|prefix|prime|profession|province|radio|rpg|second|sentence|set|shuffle|ssn|state|street|string|suffix|syllable|timestamp|timezone|tld|tv|twitter|unique|url|weekday|weighted|word|wp7_anid|wp8_anid2|year|zip)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.random.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(addFlags|compile|escape|exec|getFlags|removeFlags|setFlags|test|toSource|toString)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.regexp.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(at|chain|commit|next|plant|prototype|reverse|tap|thru|toJSON|value|valueOf)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.seq.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(add|clear|delete|entries|forEach|has|values)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.set.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(addAcronym|addHuman|addPlural|anchor|at|big|blink|bold|camelCase|camelize|capitalize|chain|charAt|charCodeAt|chars|codePointAt|codePoints|codes|compact|concat|count|countGraphemes|countSubstrings|countWhere|countWords|dasherize|deburr|decapitalize|decodeBase64|encodeBase64|endsWith|escape|escapeHtml|escapeHTML|escapeRegExp|escapeURL|first|fixed|fontcolor|fontsize|forEach|format|from|fromCharCode|fromCodePoint|graphemeAt|graphemes|hankaku|hasScript|hiragana|humanize|includes|indexOf|insert|isAlpha|isAlphaDigit|isBlank|isDigit|isEmpty|isLowerCase|isNumeric|isScript|isString|isUpperCase|italics|katakana|kebabCase|last|lastIndexOf|latinise|lines|link|localeCompare|lowerCase|lowerFirst|match|matchAll|matches|normalize|pad|padEnd|padLeft|padRight|padStart|parameterize|parseInt|pluralize|prune|range|raw|remove|removeAll|removeTags|repeat|replace|replaceAll|reverse|reverseGrapheme|search|shift|singularize|slice|slugify|small|snakeCase|spacify|splice|split|sprintf|startCase|startsWith|strike|stripBom|stripTags|sub|substr|substring|sup|swapCase|template|thru|titleCase|titleize|to|toLocaleLowerCase|toLocaleUpperCase|toLower|toLowerCase|toNumber|toSource|toString|toUpper|toUpperCase|tr|trim|trimEnd|trimLeft|trimRight|trimStart|truncate|truncateOnWord|underscore|unescape|unescapeHtml|unescapeHTML|unescapeURL|upperCase|upperFirst|value|valueOf|vprintf|words|wordWrap|zenkaku)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.string.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(for|keyFor|toSource|toString|valueOf)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.symbol.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(at|copyWithin|entries|every|fill|filter|find|findIndex|forEach|from|includes|indexOf|join|keys|lastIndexOf|map|of|reduce|reduceRight|reverse|set|slice|some|sort|subarray|toLocaleString|toString|values)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.typedarray.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(attempt|bindAll|cond|conforms|constant|defaultTo|escape|flow|flowRight|identity|iteratee|matches|matchesProperty|method|methodOf|mixin|noConflict|noop|now|nthArg|over|overEvery|overSome|property|propertyOf|random|range|rangeRight|result|runInContext|stubArray|stubFalse|stubObject|stubString|stubTrue|template|times|toPath|unescape|uniqueId)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.util.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(compile|compileStreaming|instantiate|instantiateStreaming|validate)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.webassembly.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(on(?:Rowsinserted|Rowsdelete|Rowenter|Rowexit|Resize|Resizestart|Resizeend|Reset|Readystatechange|Mouseout|Mouseover|Mousedown|Mouseup|Mousemove|Before(?:cut|deactivate|unload|update|paste|print|editfocus|activate)|Blur|Scrolltop|Submit|Select|Selectstart|Selectionchange|Hover|Help|Change|Contextmenu|Controlselect|Cut|Cellchange|Clock|Close|Deactivate|Datasetchanged|Datasetcomplete|Dataavailable|Drop|Drag|Dragstart|Dragover|Dragdrop|Dragenter|Dragend|Dragleave|Dblclick|Unload|Paste|Propertychange|Error|Errorupdate|Keydown|Keyup|Keypress|Focus|Load|Activate|Afterupdate|Afterprint|Abort))\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.event-handler.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(shift|showModelessDialog|showModalDialog|showHelp|scroll|scrollX|scrollByPages|scrollByLines|scrollY|scrollTo|stop|strike|sizeToContent|sidebar|signText|sort|sup|sub|substr|substring|splice|split|send|set(Milliseconds|Seconds|Minutes|Hours|Month|Year|FullYear|Date|UTC(Milliseconds|Seconds|Minutes|Hours|Month|FullYear|Date)|Time|Hotkeys|Cursor|ZOptions|Active|Resizable|RequestHeader)|search|slice|savePreferences|small|home|handleEvent|navigate|char|charCodeAt|charAt|concat|contextual|confirm|compile|clear|captureEvents|call|createStyleSheet|createPopup|createEventObject|to(GMTString|UTCString|String|Source|UpperCase|LowerCase|LocaleString)|test|taint|taintEnabled|indexOf|italics|disableExternalCapture|dump|detachEvent|unshift|untaint|unwatch|updateCommands|join|javaEnabled|pop|push|plugins.refresh|paddings|parse|print|prompt|preference|enableExternalCapture|exec|execScript|valueOf|UTC|find|file|fileModifiedDate|fileSize|fileCreatedDate|fileUpdatedDate|fixed|fontsize|fontcolor|forward|fromCharCode|watch|link|load|lastIndexOf|anchor|attachEvent|atob|apply|alert|abort|routeEvents|resize|resizeBy|resizeTo|recalc|returnValue|replace|reverse|reload|releaseCapture|releaseEvents|go|get(Milliseconds|Seconds|Minutes|Hours|Month|Day|Year|FullYear|Time|Date|TimezoneOffset|UTC(Milliseconds|Seconds|Minutes|Hours|Day|Month|FullYear|Date)|Attention|Selection|ResponseHeader|AllResponseHeaders)|moveBy|moveBelow|moveTo|moveToAbsolute|moveAbove|mergeAttributes|match|margins|btoa|big|bold|borderWidths|blink|back)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.method.nova}
      patterns:
      - include: '#round-brackets'
    - applyEndPatternLast: 1
      begin: \s*+(acceptNode|add|addEventListener|addTextTrack|adoptNode|after|animate|append|appendChild|appendData|before|blur|canPlayType|captureStream|caretPositionFromPoint|caretRangeFromPoint|checkValidity|clear|click|cloneContents|cloneNode|cloneRange|close|closest|collapse|compareBoundaryPoints|compareDocumentPosition|comparePoint|contains|convertPointFromNode|convertQuadFromNode|convertRectFromNode|createAttribute|createAttributeNS|createCaption|createCDATASection|createComment|createContextualFragment|createDocument|createDocumentFragment|createDocumentType|createElement|createElementNS|createEntityReference|createEvent|createExpression|createHTMLDocument|createNodeIterator|createNSResolver|createProcessingInstruction|createRange|createShadowRoot|createTBody|createTextNode|createTFoot|createTHead|createTreeWalker|delete|deleteCaption|deleteCell|deleteContents|deleteData|deleteRow|deleteTFoot|deleteTHead|detach|disconnect|dispatchEvent|elementFromPoint|elementsFromPoint|enableStyleSheetsForSet|entries|evaluate|execCommand|exitFullscreen|exitPointerLock|expand|extractContents|fastSeek|firstChild|focus|forEach|get|getAll|getAnimations|getAttribute|getAttributeNames|getAttributeNode|getAttributeNodeNS|getAttributeNS|getBoundingClientRect|getBoxQuads|getClientRects|getContext|getDestinationInsertionPoints|getElementById|getElementsByClassName|getElementsByName|getElementsByTagName|getElementsByTagNameNS|getItem|getNamedItem|getSelection|getStartDate|getVideoPlaybackQuality|has|hasAttribute|hasAttributeNS|hasAttributes|hasChildNodes|hasFeature|hasFocus|importNode|initEvent|insertAdjacentElement|insertAdjacentHTML|insertAdjacentText|insertBefore|insertCell|insertData|insertNode|insertRow|intersectsNode|isDefaultNamespace|isEqualNode|isPointInRange|isSameNode|item|key|keys|lastChild|load|lookupNamespaceURI|lookupPrefix|matches|move|moveAttribute|moveAttributeNode|moveChild|moveNamedItem|namedItem|nextNode|nextSibling|normalize|observe|open|parentNode|pause|play|postMessage|prepend|preventDefault|previousNode|previousSibling|probablySupportsContext|queryCommandEnabled|queryCommandIndeterm|queryCommandState|queryCommandSupported|queryCommandValue|querySelector|querySelectorAll|registerContentHandler|registerElement|registerProtocolHandler|releaseCapture|releaseEvents|remove|removeAttribute|removeAttributeNode|removeAttributeNS|removeChild|removeEventListener|removeItem|replace|replaceChild|replaceData|replaceWith|reportValidity|requestFullscreen|requestPointerLock|reset|scroll|scrollBy|scrollIntoView|scrollTo|seekToNextFrame|select|selectNode|selectNodeContents|set|setAttribute|setAttributeNode|setAttributeNodeNS|setAttributeNS|setCapture|setCustomValidity|setEnd|setEndAfter|setEndBefore|setItem|setNamedItem|setRangeText|setSelectionRange|setSinkId|setStart|setStartAfter|setStartBefore|slice|splitText|stepDown|stepUp|stopImmediatePropagation|stopPropagation|submit|substringData|supports|surroundContents|takeRecords|terminate|toBlob|toDataURL|toggle|toString|values|write|writeln)\b
      end: (?=.)
      beginCaptures:
        1: {name: support.function.dom.nova}
      patterns:
      - include: '#round-brackets'
  support-objects:
    patterns:
    - match: (?<![\#\.])\s*\b(global|GLOBAL|root|__dirname|__filename)\b\s*
      name: support.variable.object.node.nova
    - match: (?<![\#\.])\s*\b(exports|process)\s*\b
      name: support.variable.$1.nova
    - match: (?<![\#\.])\s*\b(JSON)\s*\b
      name: support.constant.json.nova
    - match: (?<![\#\.])\s*\b(Math)\s*\b
      name: support.constant.math.nova
    - match: (?<![\#\.])\s*\b(console)\s*\b
      name: support.constant.console.nova
    - match: (?<![\#\.])\s*+\b(document|event|navigator|performance|screen|window)\s*+\b
      name: support.variable.dom.nova
    - match: |-
        (?x) (?<![\#\.]) \s*+ \b
          (Buffer|EventEmitter|Server|Pipe|Socket|REPLServer|ReadStream|WriteStream|Stream 
        |Inflate|Deflate|InflateRaw|DeflateRaw|GZip|GUnzip|Unzip|Zip) \b
      name: support.class.node.nova
    - applyEndPatternLast: 1
      begin: |-
        (?x) (?<![\#\.]) \s*+ \b
          (AnalyserNode|ArrayBufferView|Attr|AudioBuffer|AudioBufferSourceNode|AudioContext|AudioDestinationNode|AudioListener
          |AudioNode|AudioParam|BatteryManager|BeforeUnloadEvent|BiquadFilterNode|Blob|BufferSource|ByteString|CSS|CSSConditionRule
          |CSSCounterStyleRule|CSSGroupingRule|CSSMatrix|CSSMediaRule|CSSPageRule|CSSPrimitiveValue|CSSRule|CSSRuleList|CSSStyleDeclaration
          |CSSStyleRule|CSSStyleSheet|CSSSupportsRule|CSSValue|CSSValueList|CanvasGradient|CanvasImageSource|CanvasPattern
          |CanvasRenderingContext2D|ChannelMergerNode|ChannelSplitterNode|CharacterData|ChromeWorker|CloseEvent|Comment|CompositionEvent
          |Console|ConvolverNode|Coordinates|Credential|CredentialsContainer|Crypto|CryptoKey|CustomEvent|DOMError|DOMException
          |DOMHighResTimeStamp|DOMImplementation|DOMString|DOMStringList|DOMStringMap|DOMTimeStamp|DOMTokenList|DataTransfer
          |DataTransferItem|DataTransferItemList|DedicatedWorkerGlobalScope|DelayNode|DeviceProximityEvent|DirectoryEntry
          |DirectoryEntrySync|DirectoryReader|DirectoryReaderSync|Document|DocumentFragment|DocumentTouch|DocumentType|DragEvent
          |DynamicsCompressorNode|Element|Entry|EntrySync|ErrorEvent|Event|EventListener|EventSource|EventTarget|FederatedCredential
          |FetchEvent|File|FileEntry|FileEntrySync|FileException|FileList|FileReader|FileReaderSync|FileSystem|FileSystemSync
          |FontFace|FormData|GainNode|Gamepad|GamepadButton|GamepadEvent|Geolocation|GlobalEventHandlers|HTMLAnchorElement
          |HTMLAreaElement|HTMLAudioElement|HTMLBRElement|HTMLBaseElement|HTMLBodyElement|HTMLButtonElement|HTMLCanvasElement
          |HTMLCollection|HTMLContentElement|HTMLDListElement|HTMLDataElement|HTMLDataListElement|HTMLDialogElement|HTMLDivElement
          |HTMLDocument|HTMLElement|HTMLEmbedElement|HTMLFieldSetElement|HTMLFontElement|HTMLFormControlsCollection|HTMLFormElement
          |HTMLHRElement|HTMLHeadElement|HTMLHeadingElement|HTMLHtmlElement|HTMLIFrameElement|HTMLImageElement|HTMLInputElement
          |HTMLKeygenElement|HTMLLIElement|HTMLLabelElement|HTMLLegendElement|HTMLLinkElement|HTMLMapElement|HTMLMediaElement
          |HTMLMetaElement|HTMLMeterElement|HTMLModElement|HTMLOListElement|HTMLObjectElement|HTMLOptGroupElement|HTMLOptionElement
          |HTMLOptionsCollection|HTMLOutputElement|HTMLParagraphElement|HTMLParamElement|HTMLPreElement|HTMLProgressElement
          |HTMLQuoteElement|HTMLScriptElement|HTMLSelectElement|HTMLShadowElement|HTMLSourceElement|HTMLSpanElement|HTMLStyleElement
          |HTMLTableCaptionElement|HTMLTableCellElement|HTMLTableColElement|HTMLTableDataCellElement|HTMLTableElement|HTMLTableHeaderCellElement
          |HTMLTableRowElement|HTMLTableSectionElement|HTMLTextAreaElement|HTMLTimeElement|HTMLTitleElement|HTMLTrackElement
          |HTMLUListElement|HTMLUnknownElement|HTMLVideoElement|HashChangeEvent|History|IDBCursor|IDBCursorWithValue|IDBDatabase
          |IDBEnvironment|IDBFactory|IDBIndex|IDBKeyRange|IDBMutableFile|IDBObjectStore|IDBOpenDBRequest|IDBRequest|IDBTransaction
          |IDBVersionChangeEvent|IIRFilterNode|IdentityManager|ImageBitmap|ImageBitmapFactories|ImageData|Index|InputDeviceCapabilities
          |InputEvent|InstallEvent|InstallTrigger|KeyboardEvent|LinkStyle|LocalFileSystem|LocalFileSystemSync|Location|MIDIAccess
          |MIDIConnectionEvent|MIDIInput|MIDIInputMap|MIDIOutputMap|MediaElementAudioSourceNode|MediaError|MediaKeyMessageEvent
          |MediaKeySession|MediaKeyStatusMap|MediaKeySystemAccess|MediaKeySystemConfiguration|MediaKeys|MediaRecorder|MediaStream
          |MediaStreamAudioDestinationNode|MediaStreamAudioSourceNode|MessageChannel|MessageEvent|MessagePort|MouseEvent
          |MutationObserver|MutationRecord|NamedNodeMap|Navigator|NavigatorConcurrentHardware|NavigatorGeolocation|NavigatorID
          |NavigatorLanguage|NavigatorOnLine|Node|NodeFilter|NodeIterator|NodeList|NonDocumentTypeChildNode|Notification
          |OfflineAudioCompletionEvent|OfflineAudioContext|OscillatorNode|PageTransitionEvent|PannerNode|ParentNode|PasswordCredential
          |Path2D|PaymentAddress|PaymentRequest|PaymentResponse|Performance|PerformanceEntry|PerformanceFrameTiming|PerformanceMark
          |PerformanceMeasure|PerformanceNavigation|PerformanceNavigationTiming|PerformanceObserver|PerformanceObserverEntryList
          |PerformanceResourceTiming|PerformanceTiming|PeriodicSyncEvent|PeriodicWave|Plugin|Point|PointerEvent|PopStateEvent
          |PortCollection|Position|PositionError|PositionOptions|PresentationConnectionClosedEvent|PresentationConnectionList
          |PresentationReceiver|ProcessingInstruction|ProgressEvent|PromiseRejectionEvent|PushEvent|PushRegistrationManager
          |RTCCertificate|RTCConfiguration|RTCPeerConnection|RTCSessionDescriptionCallback|RTCStatsReport|RadioNodeList|RandomSource
          |Range|ReadableByteStream|RenderingContext|SVGAElement|SVGAngle|SVGAnimateColorElement|SVGAnimateElement|SVGAnimateMotionElement
          |SVGAnimateTransformElement|SVGAnimatedAngle|SVGAnimatedBoolean|SVGAnimatedEnumeration|SVGAnimatedInteger|SVGAnimatedLength
          |SVGAnimatedLengthList|SVGAnimatedNumber|SVGAnimatedNumberList|SVGAnimatedPoints|SVGAnimatedPreserveAspectRatio
          |SVGAnimatedRect|SVGAnimatedString|SVGAnimatedTransformList|SVGAnimationElement|SVGCircleElement|SVGClipPathElement
          |SVGCursorElement|SVGDefsElement|SVGDescElement|SVGElement|SVGEllipseElement|SVGEvent|SVGFilterElement|SVGFontElement
          |SVGFontFaceElement|SVGFontFaceFormatElement|SVGFontFaceNameElement|SVGFontFaceSrcElement|SVGFontFaceUriElement
          |SVGForeignObjectElement|SVGGElement|SVGGlyphElement|SVGGradientElement|SVGHKernElement|SVGImageElement|SVGLength
          |SVGLengthList|SVGLineElement|SVGLinearGradientElement|SVGMPathElement|SVGMaskElement|SVGMatrix|SVGMissingGlyphElement
          |SVGNumber|SVGNumberList|SVGPathElement|SVGPatternElement|SVGPoint|SVGPolygonElement|SVGPolylineElement|SVGPreserveAspectRatio
          |SVGRadialGradientElement|SVGRect|SVGRectElement|SVGSVGElement|SVGScriptElement|SVGSetElement|SVGStopElement|SVGStringList
          |SVGStylable|SVGStyleElement|SVGSwitchElement|SVGSymbolElement|SVGTRefElement|SVGTSpanElement|SVGTests|SVGTextElement
          |SVGTextPositioningElement|SVGTitleElement|SVGTransform|SVGTransformList|SVGTransformable|SVGUseElement|SVGVKernElement
          |SVGViewElement|ServiceWorker|ServiceWorkerContainer|ServiceWorkerGlobalScope|ServiceWorkerRegistration|ServiceWorkerState
          |ShadowRoot|SharedWorker|SharedWorkerGlobalScope|SourceBufferList|StereoPannerNode|Storage|StorageEvent|StyleSheet
          |StyleSheetList|SubtleCrypto|SyncEvent|Text|TextMetrics|TimeEvent|TimeRanges|Touch|TouchEvent|TouchList|Transferable
          |TreeWalker|UIEvent|USVString|VRDisplayCapabilities|ValidityState|WaveShaperNode|WebGL|WebGLActiveInfo|WebGLBuffer
          |WebGLContextEvent|WebGLFramebuffer|WebGLProgram|WebGLRenderbuffer|WebGLRenderingContext|WebGLShader|WebGLShaderPrecisionFormat
          |WebGLTexture|WebGLTimerQueryEXT|WebGLTransformFeedback|WebGLUniformLocation|WebGLVertexArrayObject|WebGLVertexArrayObjectOES
          |WebSocket|WebSockets|WebVTT|WheelEvent|Window|WindowBase64|WindowEventHandlers|WindowTimers|Worker|WorkerGlobalScope
          |WorkerLocation|WorkerNavigator|XMLHttpRequest|XMLHttpRequestEventTarget|XMLSerializer|XPathExpression|XPathResult
          |XSLTProcessor)
        \b
      end: (?=.)
      name: support.class.dom.nova
      beginCaptures:
        1: {name: support.class.dom.nova}
  support-properties:
    patterns:
    - match: |-
        (?<=\.)\s*\b
        (ATTRIBUTE_NODE|CDATA_SECTION_NODE|COMMENT_NODE|DOCUMENT_FRAGMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE
        |DOMSTRING_SIZE_ERR|ELEMENT_NODE|ENTITY_NODE|ENTITY_REFERENCE_NODE|HIERARCHY_REQUEST_ERR|INDEX_SIZE_ERR
        |INUSE_ATTRIBUTE_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR
        |NOT_SUPPORTED_ERR|NOTATION_NODE|PROCESSING_INSTRUCTION_NODE|TEXT_NODE|WRONG_DOCUMENT_ERR)
        \b\s*
      name: support.variable.property.dom.nova
    - match: |-
        (?x)(?<=\.)\s*\b (_content|[xyz]|abbr|above|accept|acceptCharset|accessKey|action|align|[av]Link(?:color)?|all|alt|anchors|appCodeName    |appCore|applets|appMinorVersion|appName|appVersion|archive|areas|arguments|attributes|availHeight|availLeft|availTop    |availWidth|axis|background|backgroundColor|backgroundImage|below|bgColor|body|border|borderBottomWidth|borderColor    |borderLeftWidth|borderRightWidth|borderStyle|borderTopWidth|borderWidth|bottom|bufferDepth|callee|caller|caption    |cellPadding|cells|cellSpacing|ch|characterSet|charset|checked|childNodes|chOff|cite|classes|className|clear    |clientInformation|clip|clipBoardData|closed|code|codeBase|codeType|color|colorDepth|cols|colSpan|compact|complete    |components|content|controllers|cookie|cookieEnabled|cords|cpuClass|crypto|current|data|dateTime|declare|defaultCharset    |defaultChecked|defaultSelected|defaultStatus|defaultValue|defaultView|defer|description|dialogArguments|dialogHeight
            |dialogLeft|dialogTop|dialogWidth|dir|directories|disabled|display|docmain|doctype|documentElement|elements|embeds
            |enabledPlugin|encoding|enctype|entities|event|expando|external|face|fgColor|filename|firstChild|fontFamily|fontSize
            |fontWeight|form|formName|forms|frame|frameBorder|frameElement|frames|hasFocus|hash|headers|height|history|host
            |hostname|href|hreflang|hspace|htmlFor|httpEquiv|id|ids|ignoreCase|images|implementation|index|innerHeight|innerWidth
            |input|isMap|label|lang|language|lastChild|lastIndex|lastMatch|lastModified|lastParen|layer[sXY]|left|leftContext
            |lineHeight|link|linkColor|links|listStyleType|localName|location|locationbar|longDesc|lowsrc|lowSrc|marginBottom
            |marginHeight|marginLeft|marginRight|marginTop|marginWidth|maxLength|media|menubar|method|mimeTypes|multiline|multiple
            |name|nameProp|namespaces|namespaceURI|next|nextSibling|nodeName|nodeType|nodeValue|noHref|noResize|noShade|notationName
            |notations|noWrap|object|offscreenBuffering|onLine|onreadystatechange|opener|opsProfile|options|oscpu|outerHeight
            |outerWidth|ownerDocument|paddingBottom|paddingLeft|paddingRight|paddingTop|page[XY]|page[XY]Offset|parent|parentLayer
            |parentNode|parentWindow|pathname|personalbar|pixelDepth|pkcs11|platform|plugins|port|prefix|previous|previousDibling
            |product|productSub|profile|profileend|prompt|prompter|protocol|publicId|readOnly|readyState|referrer|rel|responseText
            |responseXML|rev|right|rightContext|rowIndex|rows|rowSpan|rules|scheme|scope|screen[XY]|screenLeft|screenTop|scripts
            |scrollbars|scrolling|sectionRowIndex|security|securityPolicy|selected|selectedIndex|selection|self|shape|siblingAbove
            |siblingBelow|size|source|specified|standby|start|status|statusbar|statusText|style|styleSheets|suffixes|summary
            |systemId|systemLanguage|tagName|tags|target|tBodies|text|textAlign|textDecoration|textIndent|textTransform|tFoot|tHead
            |title|toolbar|top|type|undefined|uniqueID|updateInterval|URL|URLUnencoded|useMap|userAgent|userLanguage|userProfile
            |vAlign|value|valueType|vendor|vendorSub|version|visibility|vspace|whiteSpace|width|X[MS]LDocument|zIndex)
        \b\s*
      name: support.variable.property.dom.nova
    - match: (?x)(?<=\.)\s*\b (module|exports|id|filename|loaded|parent|children) \b\s*
      name: support.type.object.module.nova
  support-python:
    patterns:
    - match: |-
        (?x)
          (?<![\#\.]) \s*+ \b(
            __import__ | abs | all | any | ascii | bin | breakpoint | callable
            | chr | compile | copyright | credits | delattr | dir | divmod
            | enumerate | eval | exec | exit | filter | format | getattr
            | globals | hasattr | hash | help | hex | id | input
            | isinstance | issubclass | iter | len | license | locals | map
            | max | memoryview | min | next | oct | open | ord | pow | print
            | quit | range | reload | repr | reversed | round
            | setattr | sorted | sum | vars | zip
          )\b
      name: support.function.builtin.nova
    - match: |-
        (?x)
          (?<![\#\.]) \s*+ \b(
            file | reduce | intern | raw_input | unicode | cmp | basestring
            | execfile | long | xrange
          )\b
      name: variable.legacy.builtin.nova
    - match: |-
        (?x)
          (?<![\#\.]) \s*+ \b(
            bool | bytearray | bytes | classmethod | complex | dict
            | float | frozenset | int | list | object | property
           | slice | staticmethod | str | tuple | type
            (?# Although 'super' is not a type, it's related to types,
                and is special enough to be highlighted differently from
                other built-ins)
            | super
          )\b
      name: support.type.primitive.nova
    - match: |-
        (?x)
         \s*+ \b(
            _*(?:
              abs | add | aenter | aexit | aiter | and | anext | await
              | bool | call | ceil | cmp | coerce | complex | contains
              | copy | deepcopy | del | delattr | delete | delitem
              | delslice | dir | div | divmod | enter | eq | exit | float
              | floor | floordiv | format | ge | get | getattr
              | getattribute | getinitargs | getitem | getnewargs
              | getslice | getstate | gt | hash | hex | iadd | iand | idiv
              | ifloordiv | ilshift | imod | imul | index | init
              | instancecheck | int | invert | ior | ipow | irshift | isub
              | iter | itruediv | ixor | le | len | long | lshift | lt
              | missing | mod | mul | ne | neg | new | next | nonzero | oct | or
              | pos | pow | radd | rand | rdiv | rdivmod | reduce
              | reduce_ex | repr | reversed | rfloordiv | rlshift | rmod
              | rmul | ror | round | rpow | rrshift | rshift | rsub
              | rtruediv | rxor | setattr | setitem | setslice
              | setstate | sizeof | str | sub | subclasscheck | truediv
              | trunc | unicode | xor | matmul | rmatmul | imatmul
              | init_subclass | set_name | fspath | bytes | prepare
            )_*
          )\b
      captures:
        1: {name: support.function.magic.nova}
    - match: |-
        (?x)
         \s*+ \b(
            __(?:
              all | bases | builtins | class | class_getitem | code | debug
              | defaults | dict | doc | file | func | kwdefaults | members
              | metaclass | methods | module | mro | mro_entries | name
              | qualname | post_init | self | signature | slots | subclasses
              | version | weakref | wrapped | annotations | classcell
              | spec | path | package | future | traceback
            )__
          )\b
      captures:
        1: {name: support.variable.magic.nova}
  type-argument-brackets:
    patterns:
    - begin: \s*+(<)(?=((?:(?>[^<>]+)|<\g<-1>>)*)>)
      end: \s*(>)
      name: meta.type-arguments.nova
      beginCaptures:
        1: {name: punctuation.nova}
      endCaptures:
        1: {name: punctuation.nova}
      patterns:
      - include: '#typed-parse-types'
      - include: '#comma'
  typed-bracketed-args:
    patterns:
    - begin: (?<!}|return|await|unless|els?if|ell?ess|else|match|when|repeat|until|switch|case|while|for|throw)\s*((\())
      contentName: meta.function.parameters.nova
      end: \s*((\)))
      beginCaptures:
        1: {name: punctuation.definition.parameters.begin.nova}
        2: {name: meta.brace.round.nova}
      endCaptures:
        1: {name: punctuation.definition.parameters.end.nova}
        2: {name: meta.brace.round.nova}
      patterns:
      - include: '#modifiers'
      - include: '#typed-polymorphs'
      - include: '#typed-variable'
  typed-bracketed-parameters:
    patterns:
    - applyEndPatternLast: 1
      begin: \s*+(?=(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*+(?!\.|:|=>|{|/\*\s*:))
      end: (?=.)
      patterns:
      - begin: \s*(\()
        end: \s*(\))
        beginCaptures:
          1: {name: meta.brace.round.nova}
        endCaptures:
          1: {name: meta.brace.round.nova}
        patterns:
        - include: '#typed-parse-types'
    - begin: (?<!}|return|await|unless|els?if|ell?ess|else|match|when|repeat|until|switch|case|while|for|throw)\s*((\())
      contentName: meta.function.parameters.nova
      end: \s*((\)))
      beginCaptures:
        1: {name: punctuation.definition.parameters.begin.nova}
        2: {name: meta.brace.round.nova}
      endCaptures:
        1: {name: punctuation.definition.parameters.end.nova}
        2: {name: meta.brace.round.nova}
      patterns:
      - include: '#typed-polymorphs'
      - include: '#typed-variable'
  typed-comments:
    patterns:
    - begin: \s*+(/\*)\s*(::)
      end: \s*(\*/)
      name: meta.comments.nova
      beginCaptures:
        1: {name: punctuation.definition.comment.nova}
        2: {name: punctuation.type.nova}
      endCaptures:
        1: {name: punctuation.definition.comment.nova}
      patterns:
      - include: '#typed-comments-optional-parameter'
      - include: '#module'
      - include: '#typed-keywords'
      - include: '#typed-predicate'
      - include: '#typed-parse-types'
      - include: '#function'
      - include: '#keyword-storage'
    - begin: \s*+(/\*)\s*(flow-include)\b
      end: \s*(\*/)
      name: meta.comments.nova
      beginCaptures:
        1: {name: punctuation.definition.comment.nova}
        2: {name: keyword.other.flow-include.nova}
      endCaptures:
        1: {name: punctuation.definition.comment.nova}
      patterns:
      - include: '#typed-comments-optional-parameter'
      - include: '#module'
      - include: '#typed-keywords'
      - include: '#typed-predicate'
      - include: '#typed-parse-types'
      - include: '#function'
      - include: '#keyword-storage'
    - begin: \s*+(/\*)\s*(:)((?=::)|(?![:<=>]))
      end: \s*(\*/)
      name: meta.comments.nova
      beginCaptures:
        1: {name: punctuation.definition.comment.nova}
        2: {name: punctuation.type.nova}
      endCaptures:
        1: {name: punctuation.definition.comment.nova}
      patterns:
      - include: '#typed-predicate'
      - include: '#typed-parse-types'
  typed-comments-optional-parameter:
    patterns:
    - match: (?<=::|flow-include)\s*(\?)
      captures:
        1: {name: keyword.operator.optional.parameter.nova}
  typed-declare:
    patterns:
    - match: (?<![\#\.])\s*+\b(decl?|def)\b\s*+
      captures:
        1: {name: keyword.other.declare.nova}
    - applyEndPatternLast: 1
      begin: (?<![\#\.])\s*+\b(decl?|def)\b\s*+\b(module)(.)(exports)(:)((?=::)|(?![:<=>]))
      end: (?=.)
      beginCaptures:
        1: {name: keyword.other.declare.nova}
        2: {name: storage.type.module.nova}
        3: {name: keyword.operator.accessor.nova}
        4: {name: storage.type.module.nova}
        5: {name: punctuation.type.nova}
      patterns:
      - include: '#typed-parse-objects'
      - include: '#typed-parse-types'
    - begin: (?<![\#\.])\s*+\b(decl?|def)\b\s*+\b(module)(\s|$)
      end: \s*(?<=})
      beginCaptures:
        1: {name: keyword.other.declare.nova}
        2: {name: storage.type.module.nova}
      patterns:
      - include: '#typed-polymorphs'
      - match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
        captures:
          1: {name: entity.name.class.nova}
      - include: '#string'
      - begin: \s*+({)
        contentName: meta.class.body.nova
        end: \s*(})
        beginCaptures:
          1: {name: punctuation.section.class.begin.nova}
        endCaptures:
          1: {name: punctuation.section.class.end.nova}
        patterns:
        - include: '#typed-keywords'
        - include: '#typed-method'
        - include: '#core'
    - begin: (?<![\#\.])\s*+\b(decl?|def)\b\s*+(\bexport\b)?\s*+\b(class)\b
      end: \s*(?<=})
      beginCaptures:
        1: {name: keyword.other.declare.nova}
        2: {name: keyword.constrol.module.nova}
        3: {name: storage.type.class.nova}
      patterns:
      - match: \s*+\b((ext))\b\s*+
        captures:
          1: {name: meta.class.extends.nova}
          2: {name: storage.type.extends.nova}
      - match: \s*+\b((impl))\b\s*+
        captures:
          1: {name: meta.class.implements.nova}
          2: {name: storage.type.implements.nova}
      - match: \s*+\b((mix))\b\s*+
        captures:
          1: {name: meta.class.extends.nova}
          2: {name: storage.type.extends.nova}
      - match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
        captures:
          1: {name: entity.name.class.nova}
      - begin: \s*+({)
        contentName: meta.class.body.nova
        end: \s*(})
        beginCaptures:
          1: {name: punctuation.section.class.begin.nova}
        endCaptures:
          1: {name: punctuation.section.class.end.nova}
        patterns:
        - include: '#typed-method'
        - include: '#core'
      - include: '#typed-polymorphs'
      - include: '#comma'
      - match: \s*(\.)
        captures:
          1: {name: keyword.operator.accessor.nova}
  typed-interface:
    begin: (?<![\#\.])\s*+\b(inter|schema|struct)(\s+|$)
    end: \s*(\.?=|::?=)(?![<~>=])\s*|(?<=})|\s*(?=,|;|=|{|\*/|\b(in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b|\)|})
    beginCaptures:
      1: {name: keyword.other.interface.nova}
    endCaptures:
      1: {name: keyword.operator.assignment.nova}
    patterns:
    - include: '#type-argument-brackets'
    - match: \s*+\b((ext)|(impl)|(only))\b\s*+
      captures:
        1: {name: meta.class.extends.nova}
        2: {name: storage.type.extends.nova}
        3: {name: storage.type.implements.nova}
        4: {name: keyword.operator.expression.only.nova}
    - match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
      name: entity.name.type.interface.nova
    - include: '#types'
    - begin: \s*+({)
      contentName: meta.class.body.nova
      end: \s*(})
      beginCaptures:
        1: {name: punctuation.section.class.begin.nova}
      endCaptures:
        1: {name: punctuation.section.class.end.nova}
      patterns:
      - include: '#typed-method'
      - include: '#core'
    - match: \s*(\.)
      captures:
        1: {name: keyword.operator.accessor.nova}
    - include: '#core'
  typed-keywords:
    patterns:
    - include: '#typed-declare'
    - include: '#typed-type-aliases'
    - include: '#typed-interface'
  typed-method:
    applyEndPatternLast: 1
    begin: (?<!:)\s*+(?=(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?(\())
    end: \s*(?=.)
    beginCaptures:
      1: {name: storage.modifier.nova}
      2: {name: storage.type.nova}
      3: {name: keyword.generator.asterisk.nova}
    patterns:
    - include: '#types'
  typed-object-property:
    patterns:
    - match: ((\|)(?={|))|(\s*(\|)(?=}))
      captures:
        1: {name: keyword.operator.only.nova}
        4: {name: keyword.operator.only.nova}
    - include: '#method'
    - include: '#comments'
    - include: '#typed-variable'
  typed-parse-array:
    patterns:
    - begin: (?<!=|[_\\\p{L}\p{M}\p{N}])\s*+(#\[)
      end: \s*(\])
      beginCaptures:
        1: {name: meta.brace.square.open.nova}
      endCaptures:
        1: {name: meta.brace.square.end.nova}
      patterns:
      - applyEndPatternLast: 1
        begin: \s*(?=[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*\s*[=:])
        end: (?=.)
        patterns:
        - include: '#typed-variable'
        - include: '#typed-parse-types'
      - include: '#typed-parse-types'
      - include: '#typed-variable'
    - begin: (?<!=|[_\\\p{L}\p{M}\p{N}])\s*+(\[)
      end: \s*(\])
      beginCaptures:
        1: {name: meta.brace.square.open.nova}
      endCaptures:
        1: {name: meta.brace.square.end.nova}
      patterns:
      - applyEndPatternLast: 1
        begin: \s*(?=[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*\s*[=:])
        end: (?=.)
        patterns:
        - include: '#typed-variable'
        - include: '#typed-parse-types'
      - include: '#typed-parse-types'
      - include: '#typed-variable'
  typed-parse-objects:
    patterns:
    - applyEndPatternLast: 1
      begin: (?<=:|\||&|\?|=>|<|\()\s*+(\#{)
      end: \s*(\})
      name: meta.object.nova
      beginCaptures:
        1: {name: meta.brace.curly.open.nova}
      endCaptures:
        1: {name: meta.brace.curly.close.nova}
      patterns:
      - include: '#typed-object-property'
    - applyEndPatternLast: 1
      begin: (?<=:|\||&|\?|=>|<|\()\s*+({)
      end: \s*(\})
      name: meta.object.nova
      beginCaptures:
        1: {name: meta.brace.curly.open.nova}
      endCaptures:
        1: {name: meta.brace.curly.close.nova}
      patterns:
      - include: '#typed-object-property'
  typed-parse-types:
    patterns:
    - include: '#sigils'
    - begin: (?<=[>_\\\p{L}\p{M}\p{N}]*)\s+(?=(?<![\#\.])\s*+\b(?:in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)
      end: \s*(?=[,;\p{Pe}]|\*/)
      patterns:
      - include: '#core'
    - include: '#for-all-clause'
    - include: '#modifiers'
    - include: '#keywords'
    - include: '#number'
    - include: '#string'
    - include: '#regexp'
    - include: '#regexp-multiline'
    - match: (?<![\#\.])\s*+\b(?:(typeof|nameof|infer|keyof|only)|(ext)|(impl))\b\s*+
      captures:
        1: {name: keyword.operator.expression.$1.nova}
        2: {name: keyword.operator.expression.extends.nova}
        3: {name: keyword.operator.expression.implements.nova}
    - include: '#language-constant'
    - match: (?i)(?<![\#\.])\s*+\b((?>bool|int|float|[nr]at|real|imag|cmp|num|char|rune|str|sym|regex|re|func|[usn]?(?:byte|short|int|long|cent)|[ci]?(?:half|float|double|quad|oct)))\b
      captures:
        1: {name: support.type.builtin.primitive.nova}
    - match: (?i)(?<![\#\.])\s*+\b((?>this|any|void|empty|object|list|set|map|dict|array|tuple|record|seq|dict|unit|buff|mixed|mix))\b
      captures:
        1: {name: support.type.builtin.nova}
    - match: \s*+(_|[\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}]*)(?!\p{Ll})
      name: support.type.builtin.nova
    - match: \s*+((?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}]+[_\\\p{Ll}\p{M}\p{N}]*)+)
      name: support.type.class.nova
    - match: \s*+([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
      name: support.type.primitive.nova
    - match: \s*#(?!\p{Ps})\s*
      name: keyword.operator.private.nova
    - match: (?<==>)\*
      name: keyword.generator.asterisk.nova
    - match: \s*+(\?)
      captures:
        1: {name: keyword.operator.maybe.nova}
    - match: \s*+(\^)
      captures:
        1: {name: keyword.operator.bitwise.nova}
    - match: \s*+(\~)
      captures:
        1: {name: keyword.operator.logical.nova}
    - match: \s*+(\|)(?<!{\|)(?!}|>)
      captures:
        1: {name: keyword.operator.union.nova}
    - match: \s*+(\&)
      captures:
        1: {name: keyword.operator.intersection.nova}
    - match: \s*+(\*)(?!/([^\*]|$))
      captures:
        1: {name: keyword.operator.existential.nova}
    - match: \s*+(:)((?=::)|(?![:<=>]))
      name: punctuation.type.nova
      captures:
        1: {name: support.type.builtin.primitive.nova}
    - match: (?<=\))\s*+(=>)
      captures:
        1: {name: storage.type.function.arrow.nova}
    - match: (?!^)\s*+\b((?>WeakSet|WeakMap|URIError|Uint8ClampedArray|Uint8Array|Uint32Array|Uint16Array|TypeError|TypedArray|SyntaxError|Symbol|String|SIMD.Uint8x16|SIMD.Uint32x4|SIMD.Uint16x8|SIMD.Int8x16|SIMD.Int32x4|SIMD.Int16x8|SIMD.Float64x2|SIMD.Float32x4|SIMD.Bool8x16|SIMD.Bool64x2|SIMD.Bool32x4|SIMD.Bool16x8|SIMD|SharedArrayBuffer|Set|RegExp|Reflect|ReferenceError|RangeError|Proxy|Promise|Object|Number|NaN|Math|Map|JSON|Intl.NumberFormat|Intl.DateTimeFormat|Intl.Collator|Intl|InternalError|Int8Array|Int32Array|Int16Array|Infinity|GeneratorFunction|Generator|Function|Float64Array|Float32Array|EvalError|Error|Date|DataView|Boolean|Atomics|ArrayBuffer|Array))\b
      captures:
        1: {name: support.type.builtin.class.nova}
    - match: \s*+\b((SIMD)((\.)(Uint8x16|Uint32x4|Uint16x8|Int8x16|Int32x4|Int16x8|Float64x2|Float32x4|Bool8x16|Bool64x2|Bool32x4|Bool16x8))?)\b
      captures:
        2: {name: support.type.builtin.class.nova}
        4: {name: keyword.operator.accessor.nova}
        5: {name: support.type.builtin.class.nova}
    - match: \s*+\b((Intl)((\.)(NumberFormat|DateTimeFormat|Collator))?)\b
      captures:
        2: {name: support.type.builtin.class.nova}
        4: {name: keyword.operator.accessor.nova}
        5: {name: support.type.builtin.class.nova}
    - include: '#typed-polymorphs'
    - include: '#typed-bracketed-parameters'
    - include: '#typed-parse-objects'
    - include: '#typed-parse-array'
    - include: '#square-brackets'
    - include: '#comments'
    - include: '#operators'
    repository:
      as-clause:
        begin: (?<![\#\.])\s*\b([ai]s)\b\s*
        end: (?<![\#\.])\s*\b(?=where)
        beginCaptures:
          1: {name: keyword.control.forall.nova}
        endCaptures:
          1: {patterns: [{include: '#core'}]}
        patterns:
        - include: '#as-clause'
        - include: '#case-separator'
        - include: '#typed-parse-types'
      case-separator:
        begin: ([,;])
        end: (?<![\#\.])\s*\b(?=[ai]s|where)
        beginCaptures:
          1: {patterns: [{include: '#core'}]}
        endCaptures:
          1: {patterns: [{include: '#core'}]}
        patterns:
        - include: '#as-clause'
        - include: '#case-separator'
        - include: '#core'
      for-all-clause:
        begin: (?<![\#\.])\s*+\b(for\s*all)\b\s*
        end: ^\s*|$|(?=;|,|\p{Pe})
        beginCaptures:
          1: {name: keyword.control.forall.nova}
        patterns:
        - begin: (?<![\#\.])\s*+\b(where)\b
          end: ^\s*|$|(?=;|,|\p{Pe})
          beginCaptures:
            1: {name: keyword.control.forall.nova}
          patterns:
          - include: '#comments'
          - include: '#core'
        - match: (?<![\#\.])\s*+\b(va[rl]|const|con|let)\b\s*+
          name: storage.type.nova
        - include: '#as-clause'
        - include: '#core'
  typed-polymorphs:
    patterns:
    - begin: \s*+\b((?>Array|Class|Map|Promise|Set|WeakMap|WeakSet))\s*+(<)
      end: \s*(>)
      beginCaptures:
        1: {name: support.type.builtin.class.nova}
        2: {name: punctuation.nova}
      endCaptures:
        1: {name: punctuation.nova}
      patterns:
      - include: '#comma'
      - match: \s*+(\+|-)
        captures:
          1: {name: support.type.variant.nova}
      - include: '#typed-parse-types'
    - begin: \s*+(<)
      end: \s*(>)
      beginCaptures:
        1: {name: punctuation.nova}
      endCaptures:
        1: {name: punctuation.nova}
      patterns:
      - include: '#comma'
      - match: \s*+(\+|-)
        captures:
          1: {name: support.type.variant.nova}
      - include: '#typed-parse-types'
  typed-predicate:
    applyEndPatternLast: 1
    begin: \s*+(?<=\s)(%checks)\b
    end: (?=.)
    beginCaptures:
      1: {name: entity.name.function.predicate.nova}
    patterns:
    - include: '#round-brackets'
  typed-return:
    patterns:
    - applyEndPatternLast: 1
      begin: (?<=\))\s*+(:)((?=::)|(?![:<=>]))
      end: (?=.)
      beginCaptures:
        1: {name: punctuation.type.nova}
      patterns:
      - include: '#typed-predicate'
      - include: '#typed-parse-types'
    - include: '#typed-predicate'
  typed-trap:
    patterns:
    - applyEndPatternLast: 1
      begin: (?<=\))(:)((?=::)|(?![:<=>]))
      end: (?=.)
      beginCaptures:
        1: {name: punctuation.type.nova}
      patterns:
      - include: '#typed-return'
    - applyEndPatternLast: 1
      begin: \s*+(:)(?:(?=::)|(?![:<=>]))
      end: (?=.)
      beginCaptures:
        1: {name: punctuation.type.nova}
      patterns:
      - include: '#typed-parse-types'
  typed-type-aliases:
    applyEndPatternLast: 1
    begin: (?<=^|;|\S)\s*+\b(opaque)?\s*+\b(type|alias)\b\s+(?!(i[sn])\b)(?=[_\\\p{L}\p{Nl}{\[])
    end: $|(?=;|,|\p{Pe})
    beginCaptures:
      1: {name: keyword.other.typedef.nova}
      2: {name: keyword.other.typedef.nova}
    patterns:
    - include: '#typed-parse-types'
    - include: '#types'
    - include: '#comments'
    - include: '#typed-function-name'
    - include: '#operator'
    - include: '#operators'
    - match: \s*+(=)(?!=|>)
      captures:
        1: {name: keyword.operator.assignment.nova}
    - include: '#punctuation'
  typed-variable:
    patterns:
    - match: (?<![\#\.])\s*+(\#?)((?:[_\\\p{L}\p{Nl}])(?:[_\\\p{L}\p{M}\p{N}])*+)\s*+(\??)\s*+(?=:\s*([_\\\p{L}\p{Nl}](?:[.\\_\\\p{L}\p{M}\p{N}])*+)?\s*(<(?:(?>(?<==)>|[^<>]+)|\g<-1>)*>)?\s*(\b(?:[fF]unc?|[fF]n)\b|(\((?>[^()"']|("(\\.|[^"])*+")++|('(\\.|[^'])*+')++|\g<-5>)*+\))\s*=>|\(\s*$))
      captures:
        1: {name: keyword.operator.private.nova}
        2: {name: storage.type.function.nova}
        3: {name: keyword.operator.optional.parameter.nova}
    - match: ((?<![\#\.])\.\.\.)?\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*+(\??)\s*+(?!::)(?=:|=>)
      captures:
        1: {name: keyword.operator.spread.nova}
        2: {name: keyword.operator.private.nova}
        3: {name: variable.other.readwrite.nova}
        4: {name: keyword.operator.optional.parameter.nova}
    - include: '#typed-vars-and-props'
  typed-vars-and-props:
    patterns:
    - include: '#sigils'
    - match: \s*+(\?)
      captures:
        1: {name: punctuation.type.nova}
    - match: \s*+(\|)(?<!{\|)(?!}|>)
      captures:
        1: {name: keyword.operator.union.nova}
    - match: \s*+(\&)
      captures:
        1: {name: keyword.operator.intersection.nova}
    - applyEndPatternLast: 1
      begin: \s*+(:)((?=::)|(?![:<=>]))
      end: (?=.)|$
      beginCaptures:
        1: {name: punctuation.type.nova}
      patterns:
      - include: '#typed-parse-types'
    - include: '#comma'
    - match: \s*+(@@)
    - applyEndPatternLast: 1
      begin: \s*+(=>)
      end: (?=.)|$
      beginCaptures:
        1: {name: storage.type.function.arrow.nova}
      patterns:
      - include: '#typed-parse-types'
    - begin: (?<!let|const|var|val|def|con)(?<=[_\\\p{L}\p{M}\p{N}])\s+(?=(?<![\#\.])\s*+\b(?:in|of|as|void|new|(?:type|name|key|size)of|infer|size|len|del|to|til|by|then|if|else|els?if|ell?ess?|unless?|guard|for|each|while|until|repeat|switch|case|def|match|when|pass|fail|try|throw|raise|catch|rescue|finally|with|defn?|func?|fn|macro|proc|let|va[rl]|con|const|do|goto|label|await|return|fallthru|yield|halt|skip|break|continue|from|where|join|equals|[io]nto|order|take|drop|fold|scan|group|select|(?:im|ex)port|use|using|ref|open|close|out|begin|end|show|hide|debug|check|assert)\b)
      end: \s*(?=[,;\p{Pe}]|\*/)
      patterns:
      - include: '#core'
    - begin: (?<!:)\s*+(?=((\#?)[_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)?\s*(::?|\.)?=)(?!=>|==)
      end: \s*(?=[,;\p{Pe}]|\*/)
      patterns:
      - include: '#core'
    - include: '#typed-bracketed-parameters'
    - include: '#typed-parse-array'
    - include: '#core'
  types:
    patterns:
    - include: '#comments'
    - include: '#typed-return'
    - include: '#typed-polymorphs'
    - include: '#typed-bracketed-args'
  variable:
    patterns:
    - match: \s*+(\#?)([_\\][_\\\p{L}\p{M}\p{N}]+)
      captures:
        1: {name: keyword.operator.private.nova}
        2: {name: variable.other.dollar.nova}
    - match: \s*+(\#?)(_|[\p{Lu}\p{Lt}\p{Lo}\p{Nl}][_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}\p{N}\p{M}]*)(?!\p{Ll})
      captures:
        1: {name: keyword.operator.private.nova}
        2: {name: variable.other.constant.nova}
    - match: \s*+(\#?)((?:[_\\\p{Lu}\p{Lt}\p{Lo}\p{Nl}]+[_\\\p{Ll}\p{M}\p{N}]*)+)
      captures:
        1: {name: keyword.operator.private.nova}
        2: {name: variable.other.class.nova}
    - match: \s*+(\#?)([_\\\p{Ll}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(?=\s*+[!?~]?\[|\s*+[!?~]?\.|->)
      name: variable.other.object.nova
      captures:
        1: {name: keyword.operator.private.nova}
        2: {name: variable.other.object.nova}
    - match: (?<=\.)\s*+(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)
      name: meta.property.object.nova
      captures:
        1: {name: keyword.operator.private.nova}
        2: {name: variable.other.property.nova}
    - match: \s*+(\#?)(\\+|[\p{Ll}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)(?!/)
      captures:
        1: {name: keyword.operator.private.nova}
        2: {name: variable.other.readwrite.nova}
  variable-typed:
    patterns:
    - begin: (?<=^|,|\()\s*+(?=(\#?)([_\\\p{L}\p{Nl}][_\\\p{L}\p{M}\p{N}]*)\s*\??\s*(:)((?=::)|(?![:<=>])))
      end: \s*(?=,|\))
      beginCaptures:
        3: {name: punctuation.nova}
      patterns:
      - include: '#typed-variable'
    - begin: (?<=^|,|\()\s*+(?="[^"]"\s*(:))
      end: \s*(?>=|\))
      beginCaptures:
        3: {name: punctuation.nova}
      patterns:
      - include: '#typed-variable'
    - begin: (?<=^|,|\()\s*+(?='[^']'\s*(:))
      end: \s*(?>=|\))
      beginCaptures:
        3: {name: punctuation.nova}
      patterns:
      - include: '#typed-variable'
limitLineLength: false
