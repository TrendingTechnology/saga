# **Nyx**

> The programming language for the future, perhaps.

With the best of object-oriented and functional paradigms, a big standard library, familiar syntax and powerful metaprogramming features at your disposal, Nyx offers an extensive suite of tools in one concise and expressive language where you can make _anything_ you imagine.

Nyx comes with a lightning fast compiler that scales to any codebase size, and its Python, JavaScript and WebAssembly runtimes help you to build both web and native applications with far-greater performance than with regular frameworks.

> Sample Code

```dart
class Person(val firstName: str, val lastName: str)
  def fullName() = '$firstName $lastName'
  def lastFirst() = '$lastName, $firstName'

module Utils
  def truncEllipsis(s: str, maxLen: int): str
    if s == nil || len s == 0 || maxLen == 0 then ''
    elif len s > maxLen then s.take(maxLen) ++ '...'
    else s
  def truncate(s: str, len: int): str = s.take(#len)

for (val x in 1 to 4; val y in 2 to 5) if x + y < 4
  print('x: $x, y: $y')
val p = new Person('Diana', 'Han')
print(p.fullName)
print(Utils.truncate(p.firstName, 2))
```

# Introduction

## Background

A lot of developers seem to either love or hate JavaScript because of its very nature. The language had received tons of backlash for tons of reasons. Take weak typing for example. Sometimes JavaScript would silently convert a value in one type in order to make the operation work, but most of the time that would introduce bugs that we would not notice, and only realize it when it's very late.

The NPM ecosystem is dependency-heavy. Shipping JavaScript projects inevitably drags in a lot of code, lots of which the project does not actually use, and is laying dormant, resulting in an application that is normally gigabytes in size when the project code is only tens or hundreds of megabytes. That calls for a lot of new languages, such as TypeScript, ReScript, Scala.js, Elm, PureScript, and countless others, all relying on other ecosystems besides JavaScript to compile their code into JavaScript.

Many of us realized how can we fix this without having to worry about this madness? One to take note here, when it comes to the web, everything is forced, there will be only one way to develop something for the web --- JavaScript.

## What is Nyx, exactly?

Nyx is a language with a simple and succinct syntax like Ruby, the flexibility of F# and Scala, the performance of C# and Haskell, and the versatility of Python and JavaScript. Nyx targets the JavaScript and Python runtimes, which means you can use Nyx on mobile, desktop, the web, the cloud, the server, and more. And always the latest, so you're never missing out.

## Roadmap

This document serves as a quick and informative guide for existing JavaScript developers, and also as a cheat sheet to all (or most) of Nyx's language features. Should you feel something needs to be corrected, feel free to make a pull request. I'm only a single person, so I'm looking forward to complete the documentation and language reference, so I can get started with coding the compiler.

- [ ] Documentation & Wiki
- [x] Syntax highlighting and theme (constantly being updated)
- [ ] Language reference
- [ ] Parser and compiler
- [ ] Package manager
- [ ] Standard library
- [ ] Editor support (Visual Studio Code)
- [ ] Logo and online documentation website

\*Backus-Naur Form (BNF): https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form

### Installation and Architecture

Install Nyx through NPM: `sudo npm i -g nyxlang`. `nyxlang` includes Nyx's core library, compiler (called Nyx), and CLI all compressed and bundled up in a single NPM package, exposing the `nyx` command. Nyx is written in Javascript.

Usage: `nyx [options] ... [file]`, where `options` are:

| Option | Alias | Description |
| --- | --- | --- |
| `ver`, `version` | `v` | Displays version |
| `help` | `h` | Display this help message |
| `init`, `start` | `s` | Start a project |
| `add`, `install` | `i` | Install JavaScript modules from NPM |
| `del` | `r` | Remove NPM modules |
| `update` | `u` | Update NPM modules |
| `build` | `b` | Compile |
| `list` | `l` | List all installed packages |
| `trans` | `t` | Pipe the compiled output through Babel |
| `map` | `m` | Generate source maps and include in the compiled output |
| `watch` | `w` | Watch scripts for changes |
| `output` | `o` | Write out all compiled files into the directory |
| `print` | `p` | Print output to standard output |
| `eval` | `e` | Compile and print a snippet of code |

The following are used for debugging the compiler:

| Option   | Description                             |
| -------- | --------------------------------------- |
| `nohead` | Suppress the `Generated by Nyx` header  |
| `ast`    | Generate and print the AST.             |
| `tokens` | Lex, and print the token stream         |
| `nodes`  | Lex, parse and print the compiled tree. |

```dart
import fs
import fs.[writeFileSync: write]
import .foo show Foo
import .bar show Bar
import 'module' show x
import ./dir/'module' show R, S, T
```

## A Tour of Nyx

> #### Do take note:
>
> This document is an informal reference for Nyx meant as an aid for future programmers, particularly for existing Python, JavaScript, Haskell and Ruby developers, and is structured in a way so you can read it from top to bottom. Further topics use syntax previously introduced.
>
> This is not a flat-out tutorial to the language, but something which you would consult when you have questions. If you feel something is not right and needs correction, feel free to submit a pull request with the changes and I would gladly accept them.

Blocks are delimited by indentation, curly braces, or Ruby-style `then`-`end` blocks. Curly braces are mainly used in case you want to compile Nyx into a more compact form.

```dart
// Python/Haskell style
if true
  run()
if true then run()

// Ruby/Elixir style
if true then run() end
if true then
  run()
end

// Swift/Go style
if true { run() }
if true {
  run()
}

// Multiple inline blocks
for val x in val arr = 1 to 10 if x < 10
  print(x += 10)
```

Outside string ltierals, each block is

```dart
for val [text_batch, label_batch] in train_ds.take(1)
  for val i in range(3)
    print(f'Review: ${text_batch.numpy()[i]}')
    label = label_batch.numpy()[i]
    print(f'Label : ${label} ({class_names[label]})')
```

In Nyx, comments are denoted by the `//` sequence to the end of a line, or from `/*` to the next appearance of `*/`. Documentation comments begin with an extra character and compile specifically to JSDoc comments.

```dart
// from here to the end of the line.
/* comments can be /* nested */. */

/// use these special comments
/** to /** document */ your code. */
```

Everything is an expression\*.

Except commands like `assert`, `break`/`halt`, `continue`/`skip`, `fallthru`, `return`, `yield`, `throw` and more. They can still be included as part of expressions, but once evaluated, return nothing.

### Keywords

A number of keywords are reserved in Nyx.

Some keywords and modifiers are unused; they are reserved for future developments of the language. Keywords formed as part of query (`where`, `group`, `where`, `select` `scan`, `take`, `drop`, `fold`) and module (`show`, `hide`) start a clause.

```
as assert await
break by
case catch check continue
debug def del drop
eless elif else equals export
fail fallthru finally fold for from
goto group guard
halt hide
if import in infer into is
join
key
label len
match
name new
of order out
pass
query
raise redo repeat rescue return
scan select seq show size size skip switch
take then throw til to try type
unless until use
void
when where while with
yield
```

**Declarations** are special keywords that declare program entities like macros, variables, functions and more. They can be preceded by multiple **modifiers**, as shown below.

```
alias
class con const constr
data decl def
enum extend
fn frag fun func
given
inter
let
macro
module
nspace
object
proc
raw record
schema struct style
trait
val var
```

Modifiers prefix a declaration. For example, `pub dyn def init()` which declares a public dynamic method named `init`.

```
abs async
binary
check
dele dyn
eager expl ext extl
final fixed
gen get greedy
handle
immut impl infix inline intl
lazy lock
mut
nary next
over
part prefix prev priv prot pub pvt
rec ref ronly
safe seal set sign size stat suffix sync
ternary trans
unary uncheck unique unsafe unsign unsize
vol
```

### Variables

All variables must be declared with either the `var` or `val` keyword. `var` is used for The type of a variable or value can be omitted and inferred, or it can be explicitly stated:

```dart
val x = 1 + 1
print(x) // 2

x = 3 // This does not compile.

var x = 1 + 1
x = 3 // This does
```

```

```

The type of a value can be omitted and inferred, or it can be explicitly stated:

```dart
val x: Int = 1 + 1
```

Hoisted constants are declared with `let` or `con`.

### Defining Functions

Use the `def` keyword to define functions. Alternatively, use the ES6 fat arrow. Defining functions is very lightweight in Nyx:

```dart
(x, y) => x + y // an inline function
x = () => () // an empty function

times = (x, y) =>
  x * y
// multiple lines, and be assigned to
// a var like in JavaScript
```

As you see, function definitions are considerably shorter! You may also have noticed that we have omitted `return`.

In Nyx, almost In Nyx, almost everything is an expression and the last one reached is automatically returned. However, you can still use `return` to force returns if you want, and you can add a bang `!` right after the arrow to suppress auto-returning:

```dart
noRet = x =>!
```

Assignment Basic assignment is as you would expect, variable = value, and there is no need for variable declarations. However, unlike CoffeeScript, you must use `:=` to modify variables in upper Patts.
